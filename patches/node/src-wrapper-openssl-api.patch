From 108b4239d1630a9aa0c8627fde6ab5a2088cb2be Mon Sep 17 00:00:00 2001
From: Lin Cheng <lin_cheng@dell.com>
Date: Wed, 19 Jun 2024 09:09:41 +0000
Subject: [PATCH 2/2] src: wrapper openssl api

---
 BUILD.gn                        |  17 +-
 src/crypto/crypto_aes.cc        |  68 +++---
 src/crypto/crypto_bio.cc        |  48 ++--
 src/crypto/crypto_bio.h         |   2 +-
 src/crypto/crypto_cipher.cc     | 211 +++++++++--------
 src/crypto/crypto_cipher.h      |   2 +-
 src/crypto/crypto_clienthello.h |   2 +-
 src/crypto/crypto_common.cc     | 387 ++++++++++++++++----------------
 src/crypto/crypto_common.h      |   8 +-
 src/crypto/crypto_context.cc    | 328 +++++++++++++--------------
 src/crypto/crypto_dh.cc         | 151 ++++++-------
 src/crypto/crypto_dsa.cc        |  32 ++-
 src/crypto/crypto_ec.cc         | 220 +++++++++---------
 src/crypto/crypto_hash.cc       |  90 ++++----
 src/crypto/crypto_hkdf.cc       |  22 +-
 src/crypto/crypto_hmac.cc       |  24 +-
 src/crypto/crypto_keygen.cc     |   4 +-
 src/crypto/crypto_keygen.h      |   2 +-
 src/crypto/crypto_keys.cc       | 142 ++++++------
 src/crypto/crypto_keys.h        |   2 +-
 src/crypto/crypto_pbkdf2.cc     |   4 +-
 src/crypto/crypto_random.cc     |  30 +--
 src/crypto/crypto_rsa.cc        | 110 ++++-----
 src/crypto/crypto_scrypt.cc     |   4 +-
 src/crypto/crypto_sig.cc        | 124 +++++-----
 src/crypto/crypto_spkac.cc      |  38 +---
 src/crypto/crypto_spkac.h       |   2 +-
 src/crypto/crypto_timing.cc     |   6 +-
 src/crypto/crypto_tls.cc        | 246 ++++++++++----------
 src/crypto/crypto_tls.h         |  22 +-
 src/crypto/crypto_util.cc       | 143 ++++++------
 src/crypto/crypto_util.h        | 105 ++++-----
 src/crypto/crypto_x509.cc       |  76 +++----
 src/env.h                       |  12 +-
 src/node.cc                     |  31 ++-
 src/node_metadata.cc            |   2 +-
 src/node_metadata.h             |   2 +-
 src/node_options.cc             |   2 +-
 src/node_options.h              |   2 +-
 39 files changed, 1343 insertions(+), 1380 deletions(-)

diff --git a/BUILD.gn b/BUILD.gn
index 4497ccbce9..35c2f44e46 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -258,12 +258,10 @@ if (current_toolchain == electron_js2c_toolchain) {
 
 shared_library("crypto_wrapper") {
   defines = []
-  public_deps = [
-    "//electron:electron_js2c",
-  ]
+  public_deps = []
 
-  configs += [ ":node_internal_config" ]
-  public_configs = [ ":node_lib_config" ]
+  configs += [ ]
+  public_configs = []
   include_dirs = [ "src", "deps/openssl/openssl/include" ]
   libs = []
   frameworks = []
@@ -303,7 +301,6 @@ shared_library("crypto_wrapper") {
 component("node_lib") {
   deps = [
     ":node_js2c_exec",
-    ":crypto_wrapper",
     "deps/googletest:gtest",
     "deps/ada",
     "deps/base64",
@@ -395,7 +392,13 @@ component("node_lib") {
   }
 
   if (node_use_openssl) {
-    deps += [ "//third_party/boringssl" ]
+    #deps += [ "//third_party/boringssl" ]
+    public_deps += [
+      ":crypto_wrapper",
+    ]
+    include_dirs += [
+      "deps/openssl/openssl/include",
+    ]
     sources += [
       "src/crypto/crypto_aes.cc",
       "src/crypto/crypto_aes.h",
diff --git a/src/crypto/crypto_aes.cc b/src/crypto/crypto_aes.cc
index de058d077d..9b1e955efd 100644
--- a/src/crypto/crypto_aes.cc
+++ b/src/crypto/crypto_aes.cc
@@ -9,8 +9,8 @@
 #include "threadpoolwork-inl.h"
 #include "v8.h"
 
-#include <openssl/bn.h>
-#include <openssl/aes.h>
+// #include <openssl/bn.h>
+// #include <openssl/aes.h>
 
 #include <vector>
 
@@ -41,16 +41,16 @@ WebCryptoCipherStatus AES_Cipher(
   CHECK_NOT_NULL(key_data);
   CHECK_EQ(key_data->GetKeyType(), kKeyTypeSecret);
 
-  const int mode = EVP_CIPHER_mode(params.cipher);
+  const int mode = Thin_EVP_CIPHER_mode(params.cipher);
 
-  CipherCtxPointer ctx(EVP_CIPHER_CTX_new());
-  EVP_CIPHER_CTX_init(ctx.get());
+  CipherCtxPointer ctx(Thin_EVP_CIPHER_CTX_new());
+  Thin_EVP_CIPHER_CTX_init(ctx.get());
   if (mode == EVP_CIPH_WRAP_MODE)
-    EVP_CIPHER_CTX_set_flags(ctx.get(), EVP_CIPHER_CTX_FLAG_WRAP_ALLOW);
+    Thin_EVP_CIPHER_CTX_set_flags(ctx.get(), EVP_CIPHER_CTX_FLAG_WRAP_ALLOW);
 
   const bool encrypt = cipher_mode == kWebCryptoCipherEncrypt;
 
-  if (!EVP_CipherInit_ex(
+  if (!Thin_EVP_CipherInit_ex(
           ctx.get(),
           params.cipher,
           nullptr,
@@ -61,7 +61,7 @@ WebCryptoCipherStatus AES_Cipher(
     return WebCryptoCipherStatus::FAILED;
   }
 
-  if (mode == EVP_CIPH_GCM_MODE && !EVP_CIPHER_CTX_ctrl(
+  if (mode == EVP_CIPH_GCM_MODE && !Thin_EVP_CIPHER_CTX_ctrl(
         ctx.get(),
         EVP_CTRL_AEAD_SET_IVLEN,
         params.iv.size(),
@@ -69,10 +69,10 @@ WebCryptoCipherStatus AES_Cipher(
     return WebCryptoCipherStatus::FAILED;
   }
 
-  if (!EVP_CIPHER_CTX_set_key_length(
+  if (!Thin_EVP_CIPHER_CTX_set_key_length(
           ctx.get(),
           key_data->GetSymmetricKeySize()) ||
-      !EVP_CipherInit_ex(
+      !Thin_EVP_CipherInit_ex(
           ctx.get(),
           nullptr,
           nullptr,
@@ -89,7 +89,7 @@ WebCryptoCipherStatus AES_Cipher(
       case kWebCryptoCipherDecrypt:
         // If in decrypt mode, the auth tag must be set in the params.tag.
         CHECK(params.tag);
-        if (!EVP_CIPHER_CTX_ctrl(ctx.get(),
+        if (!Thin_EVP_CIPHER_CTX_ctrl(ctx.get(),
                                  EVP_CTRL_AEAD_SET_TAG,
                                  params.tag.size(),
                                  const_cast<char*>(params.tag.data<char>()))) {
@@ -110,12 +110,12 @@ WebCryptoCipherStatus AES_Cipher(
   }
 
   size_t total = 0;
-  int buf_len = in.size() + EVP_CIPHER_CTX_block_size(ctx.get()) + tag_len;
+  int buf_len = in.size() + Thin_EVP_CIPHER_CTX_block_size(ctx.get()) + tag_len;
   int out_len;
 
   if (mode == EVP_CIPH_GCM_MODE &&
       params.additional_data.size() &&
-      !EVP_CipherUpdate(
+      !Thin_EVP_CipherUpdate(
             ctx.get(),
             nullptr,
             &out_len,
@@ -136,7 +136,7 @@ WebCryptoCipherStatus AES_Cipher(
   // Refs: https://github.com/nodejs/node/pull/38913#issuecomment-866505244
   if (in.size() == 0) {
     out_len = 0;
-  } else if (!EVP_CipherUpdate(ctx.get(),
+  } else if (!Thin_EVP_CipherUpdate(ctx.get(),
                                buf.data<unsigned char>(),
                                &out_len,
                                in.data<unsigned char>(),
@@ -146,8 +146,8 @@ WebCryptoCipherStatus AES_Cipher(
 
   total += out_len;
   CHECK_LE(out_len, buf_len);
-  out_len = EVP_CIPHER_CTX_block_size(ctx.get());
-  if (!EVP_CipherFinal_ex(
+  out_len = Thin_EVP_CIPHER_CTX_block_size(ctx.get());
+  if (!Thin_EVP_CipherFinal_ex(
           ctx.get(), buf.data<unsigned char>() + total, &out_len)) {
     return WebCryptoCipherStatus::FAILED;
   }
@@ -156,7 +156,7 @@ WebCryptoCipherStatus AES_Cipher(
   // If using AES_GCM, grab the generated auth tag and append
   // it to the end of the ciphertext.
   if (cipher_mode == kWebCryptoCipherEncrypt && mode == EVP_CIPH_GCM_MODE) {
-    if (!EVP_CIPHER_CTX_ctrl(ctx.get(),
+    if (!Thin_EVP_CIPHER_CTX_ctrl(ctx.get(),
                              EVP_CTRL_AEAD_GET_TAG,
                              tag_len,
                              buf.data<unsigned char>() + total))
@@ -185,7 +185,7 @@ BignumPointer GetCounter(const AESCipherConfig& params) {
 
   if (remainder == 0) {
     unsigned int byte_length = params.length / CHAR_BIT;
-    return BignumPointer(BN_bin2bn(
+    return BignumPointer(Thin_BN_bin2bn(
         data + params.iv.size() - byte_length,
         byte_length,
         nullptr));
@@ -199,7 +199,7 @@ BignumPointer GetCounter(const AESCipherConfig& params) {
       data + params.iv.size());
   counter[0] &= ~(0xFF << remainder);
 
-  return BignumPointer(BN_bin2bn(counter.data(), counter.size(), nullptr));
+  return BignumPointer(Thin_BN_bin2bn(counter.data(), counter.size(), nullptr));
 }
 
 std::vector<unsigned char> BlockWithZeroedCounter(
@@ -227,10 +227,10 @@ WebCryptoCipherStatus AES_CTR_Cipher2(
     const ByteSource& in,
     unsigned const char* counter,
     unsigned char* out) {
-  CipherCtxPointer ctx(EVP_CIPHER_CTX_new());
+  CipherCtxPointer ctx(Thin_EVP_CIPHER_CTX_new());
   const bool encrypt = cipher_mode == kWebCryptoCipherEncrypt;
 
-  if (!EVP_CipherInit_ex(
+  if (!Thin_EVP_CipherInit_ex(
           ctx.get(),
           params.cipher,
           nullptr,
@@ -243,7 +243,7 @@ WebCryptoCipherStatus AES_CTR_Cipher2(
 
   int out_len = 0;
   int final_len = 0;
-  if (!EVP_CipherUpdate(
+  if (!Thin_EVP_CipherUpdate(
           ctx.get(),
           out,
           &out_len,
@@ -252,7 +252,7 @@ WebCryptoCipherStatus AES_CTR_Cipher2(
     return WebCryptoCipherStatus::FAILED;
   }
 
-  if (!EVP_CipherFinal_ex(ctx.get(), out + out_len, &final_len))
+  if (!Thin_EVP_CipherFinal_ex(ctx.get(), out + out_len, &final_len))
     return WebCryptoCipherStatus::FAILED;
 
   out_len += final_len;
@@ -269,24 +269,24 @@ WebCryptoCipherStatus AES_CTR_Cipher(
     const AESCipherConfig& params,
     const ByteSource& in,
     ByteSource* out) {
-  BignumPointer num_counters(BN_new());
-  if (!BN_lshift(num_counters.get(), BN_value_one(), params.length))
+  BignumPointer num_counters(Thin_BN_new());
+  if (!Thin_BN_lshift(num_counters.get(), Thin_BN_value_one(), params.length))
     return WebCryptoCipherStatus::FAILED;
 
   BignumPointer current_counter = GetCounter(params);
 
-  BignumPointer num_output(BN_new());
+  BignumPointer num_output(Thin_BN_new());
 
-  if (!BN_set_word(num_output.get(), CeilDiv(in.size(), kAesBlockSize)))
+  if (!Thin_BN_set_word(num_output.get(), CeilDiv(in.size(), kAesBlockSize)))
     return WebCryptoCipherStatus::FAILED;
 
   // Just like in chromium's implementation, if the counter will
   // be incremented more than there are counter values, we fail.
-  if (BN_cmp(num_output.get(), num_counters.get()) > 0)
+  if (Thin_BN_cmp(num_output.get(), num_counters.get()) > 0)
     return WebCryptoCipherStatus::FAILED;
 
-  BignumPointer remaining_until_reset(BN_new());
-  if (!BN_sub(remaining_until_reset.get(),
+  BignumPointer remaining_until_reset(Thin_BN_new());
+  if (!Thin_BN_sub(remaining_until_reset.get(),
               num_counters.get(),
               current_counter.get())) {
     return WebCryptoCipherStatus::FAILED;
@@ -298,7 +298,7 @@ WebCryptoCipherStatus AES_CTR_Cipher(
   // Also just like in chromium's implementation, if we can process
   // the input without wrapping the counter, we'll do it as a single
   // call here. If we can't, we'll fallback to the a two-step approach
-  if (BN_cmp(remaining_until_reset.get(), num_output.get()) >= 0) {
+  if (Thin_BN_cmp(remaining_until_reset.get(), num_output.get()) >= 0) {
     auto status = AES_CTR_Cipher2(key_data,
                                   cipher_mode,
                                   params,
@@ -309,7 +309,7 @@ WebCryptoCipherStatus AES_CTR_Cipher(
     return status;
   }
 
-  BN_ULONG blocks_part1 = BN_get_word(remaining_until_reset.get());
+  BN_ULONG blocks_part1 = Thin_BN_get_word(remaining_until_reset.get());
   BN_ULONG input_size_part1 = blocks_part1 * kAesBlockSize;
 
   // Encrypt the first part...
@@ -555,14 +555,14 @@ Maybe<bool> AESCipherTraits::AdditionalConfig(
       UNREACHABLE();
   }
 
-  params->cipher = EVP_get_cipherbynid(cipher_nid);
+  params->cipher = Thin_EVP_get_cipherbynid(cipher_nid);
   if (params->cipher == nullptr) {
     THROW_ERR_CRYPTO_UNKNOWN_CIPHER(env);
     return Nothing<bool>();
   }
 
   if (params->iv.size() <
-      static_cast<size_t>(EVP_CIPHER_iv_length(params->cipher))) {
+      static_cast<size_t>(Thin_EVP_CIPHER_iv_length(params->cipher))) {
     THROW_ERR_CRYPTO_INVALID_IV(env);
     return Nothing<bool>();
   }
diff --git a/src/crypto/crypto_bio.cc b/src/crypto/crypto_bio.cc
index 47045365ce..bf61317fec 100644
--- a/src/crypto/crypto_bio.cc
+++ b/src/crypto/crypto_bio.cc
@@ -24,7 +24,7 @@
 #include "memory_tracker-inl.h"
 #include "util-inl.h"
 
-#include <openssl/bio.h>
+// #include <openssl/bio.h>
 
 #include <climits>
 #include <cstring>
@@ -33,7 +33,7 @@ namespace node {
 namespace crypto {
 
 BIOPointer NodeBIO::New(Environment* env) {
-  BIOPointer bio(BIO_new(GetMethod()));
+  BIOPointer bio(Thin_BIO_new(GetMethod()));
   if (bio && env != nullptr)
     NodeBIO::FromBIO(bio.get())->env_ = env;
   return bio;
@@ -45,8 +45,8 @@ BIOPointer NodeBIO::NewFixed(const char* data, size_t len, Environment* env) {
 
   if (!bio ||
       len > INT_MAX ||
-      BIO_write(bio.get(), data, len) != static_cast<int>(len) ||
-      BIO_set_mem_eof_return(bio.get(), 0) != 1) {
+      Thin_BIO_write(bio.get(), data, len) != static_cast<int>(len) ||
+      Thin_BIO_set_mem_eof_return(bio.get(), 0) != 1) {
     return BIOPointer();
   }
 
@@ -55,8 +55,8 @@ BIOPointer NodeBIO::NewFixed(const char* data, size_t len, Environment* env) {
 
 
 int NodeBIO::New(BIO* bio) {
-  BIO_set_data(bio, new NodeBIO());
-  BIO_set_init(bio, 1);
+  Thin_BIO_set_data(bio, new NodeBIO());
+  Thin_BIO_set_init(bio, 1);
 
   return 1;
 }
@@ -66,10 +66,10 @@ int NodeBIO::Free(BIO* bio) {
   if (bio == nullptr)
     return 0;
 
-  if (BIO_get_shutdown(bio)) {
-    if (BIO_get_init(bio) && BIO_get_data(bio) != nullptr) {
+  if (Thin_BIO_get_shutdown(bio)) {
+    if (Thin_BIO_get_init(bio) && Thin_BIO_get_data(bio) != nullptr) {
       delete FromBIO(bio);
-      BIO_set_data(bio, nullptr);
+      Thin_BIO_set_data(bio, nullptr);
     }
   }
 
@@ -78,7 +78,7 @@ int NodeBIO::Free(BIO* bio) {
 
 
 int NodeBIO::Read(BIO* bio, char* out, int len) {
-  BIO_clear_retry_flags(bio);
+  Thin_BIO_clear_retry_flags(bio);
 
   NodeBIO* nbio = FromBIO(bio);
   int bytes = nbio->Read(out, len);
@@ -86,7 +86,7 @@ int NodeBIO::Read(BIO* bio, char* out, int len) {
   if (bytes == 0) {
     bytes = nbio->eof_return();
     if (bytes != 0) {
-      BIO_set_retry_read(bio);
+      Thin_BIO_set_retry_read(bio);
     }
   }
 
@@ -128,7 +128,7 @@ size_t NodeBIO::PeekMultiple(char** out, size_t* size, size_t* count) {
 
 
 int NodeBIO::Write(BIO* bio, const char* data, int len) {
-  BIO_clear_retry_flags(bio);
+  Thin_BIO_clear_retry_flags(bio);
 
   FromBIO(bio)->Write(data, len);
 
@@ -194,10 +194,10 @@ long NodeBIO::Ctrl(BIO* bio, int cmd, long num,  // NOLINT(runtime/int)
     case BIO_C_GET_BUF_MEM_PTR:
       UNREACHABLE("Can't use GET_BUF_MEM_PTR with NodeBIO");
     case BIO_CTRL_GET_CLOSE:
-      ret = BIO_get_shutdown(bio);
+      ret = Thin_BIO_get_shutdown(bio);
       break;
     case BIO_CTRL_SET_CLOSE:
-      BIO_set_shutdown(bio, num);
+      Thin_BIO_set_shutdown(bio, num);
       break;
     case BIO_CTRL_WPENDING:
       ret = 0;
@@ -222,14 +222,14 @@ long NodeBIO::Ctrl(BIO* bio, int cmd, long num,  // NOLINT(runtime/int)
 const BIO_METHOD* NodeBIO::GetMethod() {
   // Static initialization ensures that this is safe to use concurrently.
   static const BIO_METHOD* method = [&]() {
-    BIO_METHOD* method = BIO_meth_new(BIO_TYPE_MEM, "node.js SSL buffer");
-    BIO_meth_set_write(method, Write);
-    BIO_meth_set_read(method, Read);
-    BIO_meth_set_puts(method, Puts);
-    BIO_meth_set_gets(method, Gets);
-    BIO_meth_set_ctrl(method, Ctrl);
-    BIO_meth_set_create(method, New);
-    BIO_meth_set_destroy(method, Free);
+    BIO_METHOD* method = Thin_BIO_meth_new(BIO_TYPE_MEM, "node.js SSL buffer");
+    Thin_BIO_meth_set_write(method, Write);
+    Thin_BIO_meth_set_read(method, Read);
+    Thin_BIO_meth_set_puts(method, Puts);
+    Thin_BIO_meth_set_gets(method, Gets);
+    Thin_BIO_meth_set_ctrl(method, Ctrl);
+    Thin_BIO_meth_set_create(method, New);
+    Thin_BIO_meth_set_destroy(method, Free);
     return method;
   }();
 
@@ -491,8 +491,8 @@ NodeBIO::~NodeBIO() {
 
 
 NodeBIO* NodeBIO::FromBIO(BIO* bio) {
-  CHECK_NOT_NULL(BIO_get_data(bio));
-  return static_cast<NodeBIO*>(BIO_get_data(bio));
+  CHECK_NOT_NULL(Thin_BIO_get_data(bio));
+  return static_cast<NodeBIO*>(Thin_BIO_get_data(bio));
 }
 
 
diff --git a/src/crypto/crypto_bio.h b/src/crypto/crypto_bio.h
index 7587a353f1..6671258833 100644
--- a/src/crypto/crypto_bio.h
+++ b/src/crypto/crypto_bio.h
@@ -25,7 +25,7 @@
 #if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
 
 #include "node_crypto.h"
-#include "openssl/bio.h"
+// #include "openssl/bio.h"
 #include "util.h"
 #include "v8.h"
 
diff --git a/src/crypto/crypto_cipher.cc b/src/crypto/crypto_cipher.cc
index 7e0e1a6228..1e96f85e3c 100644
--- a/src/crypto/crypto_cipher.cc
+++ b/src/crypto/crypto_cipher.cc
@@ -28,7 +28,7 @@ using v8::Value;
 namespace crypto {
 namespace {
 bool IsSupportedAuthenticatedMode(const EVP_CIPHER* cipher) {
-  const int mode = EVP_CIPHER_mode(cipher);
+  const int mode = Thin_EVP_CIPHER_mode(cipher);
   switch (mode) {
   case EVP_CIPH_CCM_MODE:
   case EVP_CIPH_GCM_MODE:
@@ -37,14 +37,14 @@ bool IsSupportedAuthenticatedMode(const EVP_CIPHER* cipher) {
 #endif
     return true;
   case EVP_CIPH_STREAM_CIPHER:
-    return EVP_CIPHER_nid(cipher) == NID_chacha20_poly1305;
+    return Thin_EVP_CIPHER_nid(cipher) == NID_chacha20_poly1305;
   default:
     return false;
   }
 }
 
 bool IsSupportedAuthenticatedMode(const EVP_CIPHER_CTX* ctx) {
-  const EVP_CIPHER* cipher = EVP_CIPHER_CTX_cipher(ctx);
+  const EVP_CIPHER* cipher = Thin_EVP_CIPHER_CTX_cipher(ctx);
   return IsSupportedAuthenticatedMode(cipher);
 }
 
@@ -63,19 +63,19 @@ void GetCipherInfo(const FunctionCallbackInfo<Value>& args) {
   const EVP_CIPHER* cipher;
   if (args[1]->IsString()) {
     Utf8Value name(env->isolate(), args[1]);
-    cipher = EVP_get_cipherbyname(*name);
+    cipher = Thin_EVP_get_cipherbyname(*name);
   } else {
     int nid = args[1].As<Int32>()->Value();
-    cipher = EVP_get_cipherbynid(nid);
+    cipher = Thin_EVP_get_cipherbynid(nid);
   }
 
   if (cipher == nullptr)
     return;
 
-  int mode = EVP_CIPHER_mode(cipher);
-  int iv_length = EVP_CIPHER_iv_length(cipher);
-  int key_length = EVP_CIPHER_key_length(cipher);
-  int block_length = EVP_CIPHER_block_size(cipher);
+  int mode = Thin_EVP_CIPHER_mode(cipher);
+  int iv_length = Thin_EVP_CIPHER_iv_length(cipher);
+  int key_length = Thin_EVP_CIPHER_key_length(cipher);
+  int block_length = Thin_EVP_CIPHER_block_size(cipher);
   const char* mode_label = nullptr;
   switch (mode) {
     case EVP_CIPH_CBC_MODE: mode_label = "cbc"; break;
@@ -100,13 +100,13 @@ void GetCipherInfo(const FunctionCallbackInfo<Value>& args) {
     // Test and input IV or key length to determine if it's acceptable.
     // If it is, then the getCipherInfo will succeed with the given
     // values.
-    CipherCtxPointer ctx(EVP_CIPHER_CTX_new());
-    if (!EVP_CipherInit_ex(ctx.get(), cipher, nullptr, nullptr, nullptr, 1))
+    CipherCtxPointer ctx(Thin_EVP_CIPHER_CTX_new());
+    if (!Thin_EVP_CipherInit_ex(ctx.get(), cipher, nullptr, nullptr, nullptr, 1))
       return;
 
     if (args[2]->IsInt32()) {
       int check_len = args[2].As<Int32>()->Value();
-      if (!EVP_CIPHER_CTX_set_key_length(ctx.get(), check_len))
+      if (!Thin_EVP_CIPHER_CTX_set_key_length(ctx.get(), check_len))
         return;
       key_length = check_len;
     }
@@ -125,7 +125,7 @@ void GetCipherInfo(const FunctionCallbackInfo<Value>& args) {
         case EVP_CIPH_GCM_MODE:
           // Fall through
         case EVP_CIPH_OCB_MODE:
-          if (!EVP_CIPHER_CTX_ctrl(
+          if (!Thin_EVP_CIPHER_CTX_ctrl(
                   ctx.get(),
                   EVP_CTRL_AEAD_SET_IVLEN,
                   check_len,
@@ -149,21 +149,21 @@ void GetCipherInfo(const FunctionCallbackInfo<Value>& args) {
     return;
   }
 
-  // OBJ_nid2sn(EVP_CIPHER_nid(cipher)) is used here instead of
+  // Thin_OBJ_nid2sn(Thin_EVP_CIPHER_nid(cipher)) is used here instead of
   // EVP_CIPHER_name(cipher) for compatibility with BoringSSL.
   if (info->Set(
           env->context(),
           env->name_string(),
           OneByteString(
             env->isolate(),
-            OBJ_nid2sn(EVP_CIPHER_nid(cipher)))).IsNothing()) {
+            Thin_OBJ_nid2sn(Thin_EVP_CIPHER_nid(cipher)))).IsNothing()) {
     return;
   }
 
   if (info->Set(
           env->context(),
           FIXED_ONE_BYTE_STRING(env->isolate(), "nid"),
-          Int32::New(env->isolate(), EVP_CIPHER_nid(cipher))).IsNothing()) {
+          Int32::New(env->isolate(), Thin_EVP_CIPHER_nid(cipher))).IsNothing()) {
     return;
   }
 
@@ -199,17 +199,17 @@ void GetCipherInfo(const FunctionCallbackInfo<Value>& args) {
 void CipherBase::GetSSLCiphers(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
 
-  SSLCtxPointer ctx(SSL_CTX_new(TLS_method()));
+  SSLCtxPointer ctx(Thin_SSL_CTX_new(Thin_TLS_method()));
   if (!ctx) {
-    return ThrowCryptoError(env, ERR_get_error(), "SSL_CTX_new");
+    return ThrowCryptoError(env, Thin_ERR_get_error(), "Thin_SSL_CTX_new");
   }
 
-  SSLPointer ssl(SSL_new(ctx.get()));
+  SSLPointer ssl(Thin_SSL_new(ctx.get()));
   if (!ssl) {
-    return ThrowCryptoError(env, ERR_get_error(), "SSL_new");
+    return ThrowCryptoError(env, Thin_ERR_get_error(), "Thin_SSL_new");
   }
 
-  STACK_OF(SSL_CIPHER)* ciphers = SSL_get_ciphers(ssl.get());
+  STACK_OF(SSL_CIPHER)* ciphers = Thin_SSL_get_ciphers(ssl.get());
 
   // TLSv1.3 ciphers aren't listed by EVP. There are only 5, we could just
   // document them, but since there are only 5, easier to just add them manually
@@ -223,12 +223,12 @@ void CipherBase::GetSSLCiphers(const FunctionCallbackInfo<Value>& args) {
     "tls_aes_128_ccm_sha256"
   };
 
-  const int n = sk_SSL_CIPHER_num(ciphers);
+  const int n = Thin_sk_SSL_CIPHER_num(ciphers);
   std::vector<Local<Value>> arr(n + arraysize(TLS13_CIPHERS));
 
   for (int i = 0; i < n; ++i) {
-    const SSL_CIPHER* cipher = sk_SSL_CIPHER_value(ciphers, i);
-    arr[i] = OneByteString(env->isolate(), SSL_CIPHER_get_name(cipher));
+    const SSL_CIPHER* cipher = Thin_sk_SSL_CIPHER_value(ciphers, i);
+    arr[i] = OneByteString(env->isolate(), Thin_SSL_CIPHER_get_name(cipher));
   }
 
   for (unsigned i = 0; i < arraysize(TLS13_CIPHERS); ++i) {
@@ -243,13 +243,13 @@ void CipherBase::GetCiphers(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   MarkPopErrorOnReturn mark_pop_error_on_return;
   CipherPushContext ctx(env);
-  EVP_CIPHER_do_all_sorted(
+  Thin_EVP_CIPHER_do_all_sorted(
 #if OPENSSL_VERSION_MAJOR >= 3
     array_push_back<EVP_CIPHER,
-                    EVP_CIPHER_fetch,
-                    EVP_CIPHER_free,
-                    EVP_get_cipherbyname,
-                    EVP_CIPHER_get0_name>,
+                    Thin_EVP_CIPHER_fetch,
+                    Thin_EVP_CIPHER_free,
+                    Thin_EVP_get_cipherbyname,
+                    Thin_EVP_CIPHER_get0_name>,
 #else
     array_push_back<EVP_CIPHER>,
 #endif
@@ -298,26 +298,26 @@ void CipherBase::Initialize(Environment* env, Local<Object> target) {
             target,
             "publicEncrypt",
             PublicKeyCipher::Cipher<PublicKeyCipher::kPublic,
-                                    EVP_PKEY_encrypt_init,
-                                    EVP_PKEY_encrypt>);
+                                    Thin_EVP_PKEY_encrypt_init,
+                                    Thin_EVP_PKEY_encrypt>);
   SetMethod(context,
             target,
             "privateDecrypt",
             PublicKeyCipher::Cipher<PublicKeyCipher::kPrivate,
-                                    EVP_PKEY_decrypt_init,
-                                    EVP_PKEY_decrypt>);
+                                    Thin_EVP_PKEY_decrypt_init,
+                                    Thin_EVP_PKEY_decrypt>);
   SetMethod(context,
             target,
             "privateEncrypt",
             PublicKeyCipher::Cipher<PublicKeyCipher::kPrivate,
-                                    EVP_PKEY_sign_init,
-                                    EVP_PKEY_sign>);
+                                    Thin_EVP_PKEY_sign_init,
+                                    Thin_EVP_PKEY_sign>);
   SetMethod(context,
             target,
             "publicDecrypt",
             PublicKeyCipher::Cipher<PublicKeyCipher::kPublic,
-                                    EVP_PKEY_verify_recover_init,
-                                    EVP_PKEY_verify_recover>);
+                                    Thin_EVP_PKEY_verify_recover_init,
+                                    Thin_EVP_PKEY_verify_recover>);
 
   SetMethodNoSideEffect(context, target, "getCipherInfo", GetCipherInfo);
 
@@ -342,17 +342,17 @@ void CipherBase::RegisterExternalReferences(
   registry->Register(GetCiphers);
 
   registry->Register(PublicKeyCipher::Cipher<PublicKeyCipher::kPublic,
-                                             EVP_PKEY_encrypt_init,
-                                             EVP_PKEY_encrypt>);
+                                             Thin_EVP_PKEY_encrypt_init,
+                                             Thin_EVP_PKEY_encrypt>);
   registry->Register(PublicKeyCipher::Cipher<PublicKeyCipher::kPrivate,
-                                             EVP_PKEY_decrypt_init,
-                                             EVP_PKEY_decrypt>);
+                                             Thin_EVP_PKEY_decrypt_init,
+                                             Thin_EVP_PKEY_decrypt>);
   registry->Register(PublicKeyCipher::Cipher<PublicKeyCipher::kPrivate,
-                                             EVP_PKEY_sign_init,
-                                             EVP_PKEY_sign>);
+                                             Thin_EVP_PKEY_sign_init,
+                                             Thin_EVP_PKEY_sign>);
   registry->Register(PublicKeyCipher::Cipher<PublicKeyCipher::kPublic,
-                                             EVP_PKEY_verify_recover_init,
-                                             EVP_PKEY_verify_recover>);
+                                             Thin_EVP_PKEY_verify_recover_init,
+                                             Thin_EVP_PKEY_verify_recover>);
 
   registry->Register(GetCipherInfo);
 }
@@ -371,16 +371,16 @@ void CipherBase::CommonInit(const char* cipher_type,
                             int iv_len,
                             unsigned int auth_tag_len) {
   CHECK(!ctx_);
-  ctx_.reset(EVP_CIPHER_CTX_new());
+  ctx_.reset(Thin_EVP_CIPHER_CTX_new());
 
-  const int mode = EVP_CIPHER_mode(cipher);
+  const int mode = Thin_EVP_CIPHER_mode(cipher);
   if (mode == EVP_CIPH_WRAP_MODE)
-    EVP_CIPHER_CTX_set_flags(ctx_.get(), EVP_CIPHER_CTX_FLAG_WRAP_ALLOW);
+    Thin_EVP_CIPHER_CTX_set_flags(ctx_.get(), EVP_CIPHER_CTX_FLAG_WRAP_ALLOW);
 
   const bool encrypt = (kind_ == kCipher);
-  if (1 != EVP_CipherInit_ex(ctx_.get(), cipher, nullptr,
+  if (1 != Thin_EVP_CipherInit_ex(ctx_.get(), cipher, nullptr,
                              nullptr, nullptr, encrypt)) {
-    return ThrowCryptoError(env(), ERR_get_error(),
+    return ThrowCryptoError(env(), Thin_ERR_get_error(),
                             "Failed to initialize cipher");
   }
 
@@ -390,13 +390,13 @@ void CipherBase::CommonInit(const char* cipher_type,
       return;
   }
 
-  if (!EVP_CIPHER_CTX_set_key_length(ctx_.get(), key_len)) {
+  if (!Thin_EVP_CIPHER_CTX_set_key_length(ctx_.get(), key_len)) {
     ctx_.reset();
     return THROW_ERR_CRYPTO_INVALID_KEYLEN(env());
   }
 
-  if (1 != EVP_CipherInit_ex(ctx_.get(), nullptr, nullptr, key, iv, encrypt)) {
-    return ThrowCryptoError(env(), ERR_get_error(),
+  if (1 != Thin_EVP_CipherInit_ex(ctx_.get(), nullptr, nullptr, key, iv, encrypt)) {
+    return ThrowCryptoError(env(), Thin_ERR_get_error(),
                             "Failed to initialize cipher");
   }
 }
@@ -407,23 +407,23 @@ void CipherBase::Init(const char* cipher_type,
   HandleScope scope(env()->isolate());
   MarkPopErrorOnReturn mark_pop_error_on_return;
 #if OPENSSL_VERSION_MAJOR >= 3
-  if (EVP_default_properties_is_fips_enabled(nullptr)) {
+  if (Thin_EVP_default_properties_is_fips_enabled(nullptr)) {
 #else
-  if (FIPS_mode()) {
+  if (Thin_FIPS_mode()) {
 #endif
     return THROW_ERR_CRYPTO_UNSUPPORTED_OPERATION(env(),
         "crypto.createCipher() is not supported in FIPS mode.");
   }
 
-  const EVP_CIPHER* const cipher = EVP_get_cipherbyname(cipher_type);
+  const EVP_CIPHER* const cipher = Thin_EVP_get_cipherbyname(cipher_type);
   if (cipher == nullptr)
     return THROW_ERR_CRYPTO_UNKNOWN_CIPHER(env());
 
   unsigned char key[EVP_MAX_KEY_LENGTH];
   unsigned char iv[EVP_MAX_IV_LENGTH];
 
-  int key_len = EVP_BytesToKey(cipher,
-                               EVP_md5(),
+  int key_len = Thin_EVP_BytesToKey(cipher,
+                               Thin_EVP_md5(),
                                nullptr,
                                key_buf.data(),
                                key_buf.size(),
@@ -432,7 +432,7 @@ void CipherBase::Init(const char* cipher_type,
                                iv);
   CHECK_NE(key_len, 0);
 
-  const int mode = EVP_CIPHER_mode(cipher);
+  const int mode = Thin_EVP_CIPHER_mode(cipher);
   if (kind_ == kCipher && (mode == EVP_CIPH_CTR_MODE ||
                            mode == EVP_CIPH_GCM_MODE ||
                            mode == EVP_CIPH_CCM_MODE)) {
@@ -444,7 +444,7 @@ void CipherBase::Init(const char* cipher_type,
   }
 
   CommonInit(cipher_type, cipher, key, key_len, iv,
-             EVP_CIPHER_iv_length(cipher), auth_tag_len);
+             Thin_EVP_CIPHER_iv_length(cipher), auth_tag_len);
 }
 
 void CipherBase::Init(const FunctionCallbackInfo<Value>& args) {
@@ -479,11 +479,11 @@ void CipherBase::InitIv(const char* cipher_type,
   HandleScope scope(env()->isolate());
   MarkPopErrorOnReturn mark_pop_error_on_return;
 
-  const EVP_CIPHER* const cipher = EVP_get_cipherbyname(cipher_type);
+  const EVP_CIPHER* const cipher = Thin_EVP_get_cipherbyname(cipher_type);
   if (cipher == nullptr)
     return THROW_ERR_CRYPTO_UNKNOWN_CIPHER(env());
 
-  const int expected_iv_len = EVP_CIPHER_iv_length(cipher);
+  const int expected_iv_len = Thin_EVP_CIPHER_iv_length(cipher);
   const bool is_authenticated_mode = IsSupportedAuthenticatedMode(cipher);
   const bool has_iv = iv_buf.size() > 0;
 
@@ -500,7 +500,7 @@ void CipherBase::InitIv(const char* cipher_type,
     return THROW_ERR_CRYPTO_INVALID_IV(env());
   }
 
-  if (EVP_CIPHER_nid(cipher) == NID_chacha20_poly1305) {
+  if (Thin_EVP_CIPHER_nid(cipher) == NID_chacha20_poly1305) {
     CHECK(has_iv);
     // Check for invalid IV lengths, since OpenSSL does not under some
     // conditions:
@@ -562,7 +562,7 @@ bool CipherBase::InitAuthenticated(
   CHECK(IsAuthenticatedMode());
   MarkPopErrorOnReturn mark_pop_error_on_return;
 
-  if (!EVP_CIPHER_CTX_ctrl(ctx_.get(),
+  if (!Thin_EVP_CIPHER_CTX_ctrl(ctx_.get(),
                            EVP_CTRL_AEAD_SET_IVLEN,
                            iv_len,
                            nullptr)) {
@@ -570,7 +570,7 @@ bool CipherBase::InitAuthenticated(
     return false;
   }
 
-  const int mode = EVP_CIPHER_CTX_mode(ctx_.get());
+  const int mode = Thin_EVP_CIPHER_CTX_mode(ctx_.get());
   if (mode == EVP_CIPH_GCM_MODE) {
     if (auth_tag_len != kNoAuthTagLength) {
       if (!IsValidGCMTagLength(auth_tag_len)) {
@@ -590,7 +590,7 @@ bool CipherBase::InitAuthenticated(
       // length defaults to 16 bytes when encrypting. Unlike GCM, the
       // authentication tag length also defaults to 16 bytes when decrypting,
       // whereas GCM would accept any valid authentication tag length.
-      if (EVP_CIPHER_CTX_nid(ctx_.get()) == NID_chacha20_poly1305) {
+      if (Thin_EVP_CIPHER_CTX_nid(ctx_.get()) == NID_chacha20_poly1305) {
         auth_tag_len = 16;
       } else {
         THROW_ERR_CRYPTO_INVALID_AUTH_TAG(
@@ -603,9 +603,9 @@ bool CipherBase::InitAuthenticated(
 
 #if OPENSSL_VERSION_MAJOR >= 3
     if (mode == EVP_CIPH_CCM_MODE && kind_ == kDecipher &&
-        EVP_default_properties_is_fips_enabled(nullptr)) {
+        Thin_EVP_default_properties_is_fips_enabled(nullptr)) {
 #else
-    if (mode == EVP_CIPH_CCM_MODE && kind_ == kDecipher && FIPS_mode()) {
+    if (mode == EVP_CIPH_CCM_MODE && kind_ == kDecipher && Thin_FIPS_mode()) {
 #endif
       THROW_ERR_CRYPTO_UNSUPPORTED_OPERATION(env(),
           "CCM encryption not supported in FIPS mode");
@@ -613,7 +613,7 @@ bool CipherBase::InitAuthenticated(
     }
 
     // Tell OpenSSL about the desired length.
-    if (!EVP_CIPHER_CTX_ctrl(ctx_.get(), EVP_CTRL_AEAD_SET_TAG, auth_tag_len,
+    if (!Thin_EVP_CIPHER_CTX_ctrl(ctx_.get(), EVP_CTRL_AEAD_SET_TAG, auth_tag_len,
                              nullptr)) {
       THROW_ERR_CRYPTO_INVALID_AUTH_TAG(
           env(), "Invalid authentication tag length: %u", auth_tag_len);
@@ -637,7 +637,7 @@ bool CipherBase::InitAuthenticated(
 
 bool CipherBase::CheckCCMMessageLength(int message_len) {
   CHECK(ctx_);
-  CHECK(EVP_CIPHER_CTX_mode(ctx_.get()) == EVP_CIPH_CCM_MODE);
+  CHECK(Thin_EVP_CIPHER_CTX_mode(ctx_.get()) == EVP_CIPH_CCM_MODE);
 
   if (message_len > max_message_size_) {
     THROW_ERR_CRYPTO_INVALID_MESSAGELEN(env());
@@ -688,7 +688,7 @@ void CipherBase::SetAuthTag(const FunctionCallbackInfo<Value>& args) {
 
   unsigned int tag_len = auth_tag.size();
 
-  const int mode = EVP_CIPHER_CTX_mode(cipher->ctx_.get());
+  const int mode = Thin_EVP_CIPHER_CTX_mode(cipher->ctx_.get());
   bool is_valid;
   if (mode == EVP_CIPH_GCM_MODE) {
     // Restrict GCM tag lengths according to NIST 800-38d, page 9.
@@ -733,7 +733,7 @@ void CipherBase::SetAuthTag(const FunctionCallbackInfo<Value>& args) {
 
 bool CipherBase::MaybePassAuthTagToOpenSSL() {
   if (auth_tag_state_ == kAuthTagKnown) {
-    if (!EVP_CIPHER_CTX_ctrl(ctx_.get(),
+    if (!Thin_EVP_CIPHER_CTX_ctrl(ctx_.get(),
                              EVP_CTRL_AEAD_SET_TAG,
                              auth_tag_len_,
                              reinterpret_cast<unsigned char*>(auth_tag_))) {
@@ -752,7 +752,7 @@ bool CipherBase::SetAAD(
   MarkPopErrorOnReturn mark_pop_error_on_return;
 
   int outlen;
-  const int mode = EVP_CIPHER_CTX_mode(ctx_.get());
+  const int mode = Thin_EVP_CIPHER_CTX_mode(ctx_.get());
 
   // When in CCM mode, we need to set the authentication tag and the plaintext
   // length in advance.
@@ -772,11 +772,11 @@ bool CipherBase::SetAAD(
     }
 
     // Specify the plaintext length.
-    if (!EVP_CipherUpdate(ctx_.get(), nullptr, &outlen, nullptr, plaintext_len))
+    if (!Thin_EVP_CipherUpdate(ctx_.get(), nullptr, &outlen, nullptr, plaintext_len))
       return false;
   }
 
-  return 1 == EVP_CipherUpdate(ctx_.get(),
+  return 1 == Thin_EVP_CipherUpdate(ctx_.get(),
                                nullptr,
                                &outlen,
                                data.data(),
@@ -806,7 +806,7 @@ CipherBase::UpdateResult CipherBase::Update(
     return kErrorState;
   MarkPopErrorOnReturn mark_pop_error_on_return;
 
-  const int mode = EVP_CIPHER_CTX_mode(ctx_.get());
+  const int mode = Thin_EVP_CIPHER_CTX_mode(ctx_.get());
 
   if (mode == EVP_CIPH_CCM_MODE && !CheckCCMMessageLength(len))
     return kErrorMessageSize;
@@ -816,15 +816,15 @@ CipherBase::UpdateResult CipherBase::Update(
   if (kind_ == kDecipher && IsAuthenticatedMode())
     CHECK(MaybePassAuthTagToOpenSSL());
 
-  const int block_size = EVP_CIPHER_CTX_block_size(ctx_.get());
+  const int block_size = Thin_EVP_CIPHER_CTX_block_size(ctx_.get());
   CHECK_GT(block_size, 0);
   if (len + block_size > INT_MAX) return kErrorState;
   int buf_len = len + block_size;
 
   // For key wrapping algorithms, get output size by calling
-  // EVP_CipherUpdate() with null output.
+  // Thin_EVP_CipherUpdate() with null output.
   if (kind_ == kCipher && mode == EVP_CIPH_WRAP_MODE &&
-      EVP_CipherUpdate(ctx_.get(),
+      Thin_EVP_CipherUpdate(ctx_.get(),
                        nullptr,
                        &buf_len,
                        reinterpret_cast<const unsigned char*>(data),
@@ -837,7 +837,7 @@ CipherBase::UpdateResult CipherBase::Update(
     *out = ArrayBuffer::NewBackingStore(env()->isolate(), buf_len);
   }
 
-  int r = EVP_CipherUpdate(ctx_.get(),
+  int r = Thin_EVP_CipherUpdate(ctx_.get(),
                            static_cast<unsigned char*>((*out)->Data()),
                            &buf_len,
                            reinterpret_cast<const unsigned char*>(data),
@@ -854,7 +854,7 @@ CipherBase::UpdateResult CipherBase::Update(
            buf_len);
   }
 
-  // When in CCM mode, EVP_CipherUpdate will fail if the authentication tag is
+  // When in CCM mode, Thin_EVP_CipherUpdate will fail if the authentication tag is
   // invalid. In that case, remember the error and throw in final().
   if (!r && kind_ == kDecipher && mode == EVP_CIPH_CCM_MODE) {
     pending_auth_failed_ = true;
@@ -877,7 +877,7 @@ void CipherBase::Update(const FunctionCallbackInfo<Value>& args) {
 
     if (r != kSuccess) {
       if (r == kErrorState) {
-        ThrowCryptoError(env, ERR_get_error(),
+        ThrowCryptoError(env, Thin_ERR_get_error(),
                          "Trying to add data in unsupported state");
       }
       return;
@@ -893,7 +893,7 @@ bool CipherBase::SetAutoPadding(bool auto_padding) {
   if (!ctx_)
     return false;
   MarkPopErrorOnReturn mark_pop_error_on_return;
-  return EVP_CIPHER_CTX_set_padding(ctx_.get(), auto_padding);
+  return Thin_EVP_CIPHER_CTX_set_padding(ctx_.get(), auto_padding);
 }
 
 void CipherBase::SetAutoPadding(const FunctionCallbackInfo<Value>& args) {
@@ -908,12 +908,12 @@ bool CipherBase::Final(std::unique_ptr<BackingStore>* out) {
   if (!ctx_)
     return false;
 
-  const int mode = EVP_CIPHER_CTX_mode(ctx_.get());
+  const int mode = Thin_EVP_CIPHER_CTX_mode(ctx_.get());
 
   {
     NoArrayBufferZeroFillScope no_zero_fill_scope(env()->isolate_data());
     *out = ArrayBuffer::NewBackingStore(env()->isolate(),
-        static_cast<size_t>(EVP_CIPHER_CTX_block_size(ctx_.get())));
+        static_cast<size_t>(Thin_EVP_CIPHER_CTX_block_size(ctx_.get())));
   }
 
   if (kind_ == kDecipher && IsSupportedAuthenticatedMode(ctx_.get()))
@@ -921,21 +921,21 @@ bool CipherBase::Final(std::unique_ptr<BackingStore>* out) {
 
   // OpenSSL v1.x doesn't verify the presence of the auth tag so do
   // it ourselves, see https://github.com/nodejs/node/issues/45874.
-  if (OPENSSL_VERSION_NUMBER < 0x30000000L && kind_ == kDecipher &&
-      NID_chacha20_poly1305 == EVP_CIPHER_CTX_nid(ctx_.get()) &&
-      auth_tag_state_ != kAuthTagPassedToOpenSSL) {
-    return false;
-  }
+  // if (OPENSSL_VERSION_NUMBER < 0x30000000L && kind_ == kDecipher &&
+  //     NID_chacha20_poly1305 == Thin_EVP_CIPHER_CTX_nid(ctx_.get()) &&
+  //     auth_tag_state_ != kAuthTagPassedToOpenSSL) {
+  //   return false;
+  // }
 
   // In CCM mode, final() only checks whether authentication failed in update().
-  // EVP_CipherFinal_ex must not be called and will fail.
+  // Thin_EVP_CipherFinal_ex must not be called and will fail.
   bool ok;
   if (kind_ == kDecipher && mode == EVP_CIPH_CCM_MODE) {
     ok = !pending_auth_failed_;
     *out = ArrayBuffer::NewBackingStore(env()->isolate(), 0);
   } else {
     int out_len = (*out)->ByteLength();
-    ok = EVP_CipherFinal_ex(ctx_.get(),
+    ok = Thin_EVP_CipherFinal_ex(ctx_.get(),
                             static_cast<unsigned char*>((*out)->Data()),
                             &out_len) == 1;
 
@@ -958,7 +958,7 @@ bool CipherBase::Final(std::unique_ptr<BackingStore>* out) {
         CHECK(mode == EVP_CIPH_GCM_MODE);
         auth_tag_len_ = sizeof(auth_tag_);
       }
-      ok = (1 == EVP_CIPHER_CTX_ctrl(ctx_.get(), EVP_CTRL_AEAD_GET_TAG,
+      ok = (1 == Thin_EVP_CIPHER_CTX_ctrl(ctx_.get(), EVP_CTRL_AEAD_GET_TAG,
                      auth_tag_len_,
                      reinterpret_cast<unsigned char*>(auth_tag_)));
     }
@@ -988,7 +988,7 @@ void CipherBase::Final(const FunctionCallbackInfo<Value>& args) {
                           ? "Unsupported state or unable to authenticate data"
                           : "Unsupported state";
 
-    return ThrowCryptoError(env, ERR_get_error(), msg);
+    return ThrowCryptoError(env, Thin_ERR_get_error(), msg);
   }
 
   Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(out));
@@ -1007,16 +1007,16 @@ bool PublicKeyCipher::Cipher(
     const ArrayBufferOrViewContents<unsigned char>& oaep_label,
     const ArrayBufferOrViewContents<unsigned char>& data,
     std::unique_ptr<BackingStore>* out) {
-  EVPKeyCtxPointer ctx(EVP_PKEY_CTX_new(pkey.get(), nullptr));
+  EVPKeyCtxPointer ctx(Thin_EVP_PKEY_CTX_new(pkey.get(), nullptr));
   if (!ctx)
     return false;
   if (EVP_PKEY_cipher_init(ctx.get()) <= 0)
     return false;
-  if (EVP_PKEY_CTX_set_rsa_padding(ctx.get(), padding) <= 0)
+  if (Thin_EVP_PKEY_CTX_set_rsa_padding(ctx.get(), padding) <= 0)
     return false;
 
   if (digest != nullptr) {
-    if (EVP_PKEY_CTX_set_rsa_oaep_md(ctx.get(), digest) <= 0)
+    if (Thin_EVP_PKEY_CTX_set_rsa_oaep_md(ctx.get(), digest) <= 0)
       return false;
   }
 
@@ -1080,18 +1080,18 @@ void PublicKeyCipher::Cipher(const FunctionCallbackInfo<Value>& args) {
   uint32_t padding;
   if (!args[offset + 1]->Uint32Value(env->context()).To(&padding)) return;
 
-  if (EVP_PKEY_cipher == EVP_PKEY_decrypt &&
+  if (EVP_PKEY_cipher == Thin_EVP_PKEY_decrypt &&
       operation == PublicKeyCipher::kPrivate && padding == RSA_PKCS1_PADDING &&
       !IsReverted(SECURITY_REVERT_CVE_2023_46809)) {
-    EVPKeyCtxPointer ctx(EVP_PKEY_CTX_new(pkey.get(), nullptr));
+    EVPKeyCtxPointer ctx(Thin_EVP_PKEY_CTX_new(pkey.get(), nullptr));
     CHECK(ctx);
 
-    if (EVP_PKEY_decrypt_init(ctx.get()) <= 0) {
-      return ThrowCryptoError(env, ERR_get_error());
+    if (Thin_EVP_PKEY_decrypt_init(ctx.get()) <= 0) {
+      return ThrowCryptoError(env, Thin_ERR_get_error());
     }
-#ifndef OPENSSL_IS_BORINGSSL
+
     int rsa_pkcs1_implicit_rejection =
-        EVP_PKEY_CTX_ctrl_str(ctx.get(), "rsa_pkcs1_implicit_rejection", "1");
+        Thin_EVP_PKEY_CTX_ctrl_str(ctx.get(), "rsa_pkcs1_implicit_rejection", "1");
     // From the doc -2 means that the option is not supported.
     // The default for the option is enabled and if it has been
     // specifically disabled we want to respect that so we will
@@ -1105,13 +1105,12 @@ void PublicKeyCipher::Cipher(const FunctionCallbackInfo<Value>& args) {
           "RSA_PKCS1_PADDING is no longer supported for private decryption,"
           " this can be reverted with --security-revert=CVE-2023-46809");
     }
-#endif
   }
 
   const EVP_MD* digest = nullptr;
   if (args[offset + 2]->IsString()) {
     const Utf8Value oaep_str(env->isolate(), args[offset + 2]);
-    digest = EVP_get_digestbyname(*oaep_str);
+    digest = Thin_EVP_get_digestbyname(*oaep_str);
     if (digest == nullptr)
       return THROW_ERR_OSSL_EVP_INVALID_DIGEST(env);
   }
@@ -1124,7 +1123,7 @@ void PublicKeyCipher::Cipher(const FunctionCallbackInfo<Value>& args) {
   std::unique_ptr<BackingStore> out;
   if (!Cipher<operation, EVP_PKEY_cipher_init, EVP_PKEY_cipher>(
           env, pkey, padding, digest, oaep_label, buf, &out)) {
-    return ThrowCryptoError(env, ERR_get_error());
+    return ThrowCryptoError(env, Thin_ERR_get_error());
   }
 
   Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(out));
diff --git a/src/crypto/crypto_cipher.h b/src/crypto/crypto_cipher.h
index e725a2f30d..c559b7a650 100644
--- a/src/crypto/crypto_cipher.h
+++ b/src/crypto/crypto_cipher.h
@@ -85,7 +85,7 @@ class CipherBase : public BaseObject {
   CipherBase(Environment* env, v8::Local<v8::Object> wrap, CipherKind kind);
 
  private:
-  DeleteFnPtr<EVP_CIPHER_CTX, EVP_CIPHER_CTX_free> ctx_;
+  DeleteFnPtr<EVP_CIPHER_CTX, Thin_EVP_CIPHER_CTX_free> ctx_;
   const CipherKind kind_;
   AuthTagState auth_tag_state_;
   unsigned int auth_tag_len_;
diff --git a/src/crypto/crypto_clienthello.h b/src/crypto/crypto_clienthello.h
index 3af08bc647..64283b160b 100644
--- a/src/crypto/crypto_clienthello.h
+++ b/src/crypto/crypto_clienthello.h
@@ -30,7 +30,7 @@
 namespace node {
 namespace crypto {
 // Parse the client hello so we can do async session resumption. OpenSSL's
-// session resumption uses synchronous callbacks, see SSL_CTX_sess_set_get_cb
+// session resumption uses synchronous callbacks, see Thin_SSL_CTX_sess_set_get_cb
 // and get_session_cb.
 //
 // TLS1.3 handshakes masquerade as TLS1.2 session resumption, and to do this,
diff --git a/src/crypto/crypto_common.cc b/src/crypto/crypto_common.cc
index 7164e53988..592163f6d7 100644
--- a/src/crypto/crypto_common.cc
+++ b/src/crypto/crypto_common.cc
@@ -9,14 +9,14 @@
 #include "string_bytes.h"
 #include "v8.h"
 
-#include <openssl/ec.h>
-#include <openssl/ecdh.h>
-#include <openssl/evp.h>
-#include <openssl/pem.h>
-#include <openssl/x509v3.h>
-#include <openssl/hmac.h>
-#include <openssl/rand.h>
-#include <openssl/pkcs12.h>
+// #include <openssl/ec.h>
+// #include <openssl/ecdh.h>
+// #include <openssl/evp.h>
+// #include <openssl/pem.h>
+// #include <openssl/x509v3.h>
+// #include <openssl/hmac.h>
+// #include <openssl/rand.h>
+// #include <openssl/pkcs12.h>
 
 #include <string>
 #include <unordered_map>
@@ -52,14 +52,14 @@ static constexpr int kX509NameFlagsRFC2253WithinUtf8JSON =
     ~ASN1_STRFLGS_ESC_CTRL;
 
 X509Pointer SSL_CTX_get_issuer(SSL_CTX* ctx, X509* cert) {
-  X509_STORE* store = SSL_CTX_get_cert_store(ctx);
-  DeleteFnPtr<X509_STORE_CTX, X509_STORE_CTX_free> store_ctx(
-      X509_STORE_CTX_new());
+  X509_STORE* store = Thin_SSL_CTX_get_cert_store(ctx);
+  DeleteFnPtr<X509_STORE_CTX, Thin_X509_STORE_CTX_free> store_ctx(
+      Thin_X509_STORE_CTX_new());
   X509Pointer result;
   X509* issuer;
   if (store_ctx.get() != nullptr &&
-      X509_STORE_CTX_init(store_ctx.get(), store, nullptr, nullptr) == 1 &&
-      X509_STORE_CTX_get1_issuer(&issuer, store_ctx.get(), cert) == 1) {
+      Thin_X509_STORE_CTX_init(store_ctx.get(), store, nullptr, nullptr) == 1 &&
+      Thin_X509_STORE_CTX_get1_issuer(&issuer, store_ctx.get(), cert) == 1) {
     result.reset(issuer);
   }
   return result;
@@ -70,13 +70,13 @@ void LogSecret(
     const char* name,
     const unsigned char* secret,
     size_t secretlen) {
-  auto keylog_cb = SSL_CTX_get_keylog_callback(SSL_get_SSL_CTX(ssl.get()));
+  auto keylog_cb = Thin_SSL_CTX_get_keylog_callback(Thin_SSL_get_SSL_CTX(ssl.get()));
   // All supported versions of TLS/SSL fix the client random to the same size.
   constexpr size_t kTlsClientRandomSize = SSL3_RANDOM_SIZE;
   unsigned char crandom[kTlsClientRandomSize];
 
   if (keylog_cb == nullptr ||
-      SSL_get_client_random(ssl.get(), crandom, kTlsClientRandomSize) !=
+      Thin_SSL_get_client_random(ssl.get(), crandom, kTlsClientRandomSize) !=
           kTlsClientRandomSize) {
     return;
   }
@@ -94,7 +94,7 @@ MaybeLocal<Value> GetSSLOCSPResponse(
     SSL* ssl,
     Local<Value> default_value) {
   const unsigned char* resp;
-  int len = SSL_get_tlsext_status_ocsp_resp(ssl, &resp);
+  int len = Thin_SSL_get_tlsext_status_ocsp_resp(ssl, &resp);
   if (resp == nullptr)
     return default_value;
 
@@ -111,29 +111,29 @@ MaybeLocal<Value> GetSSLOCSPResponse(
 bool SetTLSSession(
     const SSLPointer& ssl,
     const SSLSessionPointer& session) {
-  return session != nullptr && SSL_set_session(ssl.get(), session.get()) == 1;
+  return session != nullptr && Thin_SSL_set_session(ssl.get(), session.get()) == 1;
 }
 
 SSLSessionPointer GetTLSSession(const unsigned char* buf, size_t length) {
-  return SSLSessionPointer(d2i_SSL_SESSION(nullptr, &buf, length));
+  return SSLSessionPointer(Thin_d2i_SSL_SESSION(nullptr, &buf, length));
 }
 
 long VerifyPeerCertificate(  // NOLINT(runtime/int)
     const SSLPointer& ssl,
     long def) {  // NOLINT(runtime/int)
   long err = def;  // NOLINT(runtime/int)
-  if (X509* peer_cert = SSL_get_peer_certificate(ssl.get())) {
-    X509_free(peer_cert);
-    err = SSL_get_verify_result(ssl.get());
+  if (X509* peer_cert = Thin_SSL_get_peer_certificate(ssl.get())) {
+    Thin_X509_free(peer_cert);
+    err = Thin_SSL_get_verify_result(ssl.get());
   } else {
-    const SSL_CIPHER* curr_cipher = SSL_get_current_cipher(ssl.get());
-    const SSL_SESSION* sess = SSL_get_session(ssl.get());
+    const SSL_CIPHER* curr_cipher = Thin_SSL_get_current_cipher(ssl.get());
+    const SSL_SESSION* sess = Thin_SSL_get_session(ssl.get());
     // Allow no-cert for PSK authentication in TLS1.2 and lower.
     // In TLS1.3 check that session was reused because TLS1.3 PSK
     // looks like session resumption.
-    if (SSL_CIPHER_get_auth_nid(curr_cipher) == NID_auth_psk ||
-        (SSL_SESSION_get_protocol_version(sess) == TLS1_3_VERSION &&
-         SSL_session_reused(ssl.get()))) {
+    if (Thin_SSL_CIPHER_get_auth_nid(curr_cipher) == NID_auth_psk ||
+        (Thin_SSL_SESSION_get_protocol_version(sess) == TLS1_3_VERSION &&
+         Thin_SSL_session_reused(ssl.get()))) {
       return X509_V_OK;
     }
   }
@@ -143,14 +143,14 @@ long VerifyPeerCertificate(  // NOLINT(runtime/int)
 bool UseSNIContext(
     const SSLPointer& ssl, BaseObjectPtr<SecureContext> context) {
   SSL_CTX* ctx = context->ctx().get();
-  X509* x509 = SSL_CTX_get0_certificate(ctx);
-  EVP_PKEY* pkey = SSL_CTX_get0_privatekey(ctx);
+  X509* x509 = Thin_SSL_CTX_get0_certificate(ctx);
+  EVP_PKEY* pkey = Thin_SSL_CTX_get0_privatekey(ctx);
   STACK_OF(X509)* chain;
 
-  int err = SSL_CTX_get0_chain_certs(ctx, &chain);
-  if (err == 1) err = SSL_use_certificate(ssl.get(), x509);
-  if (err == 1) err = SSL_use_PrivateKey(ssl.get(), pkey);
-  if (err == 1 && chain != nullptr) err = SSL_set1_chain(ssl.get(), chain);
+  int err = Thin_SSL_CTX_get0_chain_certs(ctx, &chain);
+  if (err == 1) err = Thin_SSL_use_certificate(ssl.get(), x509);
+  if (err == 1) err = Thin_SSL_use_PrivateKey(ssl.get(), pkey);
+  if (err == 1 && chain != nullptr) err = Thin_SSL_set1_chain(ssl.get(), chain);
   return err == 1;
 }
 
@@ -158,8 +158,8 @@ const char* GetClientHelloALPN(const SSLPointer& ssl) {
   const unsigned char* buf;
   size_t len;
   size_t rem;
-#ifndef OPENSSL_IS_BORINGSSL
-  if (!SSL_client_hello_get0_ext(
+
+  if (!Thin_SSL_client_hello_get0_ext(
           ssl.get(),
           TLSEXT_TYPE_application_layer_protocol_negotiation,
           &buf,
@@ -171,16 +171,14 @@ const char* GetClientHelloALPN(const SSLPointer& ssl) {
   len = (buf[0] << 8) | buf[1];
   if (len + 2 != rem) return nullptr;
   return reinterpret_cast<const char*>(buf + 3);
-#endif
-  return nullptr;
 }
 
 const char* GetClientHelloServerName(const SSLPointer& ssl) {
   const unsigned char* buf;
   size_t len;
   size_t rem;
-#ifndef OPENSSL_IS_BORINGSSL
-  if (!SSL_client_hello_get0_ext(
+
+  if (!Thin_SSL_client_hello_get0_ext(
           ssl.get(),
           TLSEXT_TYPE_server_name,
           &buf,
@@ -201,19 +199,14 @@ const char* GetClientHelloServerName(const SSLPointer& ssl) {
   if (len + 2 > rem)
     return nullptr;
   return reinterpret_cast<const char*>(buf + 5);
-#endif
-  return nullptr;
 }
 
 const char* GetServerName(SSL* ssl) {
-  return SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name);
+  return Thin_SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name);
 }
 
  bool SetGroups(SecureContext* sc, const char* groups) {
-#ifndef OPENSSL_IS_BORINGSSL
-   return SSL_CTX_set1_groups_list(sc->ctx().get(), groups) == 1;
-#endif
-  return SSL_CTX_set1_curves_list(sc->ctx().get(), groups) == 1;
+   return Thin_SSL_CTX_set1_groups_list(sc->ctx().get(), groups) == 1;
  }
 
 const char* X509ErrorCode(long err) {  // NOLINT(runtime/int)
@@ -258,7 +251,7 @@ const char* X509ErrorCode(long err) {  // NOLINT(runtime/int)
 MaybeLocal<Value> GetValidationErrorReason(Environment* env, int err) {
   if (err == 0)
     return Undefined(env->isolate());
-  const char* reason = X509_verify_cert_error_string(err);
+  const char* reason = Thin_X509_verify_cert_error_string(err);
   return OneByteString(env->isolate(), reason);
 }
 
@@ -270,7 +263,7 @@ MaybeLocal<Value> GetValidationErrorCode(Environment* env, int err) {
 
 MaybeLocal<Value> GetCert(Environment* env, const SSLPointer& ssl) {
   ClearErrorOnReturn clear_error_on_return;
-  X509* cert = SSL_get_certificate(ssl.get());
+  X509* cert = Thin_SSL_get_certificate(ssl.get());
   if (cert == nullptr)
     return Undefined(env->isolate());
 
@@ -280,14 +273,14 @@ MaybeLocal<Value> GetCert(Environment* env, const SSLPointer& ssl) {
 
 Local<Value> ToV8Value(Environment* env, const BIOPointer& bio) {
   BUF_MEM* mem;
-  BIO_get_mem_ptr(bio.get(), &mem);
+  Thin_BIO_get_mem_ptr(bio.get(), &mem);
   MaybeLocal<String> ret =
       String::NewFromUtf8(
           env->isolate(),
           mem->data,
           NewStringType::kNormal,
           mem->length);
-  CHECK_EQ(BIO_reset(bio.get()), 1);
+  CHECK_EQ(Thin_BIO_reset(bio.get()), 1);
   return ret.FromMaybe(Local<Value>());
 }
 
@@ -317,19 +310,19 @@ MaybeLocal<Value> GetCipherValue(Environment* env, const SSL_CIPHER* cipher) {
   return OneByteString(env->isolate(), getstr(cipher));
 }
 
-constexpr auto GetCipherName = GetCipherValue<SSL_CIPHER_get_name>;
-constexpr auto GetCipherStandardName = GetCipherValue<SSL_CIPHER_standard_name>;
-constexpr auto GetCipherVersion = GetCipherValue<SSL_CIPHER_get_version>;
+constexpr auto GetCipherName = GetCipherValue<Thin_SSL_CIPHER_get_name>;
+constexpr auto GetCipherStandardName = GetCipherValue<Thin_SSL_CIPHER_standard_name>;
+constexpr auto GetCipherVersion = GetCipherValue<Thin_SSL_CIPHER_get_version>;
 
 StackOfX509 CloneSSLCerts(X509Pointer&& cert,
                           const STACK_OF(X509)* const ssl_certs) {
-  StackOfX509 peer_certs(sk_X509_new(nullptr));
+  StackOfX509 peer_certs(Thin_sk_X509_new(nullptr));
   if (!peer_certs) return StackOfX509();
-  if (cert && !sk_X509_push(peer_certs.get(), cert.release()))
+  if (cert && !Thin_sk_X509_push(peer_certs.get(), cert.release()))
     return StackOfX509();
-  for (int i = 0; i < sk_X509_num(ssl_certs); i++) {
-    X509Pointer cert(X509_dup(sk_X509_value(ssl_certs, i)));
-    if (!cert || !sk_X509_push(peer_certs.get(), cert.get()))
+  for (int i = 0; i < Thin_sk_X509_num(ssl_certs); i++) {
+    X509Pointer cert(Thin_X509_dup(Thin_sk_X509_value(ssl_certs, i)));
+    if (!cert || !Thin_sk_X509_push(peer_certs.get(), cert.get()))
       return StackOfX509();
     // `cert` is now managed by the stack.
     cert.release();
@@ -343,12 +336,12 @@ MaybeLocal<Object> AddIssuerChainToObject(
     StackOfX509&& peer_certs,
     Environment* const env) {
   Local<Context> context = env->isolate()->GetCurrentContext();
-  cert->reset(sk_X509_delete(peer_certs.get(), 0));
+  cert->reset(Thin_sk_X509_delete(peer_certs.get(), 0));
   for (;;) {
     int i;
-    for (i = 0; i < sk_X509_num(peer_certs.get()); i++) {
-      X509* ca = sk_X509_value(peer_certs.get(), i);
-      if (X509_check_issued(ca, cert->get()) != X509_V_OK)
+    for (i = 0; i < Thin_sk_X509_num(peer_certs.get()); i++) {
+      X509* ca = Thin_sk_X509_value(peer_certs.get(), i);
+      if (Thin_X509_check_issued(ca, cert->get()) != X509_V_OK)
         continue;
 
       Local<Object> ca_info;
@@ -362,12 +355,12 @@ MaybeLocal<Object> AddIssuerChainToObject(
 
       // NOTE: Intentionally freeing cert that is not used anymore.
       // Delete cert and continue aggregating issuers.
-      cert->reset(sk_X509_delete(peer_certs.get(), i));
+      cert->reset(Thin_sk_X509_delete(peer_certs.get(), i));
       break;
     }
 
     // Issuer not found, break out of the loop.
-    if (i == sk_X509_num(peer_certs.get()))
+    if (i == Thin_sk_X509_num(peer_certs.get()))
       break;
   }
   return MaybeLocal<Object>(object);
@@ -379,9 +372,9 @@ MaybeLocal<Object> GetLastIssuedCert(
     Local<Object> issuer_chain,
     Environment* const env) {
   Local<Context> context = env->isolate()->GetCurrentContext();
-  while (X509_check_issued(cert->get(), cert->get()) != X509_V_OK) {
+  while (Thin_X509_check_issued(cert->get(), cert->get()) != X509_V_OK) {
     X509Pointer ca;
-    if (!(ca = SSL_CTX_get_issuer(SSL_get_SSL_CTX(ssl.get()), cert->get())))
+    if (!(ca = SSL_CTX_get_issuer(Thin_SSL_get_SSL_CTX(ssl.get()), cert->get())))
       break;
 
     Local<Object> ca_info;
@@ -394,7 +387,7 @@ MaybeLocal<Object> GetLastIssuedCert(
     issuer_chain = ca_info;
 
     // For self-signed certificates whose keyUsage field does not include
-    // keyCertSign, X509_check_issued() will return false. Avoid going into an
+    // keyCertSign, Thin_X509_check_issued() will return false. Avoid going into an
     // infinite loop by checking if SSL_CTX_get_issuer() returned the same
     // certificate.
     if (cert->get() == ca.get()) break;
@@ -434,7 +427,7 @@ MaybeLocal<Value> GetECPubKey(
     Environment* env,
     const EC_GROUP* group,
     const ECPointer& ec) {
-  const EC_POINT* pubkey = EC_KEY_get0_public_key(ec.get());
+  const EC_POINT* pubkey = Thin_EC_KEY_get0_public_key(ec.get());
   if (pubkey == nullptr)
     return Undefined(env->isolate());
 
@@ -442,7 +435,7 @@ MaybeLocal<Value> GetECPubKey(
       env,
       group,
       pubkey,
-      EC_KEY_get_conv_form(ec.get()),
+      Thin_EC_KEY_get_conv_form(ec.get()),
       nullptr).FromMaybe(Local<Object>());
 }
 
@@ -453,7 +446,7 @@ MaybeLocal<Value> GetECGroup(
   if (group == nullptr)
     return Undefined(env->isolate());
 
-  int bits = EC_GROUP_order_bits(group);
+  int bits = Thin_EC_GROUP_order_bits(group);
   if (bits <= 0)
     return Undefined(env->isolate());
 
@@ -461,7 +454,7 @@ MaybeLocal<Value> GetECGroup(
 }
 
 MaybeLocal<Object> GetPubKey(Environment* env, const RSAPointer& rsa) {
-  int size = i2d_RSA_PUBKEY(rsa.get(), nullptr);
+  int size = Thin_i2d_RSA_PUBKEY(rsa.get(), nullptr);
   CHECK_GE(size, 0);
 
   std::unique_ptr<BackingStore> bs;
@@ -471,7 +464,7 @@ MaybeLocal<Object> GetPubKey(Environment* env, const RSAPointer& rsa) {
   }
 
   unsigned char* serialized = reinterpret_cast<unsigned char*>(bs->Data());
-  CHECK_GE(i2d_RSA_PUBKEY(rsa.get(), &serialized), 0);
+  CHECK_GE(Thin_i2d_RSA_PUBKEY(rsa.get(), &serialized), 0);
 
   Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
   return Buffer::New(env, ab, 0, ab->ByteLength()).FromMaybe(Local<Object>());
@@ -481,26 +474,26 @@ MaybeLocal<Value> GetExponentString(
     Environment* env,
     const BIOPointer& bio,
     const BIGNUM* e) {
-  uint64_t exponent_word = static_cast<uint64_t>(BN_get_word(e));
-  BIO_printf(bio.get(), "0x%" PRIx64, exponent_word);
+  uint64_t exponent_word = static_cast<uint64_t>(Thin_BN_get_word(e));
+  Thin_BIO_printf(bio.get(), "0x%" PRIx64, exponent_word);
   return ToV8Value(env, bio);
 }
 
 Local<Value> GetBits(Environment* env, const BIGNUM* n) {
-  return Integer::New(env->isolate(), BN_num_bits(n));
+  return Integer::New(env->isolate(), Thin_BN_num_bits(n));
 }
 
 MaybeLocal<Value> GetModulusString(
     Environment* env,
     const BIOPointer& bio,
     const BIGNUM* n) {
-  BN_print(bio.get(), n);
+  Thin_BN_print(bio.get(), n);
   return ToV8Value(env, bio);
 }
 }  // namespace
 
 MaybeLocal<Value> GetRawDERCertificate(Environment* env, X509* cert) {
-  int size = i2d_X509(cert, nullptr);
+  int size = Thin_i2d_X509(cert, nullptr);
 
   std::unique_ptr<BackingStore> bs;
   {
@@ -509,17 +502,17 @@ MaybeLocal<Value> GetRawDERCertificate(Environment* env, X509* cert) {
   }
 
   unsigned char* serialized = reinterpret_cast<unsigned char*>(bs->Data());
-  CHECK_GE(i2d_X509(cert, &serialized), 0);
+  CHECK_GE(Thin_i2d_X509(cert, &serialized), 0);
 
   Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
   return Buffer::New(env, ab, 0, ab->ByteLength()).FromMaybe(Local<Object>());
 }
 
 MaybeLocal<Value> GetSerialNumber(Environment* env, X509* cert) {
-  if (ASN1_INTEGER* serial_number = X509_get_serialNumber(cert)) {
-    BignumPointer bn(ASN1_INTEGER_to_BN(serial_number, nullptr));
+  if (ASN1_INTEGER* serial_number = Thin_X509_get_serialNumber(cert)) {
+    BignumPointer bn(Thin_ASN1_INTEGER_to_BN(serial_number, nullptr));
     if (bn) {
-      char* data = BN_bn2hex(bn.get());
+      char* data = Thin_BN_bn2hex(bn.get());
       ByteSource buf = ByteSource::Allocated(data, strlen(data));
       if (buf) return OneByteString(env->isolate(), buf.data<unsigned char>());
     }
@@ -530,17 +523,17 @@ MaybeLocal<Value> GetSerialNumber(Environment* env, X509* cert) {
 
 MaybeLocal<Value> GetKeyUsage(Environment* env, X509* cert) {
   StackOfASN1 eku(static_cast<STACK_OF(ASN1_OBJECT)*>(
-      X509_get_ext_d2i(cert, NID_ext_key_usage, nullptr, nullptr)));
+      Thin_X509_get_ext_d2i(cert, NID_ext_key_usage, nullptr, nullptr)));
   if (eku) {
-    const int count = sk_ASN1_OBJECT_num(eku.get());
+    const int count = Thin_sk_ASN1_OBJECT_num(eku.get());
     MaybeStackBuffer<Local<Value>, 16> ext_key_usage(count);
     char buf[256];
 
     int j = 0;
     for (int i = 0; i < count; i++) {
-      if (OBJ_obj2txt(buf,
+      if (Thin_OBJ_obj2txt(buf,
                       sizeof(buf),
-                      sk_ASN1_OBJECT_value(eku.get(), i), 1) >= 0) {
+                      Thin_sk_ASN1_OBJECT_value(eku.get(), i), 1) >= 0) {
         ext_key_usage[j++] = OneByteString(env->isolate(), buf);
       }
     }
@@ -553,12 +546,12 @@ MaybeLocal<Value> GetKeyUsage(Environment* env, X509* cert) {
 
 MaybeLocal<Value> GetCurrentCipherName(Environment* env,
                                        const SSLPointer& ssl) {
-  return GetCipherName(env, SSL_get_current_cipher(ssl.get()));
+  return GetCipherName(env, Thin_SSL_get_current_cipher(ssl.get()));
 }
 
 MaybeLocal<Value> GetCurrentCipherVersion(Environment* env,
                                           const SSLPointer& ssl) {
-  return GetCipherVersion(env, SSL_get_current_cipher(ssl.get()));
+  return GetCipherVersion(env, Thin_SSL_get_current_cipher(ssl.get()));
 }
 
 MaybeLocal<Value> GetFingerprintDigest(
@@ -569,7 +562,7 @@ MaybeLocal<Value> GetFingerprintDigest(
   unsigned int md_size;
   char fingerprint[EVP_MAX_MD_SIZE * 3];
 
-  if (X509_digest(cert, method, md, &md_size)) {
+  if (Thin_X509_digest(cert, method, md, &md_size)) {
     AddFingerprintDigest(md, md_size, fingerprint);
     return OneByteString(env->isolate(), fingerprint);
   }
@@ -580,7 +573,7 @@ MaybeLocal<Value> GetValidTo(
     Environment* env,
     X509* cert,
     const BIOPointer& bio) {
-  ASN1_TIME_print(bio.get(), X509_get0_notAfter(cert));
+  Thin_ASN1_TIME_print(bio.get(), Thin_X509_get0_notAfter(cert));
   return ToV8Value(env, bio);
 }
 
@@ -588,7 +581,7 @@ MaybeLocal<Value> GetValidFrom(
     Environment* env,
     X509* cert,
     const BIOPointer& bio) {
-  ASN1_TIME_print(bio.get(), X509_get0_notBefore(cert));
+  Thin_ASN1_TIME_print(bio.get(), Thin_X509_get0_notBefore(cert));
   return ToV8Value(env, bio);
 }
 
@@ -637,23 +630,23 @@ static inline void PrintAltName(const BIOPointer& out, const char* name,
     // For backward-compatibility, append "safe" names without any
     // modifications.
     if (safe_prefix != nullptr) {
-      BIO_printf(out.get(), "%s:", safe_prefix);
+      Thin_BIO_printf(out.get(), "%s:", safe_prefix);
     }
-    BIO_write(out.get(), name, length);
+    Thin_BIO_write(out.get(), name, length);
   } else {
     // If a name is not "safe", we cannot embed it without special
     // encoding. This does not usually happen, but we don't want to hide
     // it from the user either. We use JSON compatible escaping here.
-    BIO_write(out.get(), "\"", 1);
+    Thin_BIO_write(out.get(), "\"", 1);
     if (safe_prefix != nullptr) {
-      BIO_printf(out.get(), "%s:", safe_prefix);
+      Thin_BIO_printf(out.get(), "%s:", safe_prefix);
     }
     for (size_t j = 0; j < length; j++) {
       char c = static_cast<char>(name[j]);
       if (c == '\\') {
-        BIO_write(out.get(), "\\\\", 2);
+        Thin_BIO_write(out.get(), "\\\\", 2);
       } else if (c == '"') {
-        BIO_write(out.get(), "\\\"", 2);
+        Thin_BIO_write(out.get(), "\\\"", 2);
       } else if ((c >= ' ' && c != ',' && c <= '~') || (utf8 && (c & 0x80))) {
         // Note that the above condition explicitly excludes commas, which means
         // that those are encoded as Unicode escape sequences in the "else"
@@ -661,16 +654,16 @@ static inline void PrintAltName(const BIOPointer& out, const char* name,
         // it correctly either way. We only do this to account for third-party
         // code that might be splitting the string at commas (as Node.js itself
         // used to do).
-        BIO_write(out.get(), &c, 1);
+        Thin_BIO_write(out.get(), &c, 1);
       } else {
         // Control character or non-ASCII character. We treat everything as
         // Latin-1, which corresponds to the first 255 Unicode code points.
         const char hex[] = "0123456789abcdef";
         char u[] = { '\\', 'u', '0', '0', hex[(c & 0xf0) >> 4], hex[c & 0x0f] };
-        BIO_write(out.get(), u, sizeof(u));
+        Thin_BIO_write(out.get(), u, sizeof(u));
       }
     }
-    BIO_write(out.get(), "\"", 1);
+    Thin_BIO_write(out.get(), "\"", 1);
   }
 }
 
@@ -688,45 +681,45 @@ static inline void PrintUtf8AltName(const BIOPointer& out,
                true, safe_prefix);
 }
 
-// This function emulates the behavior of i2v_GENERAL_NAME in a safer and less
+// This function emulates the behavior of Thin_i2v_GENERAL_NAME in a safer and less
 // ambiguous way. "othername:" entries use the GENERAL_NAME_print format.
 static bool PrintGeneralName(const BIOPointer& out, const GENERAL_NAME* gen) {
   if (gen->type == GEN_DNS) {
     ASN1_IA5STRING* name = gen->d.dNSName;
-    BIO_write(out.get(), "DNS:", 4);
+    Thin_BIO_write(out.get(), "DNS:", 4);
     // Note that the preferred name syntax (see RFCs 5280 and 1034) with
     // wildcards is a subset of what we consider "safe", so spec-compliant DNS
     // names will never need to be escaped.
     PrintLatin1AltName(out, name);
   } else if (gen->type == GEN_EMAIL) {
     ASN1_IA5STRING* name = gen->d.rfc822Name;
-    BIO_write(out.get(), "email:", 6);
+    Thin_BIO_write(out.get(), "email:", 6);
     PrintLatin1AltName(out, name);
   } else if (gen->type == GEN_URI) {
     ASN1_IA5STRING* name = gen->d.uniformResourceIdentifier;
-    BIO_write(out.get(), "URI:", 4);
+    Thin_BIO_write(out.get(), "URI:", 4);
     // The set of "safe" names was designed to include just about any URI,
     // with a few exceptions, most notably URIs that contains commas (see
     // RFC 2396). In other words, most legitimate URIs will not require
     // escaping.
     PrintLatin1AltName(out, name);
   } else if (gen->type == GEN_DIRNAME) {
-    // Earlier versions of Node.js used X509_NAME_oneline to print the X509_NAME
+    // Earlier versions of Node.js used Thin_X509_NAME_oneline to print the X509_NAME
     // object. The format was non standard and should be avoided. The use of
-    // X509_NAME_oneline is discouraged by OpenSSL but was required for backward
-    // compatibility. Conveniently, X509_NAME_oneline produced ASCII and the
+    // Thin_X509_NAME_oneline is discouraged by OpenSSL but was required for backward
+    // compatibility. Conveniently, Thin_X509_NAME_oneline produced ASCII and the
     // output was unlikely to contains commas or other characters that would
     // require escaping. However, it SHOULD NOT produce ASCII output since an
     // RFC5280 AttributeValue may be a UTF8String.
-    // Newer versions of Node.js have since switched to X509_NAME_print_ex to
+    // Newer versions of Node.js have since switched to Thin_X509_NAME_print_ex to
     // produce a better format at the cost of backward compatibility. The new
     // format may contain Unicode characters and it is likely to contain commas,
     // which require escaping. Fortunately, the recently safeguarded function
     // PrintAltName handles all of that safely.
-    BIO_printf(out.get(), "DirName:");
-    BIOPointer tmp(BIO_new(BIO_s_mem()));
+    Thin_BIO_printf(out.get(), "DirName:");
+    BIOPointer tmp(Thin_BIO_new(Thin_BIO_s_mem()));
     CHECK(tmp);
-    if (X509_NAME_print_ex(tmp.get(),
+    if (Thin_X509_NAME_print_ex(tmp.get(),
                            gen->d.dirn,
                            0,
                            kX509NameFlagsRFC2253WithinUtf8JSON) < 0) {
@@ -738,40 +731,40 @@ static bool PrintGeneralName(const BIOPointer& out, const GENERAL_NAME* gen) {
     CHECK_IMPLIES(n_bytes != 0, oline != nullptr);
     PrintAltName(out, oline, static_cast<size_t>(n_bytes), true, nullptr);
   } else if (gen->type == GEN_IPADD) {
-    BIO_printf(out.get(), "IP Address:");
+    Thin_BIO_printf(out.get(), "IP Address:");
     const ASN1_OCTET_STRING* ip = gen->d.ip;
     const unsigned char* b = ip->data;
     if (ip->length == 4) {
-      BIO_printf(out.get(), "%d.%d.%d.%d", b[0], b[1], b[2], b[3]);
+      Thin_BIO_printf(out.get(), "%d.%d.%d.%d", b[0], b[1], b[2], b[3]);
     } else if (ip->length == 16) {
       for (unsigned int j = 0; j < 8; j++) {
         uint16_t pair = (b[2 * j] << 8) | b[2 * j + 1];
-        BIO_printf(out.get(), (j == 0) ? "%X" : ":%X", pair);
+        Thin_BIO_printf(out.get(), (j == 0) ? "%X" : ":%X", pair);
       }
     } else {
 #if OPENSSL_VERSION_MAJOR >= 3
-      BIO_printf(out.get(), "<invalid length=%d>", ip->length);
+      Thin_BIO_printf(out.get(), "<invalid length=%d>", ip->length);
 #else
-      BIO_printf(out.get(), "<invalid>");
+      Thin_BIO_printf(out.get(), "<invalid>");
 #endif
     }
   } else if (gen->type == GEN_RID) {
     // Unlike OpenSSL's default implementation, never print the OID as text and
     // instead always print its numeric representation.
     char oline[256];
-    OBJ_obj2txt(oline, sizeof(oline), gen->d.rid, true);
-    BIO_printf(out.get(), "Registered ID:%s", oline);
+    Thin_OBJ_obj2txt(oline, sizeof(oline), gen->d.rid, true);
+    Thin_BIO_printf(out.get(), "Registered ID:%s", oline);
   } else if (gen->type == GEN_OTHERNAME) {
     // The format that is used here is based on OpenSSL's implementation of
     // GENERAL_NAME_print (as of OpenSSL 3.0.1). Earlier versions of Node.js
-    // instead produced the same format as i2v_GENERAL_NAME, which was somewhat
+    // instead produced the same format as Thin_i2v_GENERAL_NAME, which was somewhat
     // awkward, especially when passed to translatePeerCertificate.
     bool unicode = true;
     const char* prefix = nullptr;
     // OpenSSL 1.1.1 does not support othername in GENERAL_NAME_print and may
     // not define these NIDs.
 #if OPENSSL_VERSION_MAJOR >= 3
-    int nid = OBJ_obj2nid(gen->d.otherName->type_id);
+    int nid = Thin_OBJ_obj2nid(gen->d.otherName->type_id);
     switch (nid) {
       case NID_id_on_SmtpUTF8Mailbox:
         prefix = "SmtpUTF8Mailbox";
@@ -795,9 +788,9 @@ static bool PrintGeneralName(const BIOPointer& out, const GENERAL_NAME* gen) {
     if (prefix == nullptr ||
         (unicode && val_type != V_ASN1_UTF8STRING) ||
         (!unicode && val_type != V_ASN1_IA5STRING)) {
-      BIO_printf(out.get(), "othername:<unsupported>");
+      Thin_BIO_printf(out.get(), "othername:<unsupported>");
     } else {
-      BIO_printf(out.get(), "othername:");
+      Thin_BIO_printf(out.get(), "othername:");
       if (unicode) {
         PrintUtf8AltName(out, gen->d.otherName->value->value.utf8string,
                          prefix);
@@ -808,12 +801,12 @@ static bool PrintGeneralName(const BIOPointer& out, const GENERAL_NAME* gen) {
     }
   } else if (gen->type == GEN_X400) {
     // TODO(tniessen): this is what OpenSSL does, implement properly instead
-    BIO_printf(out.get(), "X400Name:<unsupported>");
+    Thin_BIO_printf(out.get(), "X400Name:<unsupported>");
   } else if (gen->type == GEN_EDIPARTY) {
     // TODO(tniessen): this is what OpenSSL does, implement properly instead
-    BIO_printf(out.get(), "EdiPartyName:<unsupported>");
+    Thin_BIO_printf(out.get(), "EdiPartyName:<unsupported>");
   } else {
-    // This is safe because X509V3_EXT_d2i would have returned nullptr in this
+    // This is safe because Thin_X509V3_EXT_d2i would have returned nullptr in this
     // case already.
     UNREACHABLE();
   }
@@ -822,56 +815,56 @@ static bool PrintGeneralName(const BIOPointer& out, const GENERAL_NAME* gen) {
 }
 
 bool SafeX509SubjectAltNamePrint(const BIOPointer& out, X509_EXTENSION* ext) {
-  CHECK_EQ(OBJ_obj2nid(X509_EXTENSION_get_object(ext)), NID_subject_alt_name);
+  CHECK_EQ(Thin_OBJ_obj2nid(X509_EXTENSION_get_object(ext)), NID_subject_alt_name);
 
-  GENERAL_NAMES* names = static_cast<GENERAL_NAMES*>(X509V3_EXT_d2i(ext));
+  GENERAL_NAMES* names = static_cast<GENERAL_NAMES*>(Thin_X509V3_EXT_d2i(ext));
   if (names == nullptr)
     return false;
 
   bool ok = true;
 
-  for (int i = 0; i < sk_GENERAL_NAME_num(names); i++) {
-    GENERAL_NAME* gen = sk_GENERAL_NAME_value(names, i);
+  for (int i = 0; i < Thin_sk_GENERAL_NAME_num(names); i++) {
+    GENERAL_NAME* gen = Thin_sk_GENERAL_NAME_value(names, i);
 
     if (i != 0)
-      BIO_write(out.get(), ", ", 2);
+      Thin_BIO_write(out.get(), ", ", 2);
 
     if (!(ok = PrintGeneralName(out, gen))) {
       break;
     }
   }
-  sk_GENERAL_NAME_pop_free(names, GENERAL_NAME_free);
+  Thin_sk_GENERAL_NAME_pop_free(names, Thin_GENERAL_NAME_free);
 
   return ok;
 }
 
 bool SafeX509InfoAccessPrint(const BIOPointer& out, X509_EXTENSION* ext) {
-  CHECK_EQ(OBJ_obj2nid(X509_EXTENSION_get_object(ext)), NID_info_access);
+  CHECK_EQ(Thin_OBJ_obj2nid(X509_EXTENSION_get_object(ext)), NID_info_access);
 
   AUTHORITY_INFO_ACCESS* descs =
-      static_cast<AUTHORITY_INFO_ACCESS*>(X509V3_EXT_d2i(ext));
+      static_cast<AUTHORITY_INFO_ACCESS*>(Thin_X509V3_EXT_d2i(ext));
   if (descs == nullptr)
     return false;
 
   bool ok = true;
 
-  for (int i = 0; i < sk_ACCESS_DESCRIPTION_num(descs); i++) {
-    ACCESS_DESCRIPTION* desc = sk_ACCESS_DESCRIPTION_value(descs, i);
+  for (int i = 0; i < Thin_sk_ACCESS_DESCRIPTION_num(descs); i++) {
+    ACCESS_DESCRIPTION* desc = Thin_sk_ACCESS_DESCRIPTION_value(descs, i);
 
     if (i != 0)
-      BIO_write(out.get(), "\n", 1);
+      Thin_BIO_write(out.get(), "\n", 1);
 
     char objtmp[80];
-    i2t_ASN1_OBJECT(objtmp, sizeof(objtmp), desc->method);
-    BIO_printf(out.get(), "%s - ", objtmp);
+    Thin_i2t_ASN1_OBJECT(objtmp, sizeof(objtmp), desc->method);
+    Thin_BIO_printf(out.get(), "%s - ", objtmp);
     if (!(ok = PrintGeneralName(out, desc->location))) {
       break;
     }
   }
-  sk_ACCESS_DESCRIPTION_pop_free(descs, ACCESS_DESCRIPTION_free);
+  Thin_sk_ACCESS_DESCRIPTION_pop_free(descs, Thin_ACCESS_DESCRIPTION_free);
 
 #if OPENSSL_VERSION_MAJOR < 3
-  BIO_write(out.get(), "\n", 1);
+  Thin_BIO_write(out.get(), "\n", 1);
 #endif
 
   return ok;
@@ -880,15 +873,15 @@ bool SafeX509InfoAccessPrint(const BIOPointer& out, X509_EXTENSION* ext) {
 v8::MaybeLocal<v8::Value> GetSubjectAltNameString(Environment* env,
                                                   X509* cert,
                                                   const BIOPointer& bio) {
-  int index = X509_get_ext_by_NID(cert, NID_subject_alt_name, -1);
+  int index = Thin_X509_get_ext_by_NID(cert, NID_subject_alt_name, -1);
   if (index < 0)
     return Undefined(env->isolate());
 
-  X509_EXTENSION* ext = X509_get_ext(cert, index);
+  X509_EXTENSION* ext = Thin_X509_get_ext(cert, index);
   CHECK_NOT_NULL(ext);
 
   if (!SafeX509SubjectAltNamePrint(bio, ext)) {
-    CHECK_EQ(BIO_reset(bio.get()), 1);
+    CHECK_EQ(Thin_BIO_reset(bio.get()), 1);
     return v8::Null(env->isolate());
   }
 
@@ -898,15 +891,15 @@ v8::MaybeLocal<v8::Value> GetSubjectAltNameString(Environment* env,
 v8::MaybeLocal<v8::Value> GetInfoAccessString(Environment* env,
                                               X509* cert,
                                               const BIOPointer& bio) {
-  int index = X509_get_ext_by_NID(cert, NID_info_access, -1);
+  int index = Thin_X509_get_ext_by_NID(cert, NID_info_access, -1);
   if (index < 0)
     return Undefined(env->isolate());
 
-  X509_EXTENSION* ext = X509_get_ext(cert, index);
+  X509_EXTENSION* ext = Thin_X509_get_ext(cert, index);
   CHECK_NOT_NULL(ext);
 
   if (!SafeX509InfoAccessPrint(bio, ext)) {
-    CHECK_EQ(BIO_reset(bio.get()), 1);
+    CHECK_EQ(Thin_BIO_reset(bio.get()), 1);
     return v8::Null(env->isolate());
   }
 
@@ -916,13 +909,13 @@ v8::MaybeLocal<v8::Value> GetInfoAccessString(Environment* env,
 MaybeLocal<Value> GetIssuerString(Environment* env,
                                   X509* cert,
                                   const BIOPointer& bio) {
-  X509_NAME* issuer_name = X509_get_issuer_name(cert);
-  if (X509_NAME_print_ex(
+  X509_NAME* issuer_name = Thin_X509_get_issuer_name(cert);
+  if (Thin_X509_NAME_print_ex(
           bio.get(),
           issuer_name,
           0,
           kX509NameFlagsMultiline) <= 0) {
-    CHECK_EQ(BIO_reset(bio.get()), 1);
+    CHECK_EQ(Thin_BIO_reset(bio.get()), 1);
     return Undefined(env->isolate());
   }
 
@@ -932,12 +925,12 @@ MaybeLocal<Value> GetIssuerString(Environment* env,
 MaybeLocal<Value> GetSubject(Environment* env,
                              X509* cert,
                              const BIOPointer& bio) {
-  if (X509_NAME_print_ex(
+  if (Thin_X509_NAME_print_ex(
           bio.get(),
-          X509_get_subject_name(cert),
+          Thin_X509_get_subject_name(cert),
           0,
           kX509NameFlagsMultiline) <= 0) {
-    CHECK_EQ(BIO_reset(bio.get()), 1);
+    CHECK_EQ(Thin_BIO_reset(bio.get()), 1);
     return Undefined(env->isolate());
   }
 
@@ -959,7 +952,7 @@ static MaybeLocal<Value> GetX509NameObject(Environment* env, X509* cert) {
   }
 
   for (int i = 0; i < cnt; i++) {
-    X509_NAME_ENTRY* entry = X509_NAME_get_entry(name, i);
+    X509_NAME_ENTRY* entry = Thin_X509_NAME_get_entry(name, i);
     CHECK_NOT_NULL(entry);
 
     // We intentionally ignore the value of X509_NAME_ENTRY_set because the
@@ -967,18 +960,18 @@ static MaybeLocal<Value> GetX509NameObject(Environment* env, X509* cert) {
     // anyway, and multi-value RDNs are rare, i.e., the vast majority of
     // Relative Distinguished Names contains a single type-value pair only.
     const ASN1_OBJECT* type = X509_NAME_ENTRY_get_object(entry);
-    const ASN1_STRING* value = X509_NAME_ENTRY_get_data(entry);
+    const ASN1_STRING* value = Thin_X509_NAME_ENTRY_get_data(entry);
 
     // If OpenSSL knows the type, use the short name of the type as the key, and
     // the numeric representation of the type's OID otherwise.
-    int type_nid = OBJ_obj2nid(type);
+    int type_nid = Thin_OBJ_obj2nid(type);
     char type_buf[80];
     const char* type_str;
     if (type_nid != NID_undef) {
-      type_str = OBJ_nid2sn(type_nid);
+      type_str = Thin_OBJ_nid2sn(type_nid);
       CHECK_NOT_NULL(type_str);
     } else {
-      OBJ_obj2txt(type_buf, sizeof(type_buf), type, true);
+      Thin_OBJ_obj2txt(type_buf, sizeof(type_buf), type, true);
       type_str = type_buf;
     }
 
@@ -987,17 +980,17 @@ static MaybeLocal<Value> GetX509NameObject(Environment* env, X509* cert) {
       return MaybeLocal<Value>();
     }
 
-    // The previous implementation used X509_NAME_print_ex, which escapes some
+    // The previous implementation used Thin_X509_NAME_print_ex, which escapes some
     // characters in the value. The old implementation did not decode/unescape
     // values correctly though, leading to ambiguous and incorrect
     // representations. The new implementation only converts to Unicode and does
     // not escape anything.
     unsigned char* value_str;
-    int value_str_size = ASN1_STRING_to_UTF8(&value_str, value);
+    int value_str_size = Thin_ASN1_STRING_to_UTF8(&value_str, value);
     if (value_str_size < 0) {
       return Undefined(env->isolate());
     }
-    auto free_value_str = OnScopeLeave([&]() { OPENSSL_free(value_str); });
+    auto free_value_str = OnScopeLeave([&]() { Thin_OPENSSL_free(value_str); });
 
     Local<String> v8_value;
     if (!String::NewFromUtf8(env->isolate(),
@@ -1042,21 +1035,21 @@ static MaybeLocal<Value> GetX509NameObject(Environment* env, X509* cert) {
 template <MaybeLocal<Value> (*Get)(Environment* env, const SSL_CIPHER* cipher)>
 MaybeLocal<Value> GetCurrentCipherValue(Environment* env,
                                         const SSLPointer& ssl) {
-  return Get(env, SSL_get_current_cipher(ssl.get()));
+  return Get(env, Thin_SSL_get_current_cipher(ssl.get()));
 }
 
 MaybeLocal<Array> GetClientHelloCiphers(
     Environment* env,
     const SSLPointer& ssl) {
   EscapableHandleScope scope(env->isolate());
-  // const unsigned char* buf = nullptr;
-  size_t len = 0; // SSL_client_hello_get0_ciphers(ssl.get(), &buf);
+  const unsigned char* buf = nullptr;
+  size_t len = Thin_SSL_client_hello_get0_ciphers(ssl.get(), &buf);
   size_t count = len / 2;
   MaybeStackBuffer<Local<Value>, 16> ciphers(count);
   int j = 0;
   for (size_t n = 0; n < len; n += 2) {
-    const SSL_CIPHER* cipher = nullptr; // SSL_CIPHER_find(ssl.get(), buf);
-    // buf += 2;
+    const SSL_CIPHER* cipher = Thin_SSL_CIPHER_find(ssl.get(), buf);
+    buf += 2;
     Local<Object> obj = Object::New(env->isolate());
     if (!Set(env->context(),
              obj,
@@ -1080,7 +1073,7 @@ MaybeLocal<Array> GetClientHelloCiphers(
 
 
 MaybeLocal<Object> GetCipherInfo(Environment* env, const SSLPointer& ssl) {
-  if (SSL_get_current_cipher(ssl.get()) == nullptr)
+  if (Thin_SSL_get_current_cipher(ssl.get()) == nullptr)
     return MaybeLocal<Object>();
   EscapableHandleScope scope(env->isolate());
   Local<Object> info = Object::New(env->isolate());
@@ -1104,19 +1097,19 @@ MaybeLocal<Object> GetCipherInfo(Environment* env, const SSLPointer& ssl) {
 }
 
 MaybeLocal<Object> GetEphemeralKey(Environment* env, const SSLPointer& ssl) {
-  CHECK_EQ(SSL_is_server(ssl.get()), 0);
+  CHECK_EQ(Thin_SSL_is_server(ssl.get()), 0);
   EVP_PKEY* raw_key;
 
   EscapableHandleScope scope(env->isolate());
   Local<Object> info = Object::New(env->isolate());
-  if (!SSL_get_server_tmp_key(ssl.get(), &raw_key))
+  if (!Thin_SSL_get_server_tmp_key(ssl.get(), &raw_key))
     return scope.Escape(info);
 
   Local<Context> context = env->context();
   crypto::EVPKeyPointer key(raw_key);
 
-  int kid = EVP_PKEY_id(key.get());
-  int bits = EVP_PKEY_bits(key.get());
+  int kid = Thin_EVP_PKEY_id(key.get());
+  int bits = Thin_EVP_PKEY_bits(key.get());
   switch (kid) {
     case EVP_PKEY_DH:
       if (!Set<String>(context, info, env->type_string(), env->dh_string()) ||
@@ -1133,11 +1126,11 @@ MaybeLocal<Object> GetEphemeralKey(Environment* env, const SSLPointer& ssl) {
       {
         const char* curve_name;
         if (kid == EVP_PKEY_EC) {
-          ECKeyPointer ec(EVP_PKEY_get1_EC_KEY(key.get()));
-          int nid = EC_GROUP_get_curve_name(EC_KEY_get0_group(ec.get()));
-          curve_name = OBJ_nid2sn(nid);
+          ECKeyPointer ec(Thin_EVP_PKEY_get1_EC_KEY(key.get()));
+          int nid = Thin_EC_GROUP_get_curve_name(Thin_EC_KEY_get0_group(ec.get()));
+          curve_name = Thin_OBJ_nid2sn(nid);
         } else {
-          curve_name = OBJ_nid2sn(kid);
+          curve_name = Thin_OBJ_nid2sn(kid);
         }
         if (!Set<String>(context,
                          info,
@@ -1165,7 +1158,7 @@ MaybeLocal<Object> ECPointToBuffer(Environment* env,
                                    const EC_POINT* point,
                                    point_conversion_form_t form,
                                    const char** error) {
-  size_t len = EC_POINT_point2oct(group, point, form, nullptr, 0, nullptr);
+  size_t len = Thin_EC_POINT_point2oct(group, point, form, nullptr, 0, nullptr);
   if (len == 0) {
     if (error != nullptr) *error = "Failed to get public key length";
     return MaybeLocal<Object>();
@@ -1177,7 +1170,7 @@ MaybeLocal<Object> ECPointToBuffer(Environment* env,
     bs = ArrayBuffer::NewBackingStore(env->isolate(), len);
   }
 
-  len = EC_POINT_point2oct(group,
+  len = Thin_EC_POINT_point2oct(group,
                            point,
                            form,
                            reinterpret_cast<unsigned char*>(bs->Data()),
@@ -1203,15 +1196,15 @@ MaybeLocal<Value> GetPeerCert(
 
   // NOTE: This is because of the odd OpenSSL behavior. On client `cert_chain`
   // contains the `peer_certificate`, but on server it doesn't.
-  X509Pointer cert(is_server ? SSL_get_peer_certificate(ssl.get()) : nullptr);
-  STACK_OF(X509)* ssl_certs = SSL_get_peer_cert_chain(ssl.get());
-  if (!cert && (ssl_certs == nullptr || sk_X509_num(ssl_certs) == 0))
+  X509Pointer cert(is_server ? Thin_SSL_get_peer_certificate(ssl.get()) : nullptr);
+  STACK_OF(X509)* ssl_certs = Thin_SSL_get_peer_cert_chain(ssl.get());
+  if (!cert && (ssl_certs == nullptr || Thin_sk_X509_num(ssl_certs) == 0))
     return Undefined(env->isolate());
 
   // Short result requested.
   if (abbreviated) {
     maybe_cert =
-        X509ToObject(env, cert ? cert.get() : sk_X509_value(ssl_certs, 0));
+        X509ToObject(env, cert ? cert.get() : Thin_sk_X509_value(ssl_certs, 0));
     return maybe_cert.ToLocal(&result) ? result : MaybeLocal<Value>();
   }
 
@@ -1220,7 +1213,7 @@ MaybeLocal<Value> GetPeerCert(
     return Undefined(env->isolate());
 
   // First and main certificate.
-  X509Pointer first_cert(sk_X509_value(peer_certs.get(), 0));
+  X509Pointer first_cert(Thin_sk_X509_value(peer_certs.get(), 0));
   CHECK(first_cert);
   maybe_cert = X509ToObject(env, first_cert.release());
   if (!maybe_cert.ToLocal(&result))
@@ -1250,7 +1243,7 @@ MaybeLocal<Value> GetPeerCert(
     return MaybeLocal<Value>();
 
   // Last certificate should be self-signed.
-  if (X509_check_issued(cert.get(), cert.get()) == X509_V_OK &&
+  if (Thin_X509_check_issued(cert.get(), cert.get()) == X509_V_OK &&
       !Set<Object>(env->context(),
            issuer_chain,
            env->issuercert_string(),
@@ -1268,19 +1261,19 @@ MaybeLocal<Object> X509ToObject(
   Local<Context> context = env->context();
   Local<Object> info = Object::New(env->isolate());
 
-  BIOPointer bio(BIO_new(BIO_s_mem()));
+  BIOPointer bio(Thin_BIO_new(Thin_BIO_s_mem()));
   CHECK(bio);
 
-  // X509_check_ca() returns a range of values. Only 1 means "is a CA"
-  auto is_ca = Boolean::New(env->isolate(), 1 == X509_check_ca(cert));
+  // Thin_X509_check_ca() returns a range of values. Only 1 means "is a CA"
+  auto is_ca = Boolean::New(env->isolate(), 1 == Thin_X509_check_ca(cert));
   if (!Set<Value>(context,
                   info,
                   env->subject_string(),
-                  GetX509NameObject<X509_get_subject_name>(env, cert)) ||
+                  GetX509NameObject<Thin_X509_get_subject_name>(env, cert)) ||
       !Set<Value>(context,
                   info,
                   env->issuer_string(),
-                  GetX509NameObject<X509_get_issuer_name>(env, cert)) ||
+                  GetX509NameObject<Thin_X509_get_issuer_name>(env, cert)) ||
       !Set<Value>(context,
                   info,
                   env->subjectaltname_string(),
@@ -1293,16 +1286,16 @@ MaybeLocal<Object> X509ToObject(
     return MaybeLocal<Object>();
   }
 
-  EVPKeyPointer pkey(X509_get_pubkey(cert));
+  EVPKeyPointer pkey(Thin_X509_get_pubkey(cert));
   RSAPointer rsa;
   ECPointer ec;
   if (pkey) {
-    switch (EVP_PKEY_id(pkey.get())) {
+    switch (Thin_EVP_PKEY_id(pkey.get())) {
       case EVP_PKEY_RSA:
-        rsa.reset(EVP_PKEY_get1_RSA(pkey.get()));
+        rsa.reset(Thin_EVP_PKEY_get1_RSA(pkey.get()));
         break;
       case EVP_PKEY_EC:
-        ec.reset(EVP_PKEY_get1_EC_KEY(pkey.get()));
+        ec.reset(Thin_EVP_PKEY_get1_EC_KEY(pkey.get()));
         break;
     }
   }
@@ -1310,7 +1303,7 @@ MaybeLocal<Object> X509ToObject(
   if (rsa) {
     const BIGNUM* n;
     const BIGNUM* e;
-    RSA_get0_key(rsa.get(), &n, &e, nullptr);
+    Thin_RSA_get0_key(rsa.get(), &n, &e, nullptr);
     if (!Set<Value>(context,
                     info,
                     env->modulus_string(),
@@ -1327,7 +1320,7 @@ MaybeLocal<Object> X509ToObject(
       return MaybeLocal<Object>();
     }
   } else if (ec) {
-    const EC_GROUP* group = EC_KEY_get0_group(ec.get());
+    const EC_GROUP* group = Thin_EC_KEY_get0_group(ec.get());
 
     if (!Set<Value>(context,
                     info,
@@ -1340,18 +1333,18 @@ MaybeLocal<Object> X509ToObject(
       return MaybeLocal<Object>();
     }
 
-    const int nid = EC_GROUP_get_curve_name(group);
+    const int nid = Thin_EC_GROUP_get_curve_name(group);
     if (nid != 0) {
       // Curve is well-known, get its OID and NIST nick-name (if it has one).
 
       if (!Set<Value>(context,
                       info,
                       env->asn1curve_string(),
-                      GetCurveName<OBJ_nid2sn>(env, nid)) ||
+                      GetCurveName<Thin_OBJ_nid2sn>(env, nid)) ||
           !Set<Value>(context,
                       info,
                       env->nistcurve_string(),
-                      GetCurveName<EC_curve_nid2nist>(env, nid))) {
+                      GetCurveName<Thin_EC_curve_nid2nist>(env, nid))) {
         return MaybeLocal<Object>();
       }
     } else {
@@ -1382,15 +1375,15 @@ MaybeLocal<Object> X509ToObject(
   if (!Set<Value>(context,
                   info,
                   env->fingerprint_string(),
-                  GetFingerprintDigest(env, EVP_sha1(), cert)) ||
+                  GetFingerprintDigest(env, Thin_EVP_sha1(), cert)) ||
       !Set<Value>(context,
                   info,
                   env->fingerprint256_string(),
-                  GetFingerprintDigest(env, EVP_sha256(), cert)) ||
+                  GetFingerprintDigest(env, Thin_EVP_sha256(), cert)) ||
       !Set<Value>(context,
                   info,
                   env->fingerprint512_string(),
-                  GetFingerprintDigest(env, EVP_sha512(), cert)) ||
+                  GetFingerprintDigest(env, Thin_EVP_sha512(), cert)) ||
       !Set<Value>(
           context, info, env->ext_key_usage_string(), GetKeyUsage(env, cert)) ||
       !Set<Value>(context,
diff --git a/src/crypto/crypto_common.h b/src/crypto/crypto_common.h
index 9eb3ff4460..f5b914aa93 100644
--- a/src/crypto/crypto_common.h
+++ b/src/crypto/crypto_common.h
@@ -5,8 +5,8 @@
 
 #include "node_crypto.h"
 #include "v8.h"
-#include <openssl/ssl.h>
-#include <openssl/x509v3.h>
+// #include <openssl/ssl.h>
+// #include <openssl/x509v3.h>
 
 #include <string>
 
@@ -14,13 +14,13 @@ namespace node {
 namespace crypto {
 
 struct StackOfX509Deleter {
-  void operator()(STACK_OF(X509)* p) const { sk_X509_pop_free(p, X509_free); }
+  void operator()(STACK_OF(X509)* p) const { Thin_sk_X509_pop_free(p, Thin_X509_free); }
 };
 using StackOfX509 = std::unique_ptr<STACK_OF(X509), StackOfX509Deleter>;
 
 struct StackOfXASN1Deleter {
   void operator()(STACK_OF(ASN1_OBJECT)* p) const {
-    sk_ASN1_OBJECT_pop_free(p, ASN1_OBJECT_free);
+    Thin_sk_ASN1_OBJECT_pop_free(p, Thin_ASN1_OBJECT_free);
   }
 };
 using StackOfASN1 = std::unique_ptr<STACK_OF(ASN1_OBJECT), StackOfXASN1Deleter>;
diff --git a/src/crypto/crypto_context.cc b/src/crypto/crypto_context.cc
index 0435ca1ade..96e470387c 100644
--- a/src/crypto/crypto_context.cc
+++ b/src/crypto/crypto_context.cc
@@ -11,12 +11,12 @@
 #include "util.h"
 #include "v8.h"
 
-#include <openssl/x509.h>
-#include <openssl/pkcs12.h>
-#include <openssl/rand.h>
-#ifndef OPENSSL_NO_ENGINE
-#include <openssl/engine.h>
-#endif  // !OPENSSL_NO_ENGINE
+// #include <openssl/x509.h>
+// #include <openssl/pkcs12.h>
+// #include <openssl/rand.h>
+// #ifndef OPENSSL_NO_ENGINE
+// #include <openssl/engine.h>
+// #endif  // !OPENSSL_NO_ENGINE
 
 namespace node {
 
@@ -60,14 +60,14 @@ inline X509_STORE* GetOrCreateRootCertStore() {
 }
 
 // Takes a string or buffer and loads it into a BIO.
-// Caller responsible for BIO_free_all-ing the returned object.
+// Caller responsible for Thin_BIO_free_all-ing the returned object.
 BIOPointer LoadBIO(Environment* env, Local<Value> v) {
   if (v->IsString() || v->IsArrayBufferView()) {
-    BIOPointer bio(BIO_new(BIO_s_mem()));
+    BIOPointer bio(Thin_BIO_new(Thin_BIO_s_secmem()));
     if (!bio) return nullptr;
     ByteSource bsrc = ByteSource::FromStringOrBuffer(env, v);
     if (bsrc.size() > INT_MAX) return nullptr;
-    int written = BIO_write(bio.get(), bsrc.data<char>(), bsrc.size());
+    int written = Thin_BIO_write(bio.get(), bsrc.data<char>(), bsrc.size());
     if (written < 0) return nullptr;
     if (static_cast<size_t>(written) != bsrc.size()) return nullptr;
     return bio;
@@ -76,7 +76,7 @@ BIOPointer LoadBIO(Environment* env, Local<Value> v) {
 }
 
 namespace {
-int SSL_CTX_use_certificate_chain(SSL_CTX* ctx,
+int Thin_SSL_CTX_use_certificate_chain(SSL_CTX* ctx,
                                   X509Pointer&& x,
                                   STACK_OF(X509)* extra_certs,
                                   X509Pointer* cert,
@@ -85,18 +85,18 @@ int SSL_CTX_use_certificate_chain(SSL_CTX* ctx,
   CHECK(!*cert);
   X509* issuer = nullptr;
 
-  int ret = SSL_CTX_use_certificate(ctx, x.get());
+  int ret = Thin_SSL_CTX_use_certificate(ctx, x.get());
 
   if (ret) {
     // If we could set up our certificate, now proceed to
     // the CA certificates.
-    SSL_CTX_clear_extra_chain_certs(ctx);
+    Thin_SSL_CTX_clear_extra_chain_certs(ctx);
 
-    for (int i = 0; i < sk_X509_num(extra_certs); i++) {
-      X509* ca = sk_X509_value(extra_certs, i);
+    for (int i = 0; i < Thin_sk_X509_num(extra_certs); i++) {
+      X509* ca = Thin_sk_X509_value(extra_certs, i);
 
       // NOTE: Increments reference count on `ca`
-      if (!SSL_CTX_add1_chain_cert(ctx, ca)) {
+      if (!Thin_SSL_CTX_add1_chain_cert(ctx, ca)) {
         ret = 0;
         issuer = nullptr;
         break;
@@ -104,10 +104,10 @@ int SSL_CTX_use_certificate_chain(SSL_CTX* ctx,
       // Note that we must not free r if it was successfully
       // added to the chain (while we must free the main
       // certificate, since its reference count is increased
-      // by SSL_CTX_use_certificate).
+      // by Thin_SSL_CTX_use_certificate).
 
       // Find issuer
-      if (issuer != nullptr || X509_check_issued(ca, x.get()) != X509_V_OK)
+      if (issuer != nullptr || Thin_X509_check_issued(ca, x.get()) != X509_V_OK)
         continue;
 
       issuer = ca;
@@ -125,7 +125,7 @@ int SSL_CTX_use_certificate_chain(SSL_CTX* ctx,
       // no need to free `store`
     } else {
       // Increment issuer reference count
-      issuer_->reset(X509_dup(issuer));
+      issuer_->reset(Thin_X509_dup(issuer));
       if (!*issuer_) {
         ret = 0;
       }
@@ -133,7 +133,7 @@ int SSL_CTX_use_certificate_chain(SSL_CTX* ctx,
   }
 
   if (ret && x != nullptr) {
-    cert->reset(X509_dup(x.get()));
+    cert->reset(Thin_X509_dup(x.get()));
     if (!*cert)
       ret = 0;
   }
@@ -145,31 +145,31 @@ int SSL_CTX_use_certificate_chain(SSL_CTX* ctx,
 // sent to the peer in the Certificate message.
 //
 // Taken from OpenSSL - edited for style.
-int SSL_CTX_use_certificate_chain(SSL_CTX* ctx,
+int Thin_SSL_CTX_use_certificate_chain(SSL_CTX* ctx,
                                   BIOPointer&& in,
                                   X509Pointer* cert,
                                   X509Pointer* issuer) {
-  // Just to ensure that `ERR_peek_last_error` below will return only errors
+  // Just to ensure that `Thin_ERR_peek_last_error` below will return only errors
   // that we are interested in
-  ERR_clear_error();
+  Thin_ERR_clear_error();
 
   X509Pointer x(
-      PEM_read_bio_X509_AUX(in.get(), nullptr, NoPasswordCallback, nullptr));
+      Thin_PEM_read_bio_X509_AUX(in.get(), nullptr, NoPasswordCallback, nullptr));
 
   if (!x)
     return 0;
 
   unsigned long err = 0;  // NOLINT(runtime/int)
 
-  StackOfX509 extra_certs(sk_X509_new_null());
+  StackOfX509 extra_certs(Thin_sk_X509_new_null());
   if (!extra_certs)
     return 0;
 
-  while (X509Pointer extra {PEM_read_bio_X509(in.get(),
+  while (X509Pointer extra {Thin_PEM_read_bio_X509(in.get(),
                                     nullptr,
                                     NoPasswordCallback,
                                     nullptr)}) {
-    if (sk_X509_push(extra_certs.get(), extra.get())) {
+    if (Thin_sk_X509_push(extra_certs.get(), extra.get())) {
       extra.release();
       continue;
     }
@@ -178,16 +178,16 @@ int SSL_CTX_use_certificate_chain(SSL_CTX* ctx,
   }
 
   // When the while loop ends, it's usually just EOF.
-  err = ERR_peek_last_error();
+  err = Thin_ERR_peek_last_error();
   if (ERR_GET_LIB(err) == ERR_LIB_PEM &&
       ERR_GET_REASON(err) == PEM_R_NO_START_LINE) {
-    ERR_clear_error();
+    Thin_ERR_clear_error();
   } else {
     // some real error
     return 0;
   }
 
-  return SSL_CTX_use_certificate_chain(ctx,
+  return Thin_SSL_CTX_use_certificate_chain(ctx,
                                        std::move(x),
                                        extra_certs.get(),
                                        cert,
@@ -205,7 +205,7 @@ X509_STORE* NewRootCertStore() {
       per_process::cli_options->ssl_openssl_cert_store == false) {
     for (size_t i = 0; i < arraysize(root_certs); i++) {
       X509* x509 =
-          PEM_read_bio_X509(NodeBIO::NewFixed(root_certs[i],
+          Thin_PEM_read_bio_X509(NodeBIO::NewFixed(root_certs[i],
                                               strlen(root_certs[i])).get(),
                             nullptr,   // no re-use of X509 structure
                             NoPasswordCallback,
@@ -218,20 +218,20 @@ X509_STORE* NewRootCertStore() {
     }
   }
 
-  X509_STORE* store = X509_STORE_new();
+  X509_STORE* store = Thin_X509_STORE_new();
   if (*system_cert_path != '\0') {
-    ERR_set_mark();
-    X509_STORE_load_locations(store, system_cert_path, nullptr);
-    ERR_pop_to_mark();
+    Thin_ERR_set_mark();
+    Thin_X509_STORE_load_locations(store, system_cert_path, nullptr);
+    Thin_ERR_pop_to_mark();
   }
 
   Mutex::ScopedLock cli_lock(node::per_process::cli_options_mutex);
   if (per_process::cli_options->ssl_openssl_cert_store) {
-    X509_STORE_set_default_paths(store);
+    Thin_X509_STORE_set_default_paths(store);
   } else {
     for (X509* cert : root_certs_vector) {
-      X509_up_ref(cert);
-      X509_STORE_add_cert(store, cert);
+      Thin_X509_up_ref(cert);
+      Thin_X509_STORE_add_cert(store, cert);
     }
   }
 
@@ -432,7 +432,7 @@ void SecureContext::Init(const FunctionCallbackInfo<Value>& args) {
 
   int min_version = args[1].As<Int32>()->Value();
   int max_version = args[2].As<Int32>()->Value();
-  const SSL_METHOD* method = TLS_method();
+  const SSL_METHOD* method = Thin_TLS_method();
 
   if (max_version == 0)
     max_version = kMaxSupportedVersion;
@@ -458,54 +458,54 @@ void SecureContext::Init(const FunctionCallbackInfo<Value>& args) {
       max_version = TLS1_2_VERSION;
     } else if (sslmethod == "SSLv23_server_method") {
       max_version = TLS1_2_VERSION;
-      method = TLS_server_method();
+      method = Thin_TLS_server_method();
     } else if (sslmethod == "SSLv23_client_method") {
       max_version = TLS1_2_VERSION;
-      method = TLS_client_method();
-    } else if (sslmethod == "TLS_method") {
+      method = Thin_TLS_client_method();
+    } else if (sslmethod == "Thin_TLS_method") {
       min_version = 0;
       max_version = kMaxSupportedVersion;
-    } else if (sslmethod == "TLS_server_method") {
+    } else if (sslmethod == "Thin_TLS_server_method") {
       min_version = 0;
       max_version = kMaxSupportedVersion;
-      method = TLS_server_method();
-    } else if (sslmethod == "TLS_client_method") {
+      method = Thin_TLS_server_method();
+    } else if (sslmethod == "Thin_TLS_client_method") {
       min_version = 0;
       max_version = kMaxSupportedVersion;
-      method = TLS_client_method();
+      method = Thin_TLS_client_method();
     } else if (sslmethod == "TLSv1_method") {
       min_version = TLS1_VERSION;
       max_version = TLS1_VERSION;
     } else if (sslmethod == "TLSv1_server_method") {
       min_version = TLS1_VERSION;
       max_version = TLS1_VERSION;
-      method = TLS_server_method();
+      method = Thin_TLS_server_method();
     } else if (sslmethod == "TLSv1_client_method") {
       min_version = TLS1_VERSION;
       max_version = TLS1_VERSION;
-      method = TLS_client_method();
+      method = Thin_TLS_client_method();
     } else if (sslmethod == "TLSv1_1_method") {
       min_version = TLS1_1_VERSION;
       max_version = TLS1_1_VERSION;
     } else if (sslmethod == "TLSv1_1_server_method") {
       min_version = TLS1_1_VERSION;
       max_version = TLS1_1_VERSION;
-      method = TLS_server_method();
+      method = Thin_TLS_server_method();
     } else if (sslmethod == "TLSv1_1_client_method") {
       min_version = TLS1_1_VERSION;
       max_version = TLS1_1_VERSION;
-      method = TLS_client_method();
+      method = Thin_TLS_client_method();
     } else if (sslmethod == "TLSv1_2_method") {
       min_version = TLS1_2_VERSION;
       max_version = TLS1_2_VERSION;
     } else if (sslmethod == "TLSv1_2_server_method") {
       min_version = TLS1_2_VERSION;
       max_version = TLS1_2_VERSION;
-      method = TLS_server_method();
+      method = Thin_TLS_server_method();
     } else if (sslmethod == "TLSv1_2_client_method") {
       min_version = TLS1_2_VERSION;
       max_version = TLS1_2_VERSION;
-      method = TLS_client_method();
+      method = Thin_TLS_client_method();
     } else {
       THROW_ERR_TLS_INVALID_PROTOCOL_METHOD(
           env, "Unknown method: %s", *sslmethod);
@@ -513,36 +513,36 @@ void SecureContext::Init(const FunctionCallbackInfo<Value>& args) {
     }
   }
 
-  sc->ctx_.reset(SSL_CTX_new(method));
+  sc->ctx_.reset(Thin_SSL_CTX_new(method));
   if (!sc->ctx_) {
-    return ThrowCryptoError(env, ERR_get_error(), "SSL_CTX_new");
+    return ThrowCryptoError(env, Thin_ERR_get_error(), "Thin_SSL_CTX_new");
   }
-  SSL_CTX_set_app_data(sc->ctx_.get(), sc);
+  Thin_SSL_CTX_set_app_data(sc->ctx_.get(), sc);
 
-  // Disable SSLv2 in the case when method == TLS_method() and the
+  // Disable SSLv2 in the case when method == Thin_TLS_method() and the
   // cipher list contains SSLv2 ciphers (not the default, should be rare.)
   // The bundled OpenSSL doesn't have SSLv2 support but the system OpenSSL may.
   // SSLv3 is disabled because it's susceptible to downgrade attacks (POODLE.)
-  SSL_CTX_set_options(sc->ctx_.get(), SSL_OP_NO_SSLv2);
-  SSL_CTX_set_options(sc->ctx_.get(), SSL_OP_NO_SSLv3);
+  Thin_SSL_CTX_set_options(sc->ctx_.get(), SSL_OP_NO_SSLv2);
+  Thin_SSL_CTX_set_options(sc->ctx_.get(), SSL_OP_NO_SSLv3);
 #if OPENSSL_VERSION_MAJOR >= 3
-  SSL_CTX_set_options(sc->ctx_.get(), SSL_OP_ALLOW_CLIENT_RENEGOTIATION);
+  Thin_SSL_CTX_set_options(sc->ctx_.get(), SSL_OP_ALLOW_CLIENT_RENEGOTIATION);
 #endif
 
   // Enable automatic cert chaining. This is enabled by default in OpenSSL, but
   // disabled by default in BoringSSL. Enable it explicitly to make the
   // behavior match when Node is built with BoringSSL.
-  SSL_CTX_clear_mode(sc->ctx_.get(), SSL_MODE_NO_AUTO_CHAIN);
+  Thin_SSL_CTX_clear_mode(sc->ctx_.get(), SSL_MODE_NO_AUTO_CHAIN);
 
   // SSL session cache configuration
-  SSL_CTX_set_session_cache_mode(sc->ctx_.get(),
+  Thin_SSL_CTX_set_session_cache_mode(sc->ctx_.get(),
                                  SSL_SESS_CACHE_CLIENT |
                                  SSL_SESS_CACHE_SERVER |
                                  SSL_SESS_CACHE_NO_INTERNAL |
                                  SSL_SESS_CACHE_NO_AUTO_CLEAR);
 
-  SSL_CTX_set_min_proto_version(sc->ctx_.get(), min_version);
-  SSL_CTX_set_max_proto_version(sc->ctx_.get(), max_version);
+  Thin_SSL_CTX_set_min_proto_version(sc->ctx_.get(), min_version);
+  Thin_SSL_CTX_set_max_proto_version(sc->ctx_.get(), max_version);
 
   // OpenSSL 1.1.0 changed the ticket key size, but the OpenSSL 1.0.x size was
   // exposed in the public API. To retain compatibility, install a callback
@@ -553,31 +553,31 @@ void SecureContext::Init(const FunctionCallbackInfo<Value>& args) {
     return THROW_ERR_CRYPTO_OPERATION_FAILED(
         env, "Error generating ticket keys");
   }
-  SSL_CTX_set_tlsext_ticket_key_cb(sc->ctx_.get(), TicketCompatibilityCallback);
+  Thin_SSL_CTX_set_tlsext_ticket_key_cb(sc->ctx_.get(), TicketCompatibilityCallback);
 }
 
 SSLPointer SecureContext::CreateSSL() {
-  return SSLPointer(SSL_new(ctx_.get()));
+  return SSLPointer(Thin_SSL_new(ctx_.get()));
 }
 
 void SecureContext::SetNewSessionCallback(NewSessionCb cb) {
-  SSL_CTX_sess_set_new_cb(ctx_.get(), cb);
+  Thin_SSL_CTX_sess_set_new_cb(ctx_.get(), cb);
 }
 
 void SecureContext::SetGetSessionCallback(GetSessionCb cb) {
-  SSL_CTX_sess_set_get_cb(ctx_.get(), cb);
+  Thin_SSL_CTX_sess_set_get_cb(ctx_.get(), cb);
 }
 
 void SecureContext::SetSelectSNIContextCallback(SelectSNIContextCb cb) {
-  SSL_CTX_set_tlsext_servername_callback(ctx_.get(), cb);
+  Thin_SSL_CTX_set_tlsext_servername_callback(ctx_.get(), cb);
 }
 
 void SecureContext::SetSelectClientCertCallback(SelectClientCertCb cb) {
-  SSL_CTX_set_client_cert_cb(ctx_.get(), cb);
+  Thin_SSL_CTX_set_client_cert_cb(ctx_.get(), cb);
 }
 
 void SecureContext::SetKeylogCallback(KeylogCb cb) {
-  SSL_CTX_set_keylog_callback(ctx_.get(), cb);
+  Thin_SSL_CTX_set_keylog_callback(ctx_.get(), cb);
 }
 
 Maybe<bool> SecureContext::UseKey(Environment* env,
@@ -588,8 +588,8 @@ Maybe<bool> SecureContext::UseKey(Environment* env,
   }
 
   ClearErrorOnReturn clear_error_on_return;
-  if (!SSL_CTX_use_PrivateKey(ctx_.get(), key->GetAsymmetricKey().get())) {
-    ThrowCryptoError(env, ERR_get_error(), "SSL_CTX_use_PrivateKey");
+  if (!Thin_SSL_CTX_use_PrivateKey(ctx_.get(), key->GetAsymmetricKey().get())) {
+    ThrowCryptoError(env, Thin_ERR_get_error(), "Thin_SSL_CTX_use_PrivateKey");
     return Nothing<bool>();
   }
 
@@ -617,16 +617,16 @@ void SecureContext::SetKey(const FunctionCallbackInfo<Value>& args) {
   const ByteSource* pass_ptr = &passphrase;
 
   EVPKeyPointer key(
-      PEM_read_bio_PrivateKey(bio.get(),
+      Thin_PEM_read_bio_PrivateKey(bio.get(),
                               nullptr,
                               PasswordCallback,
                               &pass_ptr));
 
   if (!key)
-    return ThrowCryptoError(env, ERR_get_error(), "PEM_read_bio_PrivateKey");
+    return ThrowCryptoError(env, Thin_ERR_get_error(), "Thin_PEM_read_bio_PrivateKey");
 
-  if (!SSL_CTX_use_PrivateKey(sc->ctx_.get(), key.get()))
-    return ThrowCryptoError(env, ERR_get_error(), "SSL_CTX_use_PrivateKey");
+  if (!Thin_SSL_CTX_use_PrivateKey(sc->ctx_.get(), key.get()))
+    return ThrowCryptoError(env, Thin_ERR_get_error(), "Thin_SSL_CTX_use_PrivateKey");
   sc->client_key_provided_ = true;
 }
 
@@ -641,8 +641,8 @@ void SecureContext::SetSigalgs(const FunctionCallbackInfo<Value>& args) {
 
   const Utf8Value sigalgs(env->isolate(), args[0]);
 
-  if (!SSL_CTX_set1_sigalgs_list(sc->ctx_.get(), *sigalgs))
-    return ThrowCryptoError(env, ERR_get_error());
+  if (!Thin_SSL_CTX_set1_sigalgs_list(sc->ctx_.get(), *sigalgs))
+    return ThrowCryptoError(env, Thin_ERR_get_error());
 }
 
 #ifndef OPENSSL_NO_ENGINE
@@ -671,7 +671,7 @@ void SecureContext::SetEngineKey(const FunctionCallbackInfo<Value>& args) {
     return;
   }
 
-  if (!ENGINE_init(engine.get())) {
+  if (!Thin_ENGINE_init(engine.get())) {
     return THROW_ERR_CRYPTO_OPERATION_FAILED(
         env, "Failure to initialize engine");
   }
@@ -679,14 +679,14 @@ void SecureContext::SetEngineKey(const FunctionCallbackInfo<Value>& args) {
   engine.finish_on_exit = true;
 
   Utf8Value key_name(env->isolate(), args[0]);
-  EVPKeyPointer key(ENGINE_load_private_key(engine.get(), *key_name,
+  EVPKeyPointer key(Thin_ENGINE_load_private_key(engine.get(), *key_name,
                                             nullptr, nullptr));
 
   if (!key)
-    return ThrowCryptoError(env, ERR_get_error(), "ENGINE_load_private_key");
+    return ThrowCryptoError(env, Thin_ERR_get_error(), "Thin_ENGINE_load_private_key");
 
-  if (!SSL_CTX_use_PrivateKey(sc->ctx_.get(), key.get()))
-    return ThrowCryptoError(env, ERR_get_error(), "SSL_CTX_use_PrivateKey");
+  if (!Thin_SSL_CTX_use_PrivateKey(sc->ctx_.get(), key.get()))
+    return ThrowCryptoError(env, Thin_ERR_get_error(), "Thin_SSL_CTX_use_PrivateKey");
 
   sc->private_key_engine_ = std::move(engine);
 }
@@ -698,12 +698,12 @@ Maybe<bool> SecureContext::AddCert(Environment* env, BIOPointer&& bio) {
   cert_.reset();
   issuer_.reset();
 
-  // The SSL_CTX_use_certificate_chain call here is not from openssl, this is
+  // The Thin_SSL_CTX_use_certificate_chain call here is not from openssl, this is
   // the method implemented elsewhere in this file. The naming is a bit
   // confusing, unfortunately.
-  if (SSL_CTX_use_certificate_chain(
+  if (Thin_SSL_CTX_use_certificate_chain(
           ctx_.get(), std::move(bio), &cert_, &issuer_) == 0) {
-    ThrowCryptoError(env, ERR_get_error(), "SSL_CTX_use_certificate_chain");
+    ThrowCryptoError(env, Thin_ERR_get_error(), "Thin_SSL_CTX_use_certificate_chain");
     return Nothing<bool>();
   }
   return Just(true);
@@ -724,18 +724,18 @@ void SecureContext::SetCert(const FunctionCallbackInfo<Value>& args) {
 void SecureContext::SetCACert(const BIOPointer& bio) {
   ClearErrorOnReturn clear_error_on_return;
   if (!bio) return;
-  X509_STORE* cert_store = SSL_CTX_get_cert_store(ctx_.get());
-  while (X509Pointer x509 = X509Pointer(PEM_read_bio_X509_AUX(
+  X509_STORE* cert_store = Thin_SSL_CTX_get_cert_store(ctx_.get());
+  while (X509Pointer x509 = X509Pointer(Thin_PEM_read_bio_X509_AUX(
              bio.get(), nullptr, NoPasswordCallback, nullptr))) {
     if (cert_store == GetOrCreateRootCertStore()) {
       cert_store = NewRootCertStore();
-      SSL_CTX_set_cert_store(ctx_.get(), cert_store);
+      Thin_SSL_CTX_set_cert_store(ctx_.get(), cert_store);
     }
-    CHECK_EQ(1, X509_STORE_add_cert(cert_store, x509.get()));
-    CHECK_EQ(1, SSL_CTX_add_client_CA(ctx_.get(), x509.get()));
+    CHECK_EQ(1, Thin_X509_STORE_add_cert(cert_store, x509.get()));
+    CHECK_EQ(1, Thin_SSL_CTX_add_client_CA(ctx_.get(), x509.get()));
   }
   if (cert_store) {
-    X509_STORE_set_flags(cert_store, X509_V_FLAG_PARTIAL_CHAIN);
+    Thin_X509_STORE_set_flags(cert_store, X509_V_FLAG_PARTIAL_CHAIN);
   }
 }
 
@@ -755,23 +755,23 @@ Maybe<bool> SecureContext::SetCRL(Environment* env, const BIOPointer& bio) {
   ClearErrorOnReturn clear_error_on_return;
   if (!bio) return Just(false);
 
-  DeleteFnPtr<X509_CRL, X509_CRL_free> crl(
-      PEM_read_bio_X509_CRL(bio.get(), nullptr, NoPasswordCallback, nullptr));
+  DeleteFnPtr<X509_CRL, Thin_X509_CRL_free> crl(
+      Thin_PEM_read_bio_X509_CRL(bio.get(), nullptr, NoPasswordCallback, nullptr));
 
   if (!crl) {
     THROW_ERR_CRYPTO_OPERATION_FAILED(env, "Failed to parse CRL");
     return Nothing<bool>();
   }
 
-  X509_STORE* cert_store = SSL_CTX_get_cert_store(ctx_.get());
+  X509_STORE* cert_store = Thin_SSL_CTX_get_cert_store(ctx_.get());
   if (cert_store == GetOrCreateRootCertStore()) {
     cert_store = NewRootCertStore();
-    SSL_CTX_set_cert_store(ctx_.get(), cert_store);
+    Thin_SSL_CTX_set_cert_store(ctx_.get(), cert_store);
   }
 
-  CHECK_EQ(1, X509_STORE_add_crl(cert_store, crl.get()));
+  CHECK_EQ(1, Thin_X509_STORE_add_crl(cert_store, crl.get()));
   CHECK_EQ(1,
-           X509_STORE_set_flags(
+           Thin_X509_STORE_set_flags(
                cert_store, X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL));
   return Just(true);
 }
@@ -793,9 +793,9 @@ void SecureContext::SetRootCerts() {
   auto store = GetOrCreateRootCertStore();
 
   // Increment reference count so global store is not deleted along with CTX.
-  X509_STORE_up_ref(store);
-  X509_STORE_set_flags(store, X509_V_FLAG_PARTIAL_CHAIN);
-  SSL_CTX_set_cert_store(ctx_.get(), store);
+  Thin_X509_STORE_up_ref(store);
+  Thin_X509_STORE_set_flags(store, X509_V_FLAG_PARTIAL_CHAIN);
+  Thin_SSL_CTX_set_cert_store(ctx_.get(), store);
 }
 
 void SecureContext::AddRootCerts(const FunctionCallbackInfo<Value>& args) {
@@ -806,7 +806,6 @@ void SecureContext::AddRootCerts(const FunctionCallbackInfo<Value>& args) {
 
 void SecureContext::SetCipherSuites(const FunctionCallbackInfo<Value>& args) {
   // BoringSSL doesn't allow API config of TLS1.3 cipher suites.
-#ifndef OPENSSL_IS_BORINGSSL
   SecureContext* sc;
   ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
   Environment* env = sc->env();
@@ -816,9 +815,8 @@ void SecureContext::SetCipherSuites(const FunctionCallbackInfo<Value>& args) {
   CHECK(args[0]->IsString());
 
   const Utf8Value ciphers(env->isolate(), args[0]);
-  if (!SSL_CTX_set_ciphersuites(sc->ctx_.get(), *ciphers))
-    return ThrowCryptoError(env, ERR_get_error(), "Failed to set ciphers");
-#endif
+  if (!Thin_SSL_CTX_set_ciphersuites(sc->ctx_.get(), *ciphers))
+    return ThrowCryptoError(env, Thin_ERR_get_error(), "Failed to set ciphers");
 }
 
 void SecureContext::SetCiphers(const FunctionCallbackInfo<Value>& args) {
@@ -831,8 +829,8 @@ void SecureContext::SetCiphers(const FunctionCallbackInfo<Value>& args) {
   CHECK(args[0]->IsString());
 
   Utf8Value ciphers(env->isolate(), args[0]);
-  if (!SSL_CTX_set_cipher_list(sc->ctx_.get(), *ciphers)) {
-    unsigned long err = ERR_get_error();  // NOLINT(runtime/int)
+  if (!Thin_SSL_CTX_set_cipher_list(sc->ctx_.get(), *ciphers)) {
+    unsigned long err = Thin_ERR_get_error();  // NOLINT(runtime/int)
 
     if (strlen(*ciphers) == 0 && ERR_GET_REASON(err) == SSL_R_NO_CIPHER_MATCH) {
       // TLS1.2 ciphers were deliberately cleared, so don't consider
@@ -855,7 +853,7 @@ void SecureContext::SetECDHCurve(const FunctionCallbackInfo<Value>& args) {
 
   Utf8Value curve(env->isolate(), args[0]);
 
-  if (curve != "auto" && !SSL_CTX_set1_curves_list(sc->ctx_.get(), *curve)) {
+  if (curve != "auto" && !Thin_SSL_CTX_set1_curves_list(sc->ctx_.get(), *curve)) {
     return THROW_ERR_CRYPTO_OPERATION_FAILED(env, "Failed to set ECDH curve");
   }
 }
@@ -871,12 +869,10 @@ void SecureContext::SetDHParam(const FunctionCallbackInfo<Value>& args) {
   // If the user specified "auto" for dhparams, the JavaScript layer will pass
   // true to this function instead of the original string. Any other string
   // value will be interpreted as custom DH parameters below.
-#ifndef OPENSSL_IS_BORINGSSL
   if (args[0]->IsTrue()) {
-    CHECK(SSL_CTX_set_dh_auto(sc->ctx_.get(), true));
+    CHECK(Thin_SSL_CTX_set_dh_auto(sc->ctx_.get(), true));
     return;
   }
-#endif
 
   DHPointer dh;
   {
@@ -884,7 +880,7 @@ void SecureContext::SetDHParam(const FunctionCallbackInfo<Value>& args) {
     if (!bio)
       return;
 
-    dh.reset(PEM_read_bio_DHparams(bio.get(), nullptr, nullptr, nullptr));
+    dh.reset(Thin_PEM_read_bio_DHparams(bio.get(), nullptr, nullptr, nullptr));
   }
 
   // Invalid dhparam is silently discarded and DHE is no longer used.
@@ -893,8 +889,8 @@ void SecureContext::SetDHParam(const FunctionCallbackInfo<Value>& args) {
     return;
 
   const BIGNUM* p;
-  DH_get0_pqg(dh.get(), &p, nullptr, nullptr);
-  const int size = BN_num_bits(p);
+  Thin_DH_get0_pqg(dh.get(), &p, nullptr, nullptr);
+  const int size = Thin_BN_num_bits(p);
   if (size < 1024) {
     return THROW_ERR_INVALID_ARG_VALUE(
         env, "DH parameter is less than 1024 bits");
@@ -903,7 +899,7 @@ void SecureContext::SetDHParam(const FunctionCallbackInfo<Value>& args) {
         env->isolate(), "DH parameter is less than 2048 bits"));
   }
 
-  if (!SSL_CTX_set_tmp_dh(sc->ctx_.get(), dh.get())) {
+  if (!Thin_SSL_CTX_set_tmp_dh(sc->ctx_.get(), dh.get())) {
     return THROW_ERR_CRYPTO_OPERATION_FAILED(
         env, "Error setting temp DH parameter");
   }
@@ -918,7 +914,7 @@ void SecureContext::SetMinProto(const FunctionCallbackInfo<Value>& args) {
 
   int version = args[0].As<Int32>()->Value();
 
-  CHECK(SSL_CTX_set_min_proto_version(sc->ctx_.get(), version));
+  CHECK(Thin_SSL_CTX_set_min_proto_version(sc->ctx_.get(), version));
 }
 
 void SecureContext::SetMaxProto(const FunctionCallbackInfo<Value>& args) {
@@ -930,7 +926,7 @@ void SecureContext::SetMaxProto(const FunctionCallbackInfo<Value>& args) {
 
   int version = args[0].As<Int32>()->Value();
 
-  CHECK(SSL_CTX_set_max_proto_version(sc->ctx_.get(), version));
+  CHECK(Thin_SSL_CTX_set_max_proto_version(sc->ctx_.get(), version));
 }
 
 void SecureContext::GetMinProto(const FunctionCallbackInfo<Value>& args) {
@@ -940,7 +936,7 @@ void SecureContext::GetMinProto(const FunctionCallbackInfo<Value>& args) {
   CHECK_EQ(args.Length(), 0);
 
   long version =  // NOLINT(runtime/int)
-    SSL_CTX_get_min_proto_version(sc->ctx_.get());
+    Thin_SSL_CTX_get_min_proto_version(sc->ctx_.get());
   args.GetReturnValue().Set(static_cast<uint32_t>(version));
 }
 
@@ -951,7 +947,7 @@ void SecureContext::GetMaxProto(const FunctionCallbackInfo<Value>& args) {
   CHECK_EQ(args.Length(), 0);
 
   long version =  // NOLINT(runtime/int)
-    SSL_CTX_get_max_proto_version(sc->ctx_.get());
+    Thin_SSL_CTX_get_max_proto_version(sc->ctx_.get());
   args.GetReturnValue().Set(static_cast<uint32_t>(version));
 }
 
@@ -965,7 +961,7 @@ void SecureContext::SetOptions(const FunctionCallbackInfo<Value>& args) {
 
   int64_t val = args[0]->IntegerValue(env->context()).FromMaybe(0);
 
-  SSL_CTX_set_options(sc->ctx_.get(),
+  Thin_SSL_CTX_set_options(sc->ctx_.get(),
                       static_cast<long>(val));  // NOLINT(runtime/int)
 }
 
@@ -983,19 +979,19 @@ void SecureContext::SetSessionIdContext(
       reinterpret_cast<const unsigned char*>(*sessionIdContext);
   unsigned int sid_ctx_len = sessionIdContext.length();
 
-  if (SSL_CTX_set_session_id_context(sc->ctx_.get(), sid_ctx, sid_ctx_len) == 1)
+  if (Thin_SSL_CTX_set_session_id_context(sc->ctx_.get(), sid_ctx, sid_ctx_len) == 1)
     return;
 
   BUF_MEM* mem;
   Local<String> message;
 
-  BIOPointer bio(BIO_new(BIO_s_mem()));
+  BIOPointer bio(Thin_BIO_new(Thin_BIO_s_mem()));
   if (!bio) {
     message = FIXED_ONE_BYTE_STRING(env->isolate(),
-                                    "SSL_CTX_set_session_id_context error");
+                                    "Thin_SSL_CTX_set_session_id_context error");
   } else {
-    ERR_print_errors(bio.get());
-    BIO_get_mem_ptr(bio.get(), &mem);
+    Thin_ERR_print_errors(bio.get());
+    Thin_BIO_get_mem_ptr(bio.get(), &mem);
     message = OneByteString(env->isolate(), mem->data, mem->length);
   }
 
@@ -1010,7 +1006,7 @@ void SecureContext::SetSessionTimeout(const FunctionCallbackInfo<Value>& args) {
   CHECK(args[0]->IsInt32());
 
   int32_t sessionTimeout = args[0].As<Int32>()->Value();
-  SSL_CTX_set_timeout(sc->ctx_.get(), sessionTimeout);
+  Thin_SSL_CTX_set_timeout(sc->ctx_.get(), sessionTimeout);
 }
 
 void SecureContext::Close(const FunctionCallbackInfo<Value>& args) {
@@ -1053,9 +1049,9 @@ void SecureContext::LoadPKCS12(const FunctionCallbackInfo<Value>& args) {
   sc->issuer_.reset();
   sc->cert_.reset();
 
-  X509_STORE* cert_store = SSL_CTX_get_cert_store(sc->ctx_.get());
+  X509_STORE* cert_store = Thin_SSL_CTX_get_cert_store(sc->ctx_.get());
 
-  DeleteFnPtr<PKCS12, PKCS12_free> p12;
+  DeleteFnPtr<PKCS12, Thin_PKCS12_free> p12;
   EVPKeyPointer pkey;
   X509Pointer cert;
   StackOfX509 extra_certs;
@@ -1065,14 +1061,14 @@ void SecureContext::LoadPKCS12(const FunctionCallbackInfo<Value>& args) {
   X509* cert_ptr = nullptr;
   STACK_OF(X509)* extra_certs_ptr = nullptr;
 
-  if (!d2i_PKCS12_bio(in.get(), &p12_ptr)) {
+  if (!Thin_d2i_PKCS12_bio(in.get(), &p12_ptr)) {
     goto done;
   }
 
   // Move ownership to the smart pointer:
   p12.reset(p12_ptr);
 
-  if (!PKCS12_parse(
+  if (!Thin_PKCS12_parse(
           p12.get(), pass.data(), &pkey_ptr, &cert_ptr, &extra_certs_ptr)) {
     goto done;
   }
@@ -1092,7 +1088,7 @@ void SecureContext::LoadPKCS12(const FunctionCallbackInfo<Value>& args) {
         env, "Unable to load certificate from PFX data");
   }
 
-  if (!SSL_CTX_use_certificate_chain(sc->ctx_.get(),
+  if (!Thin_SSL_CTX_use_certificate_chain(sc->ctx_.get(),
                                      std::move(cert),
                                      extra_certs.get(),
                                      &sc->cert_,
@@ -1100,28 +1096,28 @@ void SecureContext::LoadPKCS12(const FunctionCallbackInfo<Value>& args) {
     goto done;
   }
 
-  if (!SSL_CTX_use_PrivateKey(sc->ctx_.get(), pkey.get())) {
+  if (!Thin_SSL_CTX_use_PrivateKey(sc->ctx_.get(), pkey.get())) {
     goto done;
   }
 
   // Add CA certs too
-  for (int i = 0; i < sk_X509_num(extra_certs.get()); i++) {
-    X509* ca = sk_X509_value(extra_certs.get(), i);
+  for (int i = 0; i < Thin_sk_X509_num(extra_certs.get()); i++) {
+    X509* ca = Thin_sk_X509_value(extra_certs.get(), i);
 
     if (cert_store == GetOrCreateRootCertStore()) {
       cert_store = NewRootCertStore();
-      SSL_CTX_set_cert_store(sc->ctx_.get(), cert_store);
+      Thin_SSL_CTX_set_cert_store(sc->ctx_.get(), cert_store);
     }
-    X509_STORE_add_cert(cert_store, ca);
-    SSL_CTX_add_client_CA(sc->ctx_.get(), ca);
+    Thin_X509_STORE_add_cert(cert_store, ca);
+    Thin_SSL_CTX_add_client_CA(sc->ctx_.get(), ca);
   }
   ret = true;
 
 done:
   if (!ret) {
     // TODO(@jasnell): Should this use ThrowCryptoError?
-    unsigned long err = ERR_get_error();  // NOLINT(runtime/int)
-    const char* str = ERR_reason_error_string(err);
+    unsigned long err = Thin_ERR_get_error();  // NOLINT(runtime/int)
+    const char* str = Thin_ERR_reason_error_string(err);
     str = str != nullptr ? str : "Unknown error";
 
     return env->ThrowError(str);
@@ -1140,7 +1136,7 @@ void SecureContext::SetClientCertEngine(
 
   MarkPopErrorOnReturn mark_pop_error_on_return;
 
-  // SSL_CTX_set_client_cert_engine does not itself support multiple
+  // Thin_SSL_CTX_set_client_cert_engine does not itself support multiple
   // calls by cleaning up before overwriting the client_cert_engine
   // internal context variable.
   // Instead of trying to fix up this problem we in turn also do not
@@ -1165,8 +1161,8 @@ void SecureContext::SetClientCertEngine(
   }
 
   // Note that this takes another reference to `engine`.
-  if (!SSL_CTX_set_client_cert_engine(sc->ctx_.get(), engine.get()))
-    return ThrowCryptoError(env, ERR_get_error());
+  if (!Thin_SSL_CTX_set_client_cert_engine(sc->ctx_.get(), engine.get()))
+    return ThrowCryptoError(env, Thin_ERR_get_error());
   sc->client_cert_engine_provided_ = true;
 }
 #endif  // !OPENSSL_NO_ENGINE
@@ -1210,7 +1206,7 @@ void SecureContext::EnableTicketKeyCallback(
   SecureContext* wrap;
   ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
 
-  SSL_CTX_set_tlsext_ticket_key_cb(wrap->ctx_.get(), TicketKeyCallback);
+  Thin_SSL_CTX_set_tlsext_ticket_key_cb(wrap->ctx_.get(), TicketKeyCallback);
 }
 
 int SecureContext::TicketKeyCallback(SSL* ssl,
@@ -1222,7 +1218,7 @@ int SecureContext::TicketKeyCallback(SSL* ssl,
   static const int kTicketPartSize = 16;
 
   SecureContext* sc = static_cast<SecureContext*>(
-      SSL_CTX_get_app_data(SSL_get_SSL_CTX(ssl)));
+      Thin_SSL_CTX_get_app_data(Thin_SSL_get_SSL_CTX(ssl)));
 
   Environment* env = sc->env();
   HandleScope handle_scope(env->isolate());
@@ -1290,22 +1286,22 @@ int SecureContext::TicketKeyCallback(SSL* ssl,
   }
 
   ArrayBufferViewContents<unsigned char> hmac_buf(hmac);
-  HMAC_Init_ex(hctx,
+  Thin_HMAC_Init_ex(hctx,
                hmac_buf.data(),
                hmac_buf.length(),
-               EVP_sha256(),
+               Thin_EVP_sha256(),
                nullptr);
 
   ArrayBufferViewContents<unsigned char> aes_key(aes.As<ArrayBufferView>());
   if (enc) {
-    EVP_EncryptInit_ex(ectx,
-                       EVP_aes_128_cbc(),
+    Thin_EVP_EncryptInit_ex(ectx,
+                       Thin_EVP_aes_128_cbc(),
                        nullptr,
                        aes_key.data(),
                        iv);
   } else {
-    EVP_DecryptInit_ex(ectx,
-                       EVP_aes_128_cbc(),
+    Thin_EVP_DecryptInit_ex(ectx,
+                       Thin_EVP_aes_128_cbc(),
                        nullptr,
                        aes_key.data(),
                        iv);
@@ -1321,17 +1317,17 @@ int SecureContext::TicketCompatibilityCallback(SSL* ssl,
                                                HMAC_CTX* hctx,
                                                int enc) {
   SecureContext* sc = static_cast<SecureContext*>(
-      SSL_CTX_get_app_data(SSL_get_SSL_CTX(ssl)));
+      Thin_SSL_CTX_get_app_data(Thin_SSL_get_SSL_CTX(ssl)));
 
   if (enc) {
     memcpy(name, sc->ticket_key_name_, sizeof(sc->ticket_key_name_));
     if (CSPRNG(iv, 16).is_err() ||
-        EVP_EncryptInit_ex(
-            ectx, EVP_aes_128_cbc(), nullptr, sc->ticket_key_aes_, iv) <= 0 ||
-        HMAC_Init_ex(hctx,
+        Thin_EVP_EncryptInit_ex(
+            ectx, Thin_EVP_aes_128_cbc(), nullptr, sc->ticket_key_aes_, iv) <= 0 ||
+        Thin_HMAC_Init_ex(hctx,
                      sc->ticket_key_hmac_,
                      sizeof(sc->ticket_key_hmac_),
-                     EVP_sha256(),
+                     Thin_EVP_sha256(),
                      nullptr) <= 0) {
       return -1;
     }
@@ -1343,10 +1339,10 @@ int SecureContext::TicketCompatibilityCallback(SSL* ssl,
     return 0;
   }
 
-  if (EVP_DecryptInit_ex(ectx, EVP_aes_128_cbc(), nullptr, sc->ticket_key_aes_,
+  if (Thin_EVP_DecryptInit_ex(ectx, Thin_EVP_aes_128_cbc(), nullptr, sc->ticket_key_aes_,
                          iv) <= 0 ||
-      HMAC_Init_ex(hctx, sc->ticket_key_hmac_, sizeof(sc->ticket_key_hmac_),
-                   EVP_sha256(), nullptr) <= 0) {
+      Thin_HMAC_Init_ex(hctx, sc->ticket_key_hmac_, sizeof(sc->ticket_key_hmac_),
+                   Thin_EVP_sha256(), nullptr) <= 0) {
     return -1;
   }
   return 1;
@@ -1373,13 +1369,13 @@ void SecureContext::GetCertificate(const FunctionCallbackInfo<Value>& args) {
   if (cert == nullptr)
     return args.GetReturnValue().SetNull();
 
-  int size = i2d_X509(cert, nullptr);
+  int size = Thin_i2d_X509(cert, nullptr);
   Local<Object> buff;
   if (!Buffer::New(env, size).ToLocal(&buff))
     return;
   unsigned char* serialized = reinterpret_cast<unsigned char*>(
       Buffer::Data(buff));
-  i2d_X509(cert, &serialized);
+  Thin_i2d_X509(cert, &serialized);
 
   args.GetReturnValue().Set(buff);
 }
@@ -1388,19 +1384,19 @@ namespace {
 unsigned long AddCertsFromFile(  // NOLINT(runtime/int)
     X509_STORE* store,
     const char* file) {
-  ERR_clear_error();
+  Thin_ERR_clear_error();
   MarkPopErrorOnReturn mark_pop_error_on_return;
 
-  BIOPointer bio(BIO_new_file(file, "r"));
+  BIOPointer bio(Thin_BIO_new_file(file, "r"));
   if (!bio)
-    return ERR_get_error();
+    return Thin_ERR_get_error();
 
-  while (X509Pointer x509 = X509Pointer(PEM_read_bio_X509(
+  while (X509Pointer x509 = X509Pointer(Thin_PEM_read_bio_X509(
              bio.get(), nullptr, NoPasswordCallback, nullptr))) {
-    X509_STORE_add_cert(store, x509.get());
+    Thin_X509_STORE_add_cert(store, x509.get());
   }
 
-  unsigned long err = ERR_peek_error();  // NOLINT(runtime/int)
+  unsigned long err = Thin_ERR_peek_error();  // NOLINT(runtime/int)
   // Ignore error if its EOF/no start line found.
   if (ERR_GET_LIB(err) == ERR_LIB_PEM &&
       ERR_GET_REASON(err) == PEM_R_NO_START_LINE) {
@@ -1418,7 +1414,7 @@ void UseExtraCaCerts(const std::string& file) {
   X509_STORE* store = GetOrCreateRootCertStore();
   if (auto err = AddCertsFromFile(store, file.c_str())) {
     char buf[256];
-    ERR_error_string_n(err, buf, sizeof(buf));
+    Thin_ERR_error_string_n(err, buf, sizeof(buf));
     fprintf(stderr,
             "Warning: Ignoring extra certs from `%s`, load failed: %s\n",
             file.c_str(),
diff --git a/src/crypto/crypto_dh.cc b/src/crypto/crypto_dh.cc
index 678be07feb..e7427efe7d 100644
--- a/src/crypto/crypto_dh.cc
+++ b/src/crypto/crypto_dh.cc
@@ -40,8 +40,8 @@ namespace {
 void ZeroPadDiffieHellmanSecret(size_t remainder_size,
                                 char* data,
                                 size_t length) {
-  // DH_size returns number of bytes in a prime number.
-  // DH_compute_key returns number of bytes in a remainder of exponent, which
+  // Thin_DH_size returns number of bytes in a prime number.
+  // Thin_DH_compute_key returns number of bytes in a remainder of exponent, which
   // may have less bytes than a prime number. Therefore add 0-padding to the
   // allocated buffer.
   const size_t prime_size = length;
@@ -132,8 +132,8 @@ void DiffieHellman::RegisterExternalReferences(
 }
 
 bool DiffieHellman::Init(int primeLength, int g) {
-  dh_.reset(DH_new());
-  if (!DH_generate_parameters_ex(dh_.get(), primeLength, g, nullptr))
+  dh_.reset(Thin_DH_new());
+  if (!Thin_DH_generate_parameters_ex(dh_.get(), primeLength, g, nullptr))
     return false;
   return VerifyContext();
 }
@@ -143,56 +143,61 @@ void DiffieHellman::MemoryInfo(MemoryTracker* tracker) const {
 }
 
 bool DiffieHellman::Init(BignumPointer&& bn_p, int g) {
-  dh_.reset(DH_new());
+  dh_.reset(Thin_DH_new());
   CHECK_GE(g, 2);
-  BignumPointer bn_g(BN_new());
-  return bn_g && BN_set_word(bn_g.get(), g) &&
-         DH_set0_pqg(dh_.get(), bn_p.release(), nullptr, bn_g.release()) &&
+  BignumPointer bn_g(Thin_BN_new());
+  return bn_g && Thin_BN_set_word(bn_g.get(), g) &&
+         Thin_DH_set0_pqg(dh_.get(), bn_p.release(), nullptr, bn_g.release()) &&
          VerifyContext();
 }
 
 bool DiffieHellman::Init(const char* p, int p_len, int g) {
-  dh_.reset(DH_new());
+  dh_.reset(Thin_DH_new());
   if (p_len <= 0) {
-    OPENSSL_PUT_ERROR(BN, BN_R_BITS_TOO_SMALL);
+    Thin_ERR_put_error(ERR_LIB_BN, BN_F_BN_GENERATE_PRIME_EX,
+      BN_R_BITS_TOO_SMALL, __FILE__, __LINE__);
     return false;
   }
   if (g <= 1) {
-    OPENSSL_PUT_ERROR(DH, DH_R_BAD_GENERATOR);
+    Thin_ERR_put_error(ERR_LIB_DH, DH_F_DH_BUILTIN_GENPARAMS,
+      DH_R_BAD_GENERATOR, __FILE__, __LINE__);
     return false;
   }
   BignumPointer bn_p(
-      BN_bin2bn(reinterpret_cast<const unsigned char*>(p), p_len, nullptr));
-  BignumPointer bn_g(BN_new());
-  if (bn_p == nullptr || bn_g == nullptr || !BN_set_word(bn_g.get(), g) ||
-      !DH_set0_pqg(dh_.get(), bn_p.release(), nullptr, bn_g.release())) {
+      Thin_BN_bin2bn(reinterpret_cast<const unsigned char*>(p), p_len, nullptr));
+  BignumPointer bn_g(Thin_BN_new());
+  if (bn_p == nullptr || bn_g == nullptr || !Thin_BN_set_word(bn_g.get(), g) ||
+      !Thin_DH_set0_pqg(dh_.get(), bn_p.release(), nullptr, bn_g.release())) {
     return false;
   }
   return VerifyContext();
 }
 
 bool DiffieHellman::Init(const char* p, int p_len, const char* g, int g_len) {
-  dh_.reset(DH_new());
+  dh_.reset(Thin_DH_new());
   if (p_len <= 0) {
-    OPENSSL_PUT_ERROR(BN, BN_R_BITS_TOO_SMALL);
+    Thin_ERR_put_error(ERR_LIB_BN, BN_F_BN_GENERATE_PRIME_EX,
+      BN_R_BITS_TOO_SMALL, __FILE__, __LINE__);
     return false;
   }
   if (g_len <= 0) {
-    OPENSSL_PUT_ERROR(DH, DH_R_BAD_GENERATOR);
+    Thin_ERR_put_error(ERR_LIB_DH, DH_F_DH_BUILTIN_GENPARAMS,
+      DH_R_BAD_GENERATOR, __FILE__, __LINE__);
     return false;
   }
   BignumPointer bn_g(
-      BN_bin2bn(reinterpret_cast<const unsigned char*>(g), g_len, nullptr));
-  if (BN_is_zero(bn_g.get()) || BN_is_one(bn_g.get())) {
-    OPENSSL_PUT_ERROR(DH, DH_R_BAD_GENERATOR);
+      Thin_BN_bin2bn(reinterpret_cast<const unsigned char*>(g), g_len, nullptr));
+  if (Thin_BN_is_zero(bn_g.get()) || Thin_BN_is_one(bn_g.get())) {
+    Thin_ERR_put_error(ERR_LIB_DH, DH_F_DH_BUILTIN_GENPARAMS,
+      DH_R_BAD_GENERATOR, __FILE__, __LINE__);
     return false;
   }
   BignumPointer bn_p(
-      BN_bin2bn(reinterpret_cast<const unsigned char*>(p), p_len, nullptr));
-  if (!DH_set0_pqg(dh_.get(), bn_p.get(), nullptr, bn_g.get())) {
+      Thin_BN_bin2bn(reinterpret_cast<const unsigned char*>(p), p_len, nullptr));
+  if (!Thin_DH_set0_pqg(dh_.get(), bn_p.get(), nullptr, bn_g.get())) {
     return false;
   }
-  // The DH_set0_pqg call above takes ownership of the bignums on success,
+  // The Thin_DH_set0_pqg call above takes ownership of the bignums on success,
   // so we should release them here so we don't end with a possible
   // use-after-free or double free.
   bn_p.release();
@@ -214,10 +219,8 @@ typedef BignumPointer (*StandardizedGroupInstantiator)();
 inline StandardizedGroupInstantiator FindDiffieHellmanGroup(const char* name) {
 #define V(n, p)                                                                \
   if (StringEqualNoCase(name, n)) return InstantiateStandardizedGroup<p>
-#ifndef OPENSSL_IS_BORINGSSL
-  V("modp1", BN_get_rfc2409_prime_768);
-  V("modp2", BN_get_rfc2409_prime_1024);
-#endif
+  V("modp1", Thin_BN_get_rfc2409_prime_768);
+  V("modp2", Thin_BN_get_rfc2409_prime_1024);
   V("modp5", BN_get_rfc3526_prime_1536);
   V("modp14", BN_get_rfc3526_prime_2048);
   V("modp15", BN_get_rfc3526_prime_3072);
@@ -280,7 +283,7 @@ void DiffieHellman::New(const FunctionCallbackInfo<Value>& args) {
   }
 
   if (!initialized) {
-    return ThrowCryptoError(env, ERR_get_error(), "Initialization failed");
+    return ThrowCryptoError(env, Thin_ERR_get_error(), "Initialization failed");
   }
 }
 
@@ -291,23 +294,23 @@ void DiffieHellman::GenerateKeys(const FunctionCallbackInfo<Value>& args) {
   DiffieHellman* diffieHellman;
   ASSIGN_OR_RETURN_UNWRAP(&diffieHellman, args.Holder());
 
-  if (!DH_generate_key(diffieHellman->dh_.get())) {
-    return ThrowCryptoError(env, ERR_get_error(), "Key generation failed");
+  if (!Thin_DH_generate_key(diffieHellman->dh_.get())) {
+    return ThrowCryptoError(env, Thin_ERR_get_error(), "Key generation failed");
   }
 
   const BIGNUM* pub_key;
-  DH_get0_key(diffieHellman->dh_.get(), &pub_key, nullptr);
+  Thin_DH_get0_key(diffieHellman->dh_.get(), &pub_key, nullptr);
 
   std::unique_ptr<BackingStore> bs;
   {
-    const int size = BN_num_bytes(pub_key);
+    const int size = Thin_BN_num_bytes(pub_key);
     CHECK_GE(size, 0);
     NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
     bs = ArrayBuffer::NewBackingStore(env->isolate(), size);
   }
 
   CHECK_EQ(static_cast<int>(bs->ByteLength()),
-           BN_bn2binpad(pub_key,
+           Thin_BN_bn2binpad(pub_key,
                         static_cast<unsigned char*>(bs->Data()),
                         bs->ByteLength()));
 
@@ -332,14 +335,14 @@ void DiffieHellman::GetField(const FunctionCallbackInfo<Value>& args,
 
   std::unique_ptr<BackingStore> bs;
   {
-    const int size = BN_num_bytes(num);
+    const int size = Thin_BN_num_bytes(num);
     CHECK_GE(size, 0);
     NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
     bs = ArrayBuffer::NewBackingStore(env->isolate(), size);
   }
 
   CHECK_EQ(static_cast<int>(bs->ByteLength()),
-           BN_bn2binpad(num,
+           Thin_BN_bn2binpad(num,
                         static_cast<unsigned char*>(bs->Data()),
                         bs->ByteLength()));
 
@@ -352,7 +355,7 @@ void DiffieHellman::GetField(const FunctionCallbackInfo<Value>& args,
 void DiffieHellman::GetPrime(const FunctionCallbackInfo<Value>& args) {
   GetField(args, [](const DH* dh) -> const BIGNUM* {
     const BIGNUM* p;
-    DH_get0_pqg(dh, &p, nullptr, nullptr);
+    Thin_DH_get0_pqg(dh, &p, nullptr, nullptr);
     return p;
   }, "p is null");
 }
@@ -360,7 +363,7 @@ void DiffieHellman::GetPrime(const FunctionCallbackInfo<Value>& args) {
 void DiffieHellman::GetGenerator(const FunctionCallbackInfo<Value>& args) {
   GetField(args, [](const DH* dh) -> const BIGNUM* {
     const BIGNUM* g;
-    DH_get0_pqg(dh, nullptr, nullptr, &g);
+    Thin_DH_get0_pqg(dh, nullptr, nullptr, &g);
     return g;
   }, "g is null");
 }
@@ -368,7 +371,7 @@ void DiffieHellman::GetGenerator(const FunctionCallbackInfo<Value>& args) {
 void DiffieHellman::GetPublicKey(const FunctionCallbackInfo<Value>& args) {
   GetField(args, [](const DH* dh) -> const BIGNUM* {
     const BIGNUM* pub_key;
-    DH_get0_key(dh, &pub_key, nullptr);
+    Thin_DH_get0_key(dh, &pub_key, nullptr);
     return pub_key;
   }, "No public key - did you forget to generate one?");
 }
@@ -376,7 +379,7 @@ void DiffieHellman::GetPublicKey(const FunctionCallbackInfo<Value>& args) {
 void DiffieHellman::GetPrivateKey(const FunctionCallbackInfo<Value>& args) {
   GetField(args, [](const DH* dh) -> const BIGNUM* {
     const BIGNUM* priv_key;
-    DH_get0_key(dh, nullptr, &priv_key);
+    Thin_DH_get0_key(dh, nullptr, &priv_key);
     return priv_key;
   }, "No private key - did you forget to generate one?");
 }
@@ -393,16 +396,16 @@ void DiffieHellman::ComputeSecret(const FunctionCallbackInfo<Value>& args) {
   ArrayBufferOrViewContents<unsigned char> key_buf(args[0]);
   if (UNLIKELY(!key_buf.CheckSizeInt32()))
     return THROW_ERR_OUT_OF_RANGE(env, "secret is too big");
-  BignumPointer key(BN_bin2bn(key_buf.data(), key_buf.size(), nullptr));
+  BignumPointer key(Thin_BN_bin2bn(key_buf.data(), key_buf.size(), nullptr));
 
   std::unique_ptr<BackingStore> bs;
   {
     NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
     bs = ArrayBuffer::NewBackingStore(env->isolate(),
-                                      DH_size(diffieHellman->dh_.get()));
+                                      Thin_DH_size(diffieHellman->dh_.get()));
   }
 
-  int size = DH_compute_key(static_cast<unsigned char*>(bs->Data()),
+  int size = Thin_DH_compute_key(static_cast<unsigned char*>(bs->Data()),
                             key.get(),
                             diffieHellman->dh_.get());
 
@@ -410,12 +413,12 @@ void DiffieHellman::ComputeSecret(const FunctionCallbackInfo<Value>& args) {
     int checkResult;
     int checked;
 
-    checked = DH_check_pub_key(diffieHellman->dh_.get(),
+    checked = Thin_DH_check_pub_key(diffieHellman->dh_.get(),
                                key.get(),
                                &checkResult);
 
     if (!checked) {
-      return ThrowCryptoError(env, ERR_get_error(), "Invalid Key");
+      return ThrowCryptoError(env, Thin_ERR_get_error(), "Invalid Key");
     } else if (checkResult) {
       if (checkResult & DH_CHECK_PUBKEY_TOO_SMALL) {
         return THROW_ERR_CRYPTO_INVALID_KEYLEN(env,
@@ -449,20 +452,20 @@ void DiffieHellman::SetKey(const FunctionCallbackInfo<Value>& args,
   ArrayBufferOrViewContents<unsigned char> buf(args[0]);
   if (UNLIKELY(!buf.CheckSizeInt32()))
     return THROW_ERR_OUT_OF_RANGE(env, "buf is too big");
-  BIGNUM* num = BN_bin2bn(buf.data(), buf.size(), nullptr);
+  BIGNUM* num = Thin_BN_bin2bn(buf.data(), buf.size(), nullptr);
   CHECK_NOT_NULL(num);
   CHECK_EQ(1, set_field(dh->dh_.get(), num));
 }
 
 void DiffieHellman::SetPublicKey(const FunctionCallbackInfo<Value>& args) {
   SetKey(args,
-         [](DH* dh, BIGNUM* num) { return DH_set0_key(dh, num, nullptr); },
+         [](DH* dh, BIGNUM* num) { return Thin_DH_set0_key(dh, num, nullptr); },
          "Public key");
 }
 
 void DiffieHellman::SetPrivateKey(const FunctionCallbackInfo<Value>& args) {
   SetKey(args,
-         [](DH* dh, BIGNUM* num) { return DH_set0_key(dh, nullptr, num); },
+         [](DH* dh, BIGNUM* num) { return Thin_DH_set0_key(dh, nullptr, num); },
          "Private key");
 }
 
@@ -477,7 +480,7 @@ void DiffieHellman::VerifyErrorGetter(const FunctionCallbackInfo<Value>& args) {
 
 bool DiffieHellman::VerifyContext() {
   int codes;
-  if (!DH_check(dh_.get(), &codes))
+  if (!Thin_DH_check(dh_.get(), &codes))
     return false;
   verifyError_ = codes;
   return true;
@@ -530,7 +533,7 @@ Maybe<bool> DhKeyGenTraits::AdditionalConfig(
         return Nothing<bool>();
       }
       params->params.prime = BignumPointer(
-          BN_bin2bn(input.data(), input.size(), nullptr));
+          Thin_BN_bin2bn(input.data(), input.size(), nullptr));
     }
 
     CHECK(args[*offset + 1]->IsInt32());
@@ -545,53 +548,45 @@ EVPKeyCtxPointer DhKeyGenTraits::Setup(DhKeyPairGenConfig* params) {
   EVPKeyPointer key_params;
   if (BignumPointer* prime_fixed_value =
           std::get_if<BignumPointer>(&params->params.prime)) {
-    DHPointer dh(DH_new());
+    DHPointer dh(Thin_DH_new());
     if (!dh)
       return EVPKeyCtxPointer();
 
     BIGNUM* prime = prime_fixed_value->get();
-    BignumPointer bn_g(BN_new());
-    if (!BN_set_word(bn_g.get(), params->params.generator) ||
-        !DH_set0_pqg(dh.get(), prime, nullptr, bn_g.get())) {
+    BignumPointer bn_g(Thin_BN_new());
+    if (!Thin_BN_set_word(bn_g.get(), params->params.generator) ||
+        !Thin_DH_set0_pqg(dh.get(), prime, nullptr, bn_g.get())) {
       return EVPKeyCtxPointer();
     }
 
-#ifndef OPENSSL_IS_BORINGSSL
     prime_fixed_value->release();
     bn_g.release();
 
-    key_params = EVPKeyPointer(EVP_PKEY_new());
+    key_params = EVPKeyPointer(Thin_EVP_PKEY_new());
     CHECK(key_params);
-    CHECK_EQ(EVP_PKEY_assign_DH(key_params.get(), dh.release()), 1);
-#else
-    return EVPKeyCtxPointer();
-#endif
+    CHECK_EQ(Thin_EVP_PKEY_assign_DH(key_params.get(), dh.release()), 1);
   } else if (int* prime_size = std::get_if<int>(&params->params.prime)) {
-    EVPKeyCtxPointer param_ctx(EVP_PKEY_CTX_new_id(EVP_PKEY_DH, nullptr));
+    EVPKeyCtxPointer param_ctx(Thin_EVP_PKEY_CTX_new_id(EVP_PKEY_DH, nullptr));
     EVP_PKEY* raw_params = nullptr;
-#ifndef OPENSSL_IS_BORINGSSL
     if (!param_ctx ||
-        EVP_PKEY_paramgen_init(param_ctx.get()) <= 0 ||
-        EVP_PKEY_CTX_set_dh_paramgen_prime_len(
+        Thin_EVP_PKEY_paramgen_init(param_ctx.get()) <= 0 ||
+        Thin_EVP_PKEY_CTX_set_dh_paramgen_prime_len(
             param_ctx.get(),
             *prime_size) <= 0 ||
-        EVP_PKEY_CTX_set_dh_paramgen_generator(
+        Thin_EVP_PKEY_CTX_set_dh_paramgen_generator(
             param_ctx.get(),
             params->params.generator) <= 0 ||
-        EVP_PKEY_paramgen(param_ctx.get(), &raw_params) <= 0) {
+        Thin_EVP_PKEY_paramgen(param_ctx.get(), &raw_params) <= 0) {
       return EVPKeyCtxPointer();
     }
 
     key_params = EVPKeyPointer(raw_params);
-#else
-    return EVPKeyCtxPointer();
-#endif
   } else {
     UNREACHABLE();
   }
 
-  EVPKeyCtxPointer ctx(EVP_PKEY_CTX_new(key_params.get(), nullptr));
-  if (!ctx || EVP_PKEY_keygen_init(ctx.get()) <= 0)
+  EVPKeyCtxPointer ctx(Thin_EVP_PKEY_CTX_new(key_params.get(), nullptr));
+  if (!ctx || Thin_EVP_PKEY_keygen_init(ctx.get()) <= 0)
     return EVPKeyCtxPointer();
 
   return ctx;
@@ -631,15 +626,15 @@ ByteSource StatelessDiffieHellmanThreadsafe(
     const ManagedEVPPKey& their_key) {
   size_t out_size;
 
-  EVPKeyCtxPointer ctx(EVP_PKEY_CTX_new(our_key.get(), nullptr));
+  EVPKeyCtxPointer ctx(Thin_EVP_PKEY_CTX_new(our_key.get(), nullptr));
   if (!ctx ||
-      EVP_PKEY_derive_init(ctx.get()) <= 0 ||
-      EVP_PKEY_derive_set_peer(ctx.get(), their_key.get()) <= 0 ||
-      EVP_PKEY_derive(ctx.get(), nullptr, &out_size) <= 0)
+      Thin_EVP_PKEY_derive_init(ctx.get()) <= 0 ||
+      Thin_EVP_PKEY_derive_set_peer(ctx.get(), their_key.get()) <= 0 ||
+      Thin_EVP_PKEY_derive(ctx.get(), nullptr, &out_size) <= 0)
     return ByteSource();
 
   ByteSource::Builder out(out_size);
-  if (EVP_PKEY_derive(ctx.get(), out.data<unsigned char>(), &out_size) <= 0) {
+  if (Thin_EVP_PKEY_derive(ctx.get(), out.data<unsigned char>(), &out_size) <= 0) {
     return ByteSource();
   }
 
@@ -668,7 +663,7 @@ void DiffieHellman::Stateless(const FunctionCallbackInfo<Value>& args) {
               .ToLocal(&out)) return;
 
   if (Buffer::Length(out) == 0)
-    return ThrowCryptoError(env, ERR_get_error(), "diffieHellman failed");
+    return ThrowCryptoError(env, Thin_ERR_get_error(), "diffieHellman failed");
 
   args.GetReturnValue().Set(out);
 }
@@ -725,7 +720,7 @@ Maybe<bool> GetDhKeyDetail(
     std::shared_ptr<KeyObjectData> key,
     Local<Object> target) {
   ManagedEVPPKey pkey = key->GetAsymmetricKey();
-  CHECK_EQ(EVP_PKEY_id(pkey.get()), EVP_PKEY_DH);
+  CHECK_EQ(Thin_EVP_PKEY_id(pkey.get()), EVP_PKEY_DH);
   return Just(true);
 }
 
diff --git a/src/crypto/crypto_dsa.cc b/src/crypto/crypto_dsa.cc
index fa48dffc31..d863d0f72d 100644
--- a/src/crypto/crypto_dsa.cc
+++ b/src/crypto/crypto_dsa.cc
@@ -7,15 +7,15 @@
 #include "threadpoolwork-inl.h"
 #include "v8.h"
 
-#include <openssl/bn.h>
-#include <openssl/dsa.h>
+// #include <openssl/bn.h>
+// #include <openssl/dsa.h>
 
 #include <cstdio>
 
 // EVP_PKEY_CTX_set_dsa_paramgen_q_bits was added in OpenSSL 1.1.1e.
 #if OPENSSL_VERSION_NUMBER < 0x1010105fL
 #define EVP_PKEY_CTX_set_dsa_paramgen_q_bits(ctx, qbits)                       \
-  EVP_PKEY_CTX_ctrl((ctx),                                                     \
+  Thin_EVP_PKEY_CTX_ctrl((ctx),                                                     \
                     EVP_PKEY_DSA,                                              \
                     EVP_PKEY_OP_PARAMGEN,                                      \
                     EVP_PKEY_CTRL_DSA_PARAMGEN_Q_BITS,                         \
@@ -38,12 +38,11 @@ using v8::Value;
 
 namespace crypto {
 EVPKeyCtxPointer DsaKeyGenTraits::Setup(DsaKeyPairGenConfig* params) {
-  EVPKeyCtxPointer param_ctx(EVP_PKEY_CTX_new_id(EVP_PKEY_DSA, nullptr));
+  EVPKeyCtxPointer param_ctx(Thin_EVP_PKEY_CTX_new_id(EVP_PKEY_DSA, nullptr));
   EVP_PKEY* raw_params = nullptr;
-#ifndef OPENSSL_IS_BORINGSSL
   if (!param_ctx ||
-      EVP_PKEY_paramgen_init(param_ctx.get()) <= 0 ||
-      EVP_PKEY_CTX_set_dsa_paramgen_bits(
+      Thin_EVP_PKEY_paramgen_init(param_ctx.get()) <= 0 ||
+      Thin_EVP_PKEY_CTX_set_dsa_paramgen_bits(
           param_ctx.get(),
           params->params.modulus_bits) <= 0) {
     return EVPKeyCtxPointer();
@@ -55,16 +54,13 @@ EVPKeyCtxPointer DsaKeyGenTraits::Setup(DsaKeyPairGenConfig* params) {
       return EVPKeyCtxPointer();
     }
   }
-#else
-  return EVPKeyCtxPointer();
-#endif
-  if (EVP_PKEY_paramgen(param_ctx.get(), &raw_params) <= 0)
+  if (Thin_EVP_PKEY_paramgen(param_ctx.get(), &raw_params) <= 0)
     return EVPKeyCtxPointer();
 
   EVPKeyPointer key_params(raw_params);
-  EVPKeyCtxPointer key_ctx(EVP_PKEY_CTX_new(key_params.get(), nullptr));
+  EVPKeyCtxPointer key_ctx(Thin_EVP_PKEY_CTX_new(key_params.get(), nullptr));
 
-  if (!key_ctx || EVP_PKEY_keygen_init(key_ctx.get()) <= 0)
+  if (!key_ctx || Thin_EVP_PKEY_keygen_init(key_ctx.get()) <= 0)
     return EVPKeyCtxPointer();
 
   return key_ctx;
@@ -137,16 +133,16 @@ Maybe<bool> GetDsaKeyDetail(
 
   ManagedEVPPKey m_pkey = key->GetAsymmetricKey();
   Mutex::ScopedLock lock(*m_pkey.mutex());
-  int type = EVP_PKEY_id(m_pkey.get());
+  int type = Thin_EVP_PKEY_id(m_pkey.get());
   CHECK(type == EVP_PKEY_DSA);
 
-  const DSA* dsa = EVP_PKEY_get0_DSA(m_pkey.get());
+  const DSA* dsa = Thin_EVP_PKEY_get0_DSA(m_pkey.get());
   CHECK_NOT_NULL(dsa);
 
-  DSA_get0_pqg(dsa, &p, &q, nullptr);
+  Thin_DSA_get0_pqg(dsa, &p, &q, nullptr);
 
-  size_t modulus_length = BN_num_bits(p);
-  size_t divisor_length = BN_num_bits(q);
+  size_t modulus_length = Thin_BN_num_bits(p);
+  size_t divisor_length = Thin_BN_num_bits(q);
 
   if (target
           ->Set(
diff --git a/src/crypto/crypto_ec.cc b/src/crypto/crypto_ec.cc
index 860d5048db..ea7c17a3b5 100644
--- a/src/crypto/crypto_ec.cc
+++ b/src/crypto/crypto_ec.cc
@@ -10,9 +10,9 @@
 #include "threadpoolwork-inl.h"
 #include "v8.h"
 
-#include <openssl/bn.h>
-#include <openssl/ec.h>
-#include <openssl/ecdh.h>
+// #include <openssl/bn.h>
+// #include <openssl/ec.h>
+// #include <openssl/ecdh.h>
 
 #include <algorithm>
 
@@ -39,9 +39,9 @@ using v8::Value;
 namespace crypto {
 
 int GetCurveFromName(const char* name) {
-  int nid = EC_curve_nist2nid(name);
+  int nid = Thin_EC_curve_nist2nid(name);
   if (nid == NID_undef)
-    nid = OBJ_sn2nid(name);
+    nid = Thin_OBJ_sn2nid(name);
   return nid;
 }
 
@@ -107,13 +107,13 @@ void ECDH::RegisterExternalReferences(ExternalReferenceRegistry* registry) {
 
 void ECDH::GetCurves(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
-  const size_t num_curves = EC_get_builtin_curves(nullptr, 0);
+  const size_t num_curves = Thin_EC_get_builtin_curves(nullptr, 0);
   std::vector<EC_builtin_curve> curves(num_curves);
-  CHECK_EQ(EC_get_builtin_curves(curves.data(), num_curves), num_curves);
+  CHECK_EQ(Thin_EC_get_builtin_curves(curves.data(), num_curves), num_curves);
 
   std::vector<Local<Value>> arr(num_curves);
   std::transform(curves.begin(), curves.end(), arr.begin(), [env](auto& curve) {
-    return OneByteString(env->isolate(), OBJ_nid2sn(curve.nid));
+    return OneByteString(env->isolate(), Thin_OBJ_nid2sn(curve.nid));
   });
   args.GetReturnValue().Set(Array::New(env->isolate(), arr.data(), arr.size()));
 }
@@ -121,7 +121,7 @@ void ECDH::GetCurves(const FunctionCallbackInfo<Value>& args) {
 ECDH::ECDH(Environment* env, Local<Object> wrap, ECKeyPointer&& key)
     : BaseObject(env, wrap),
     key_(std::move(key)),
-    group_(EC_KEY_get0_group(key_.get())) {
+    group_(Thin_EC_KEY_get0_group(key_.get())) {
   MakeWeak();
   CHECK_NOT_NULL(group_);
 }
@@ -139,11 +139,11 @@ void ECDH::New(const FunctionCallbackInfo<Value>& args) {
   CHECK(args[0]->IsString());
   node::Utf8Value curve(env->isolate(), args[0]);
 
-  int nid = OBJ_sn2nid(*curve);
+  int nid = Thin_OBJ_sn2nid(*curve);
   if (nid == NID_undef)
     return THROW_ERR_CRYPTO_INVALID_CURVE(env);
 
-  ECKeyPointer key(EC_KEY_new_by_curve_name(nid));
+  ECKeyPointer key(Thin_EC_KEY_new_by_curve_name(nid));
   if (!key)
     return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
       "Failed to create key using named curve");
@@ -157,7 +157,7 @@ void ECDH::GenerateKeys(const FunctionCallbackInfo<Value>& args) {
   ECDH* ecdh;
   ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());
 
-  if (!EC_KEY_generate_key(ecdh->key_.get()))
+  if (!Thin_EC_KEY_generate_key(ecdh->key_.get()))
     return THROW_ERR_CRYPTO_OPERATION_FAILED(env, "Failed to generate key");
 }
 
@@ -166,7 +166,7 @@ ECPointPointer ECDH::BufferToPoint(Environment* env,
                                    Local<Value> buf) {
   int r;
 
-  ECPointPointer pub(EC_POINT_new(group));
+  ECPointPointer pub(Thin_EC_POINT_new(group));
   if (!pub) {
     THROW_ERR_CRYPTO_OPERATION_FAILED(env,
         "Failed to allocate EC_POINT for a public key");
@@ -178,7 +178,7 @@ ECPointPointer ECDH::BufferToPoint(Environment* env,
     THROW_ERR_OUT_OF_RANGE(env, "buffer is too big");
     return ECPointPointer();
   }
-  r = EC_POINT_oct2point(
+  r = Thin_EC_POINT_oct2point(
       group,
       pub.get(),
       input.data(),
@@ -218,12 +218,12 @@ void ECDH::ComputeSecret(const FunctionCallbackInfo<Value>& args) {
   {
     NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
     // NOTE: field_size is in bits
-    int field_size = EC_GROUP_get_degree(ecdh->group_);
+    int field_size = Thin_EC_GROUP_get_degree(ecdh->group_);
     size_t out_len = (field_size + 7) / 8;
     bs = ArrayBuffer::NewBackingStore(env->isolate(), out_len);
   }
 
-  if (!ECDH_compute_key(
+  if (!Thin_ECDH_compute_key(
           bs->Data(), bs->ByteLength(), pub.get(), ecdh->key_.get(), nullptr))
     return THROW_ERR_CRYPTO_OPERATION_FAILED(env, "Failed to compute ECDH key");
 
@@ -242,8 +242,8 @@ void ECDH::GetPublicKey(const FunctionCallbackInfo<Value>& args) {
   ECDH* ecdh;
   ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());
 
-  const EC_GROUP* group = EC_KEY_get0_group(ecdh->key_.get());
-  const EC_POINT* pub = EC_KEY_get0_public_key(ecdh->key_.get());
+  const EC_GROUP* group = Thin_EC_KEY_get0_group(ecdh->key_.get());
+  const EC_POINT* pub = Thin_EC_KEY_get0_public_key(ecdh->key_.get());
   if (pub == nullptr)
     return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
         "Failed to get ECDH public key");
@@ -265,7 +265,7 @@ void ECDH::GetPrivateKey(const FunctionCallbackInfo<Value>& args) {
   ECDH* ecdh;
   ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());
 
-  const BIGNUM* b = EC_KEY_get0_private_key(ecdh->key_.get());
+  const BIGNUM* b = Thin_EC_KEY_get0_private_key(ecdh->key_.get());
   if (b == nullptr)
     return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
         "Failed to get ECDH private key");
@@ -273,10 +273,10 @@ void ECDH::GetPrivateKey(const FunctionCallbackInfo<Value>& args) {
   std::unique_ptr<BackingStore> bs;
   {
     NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
-    bs = ArrayBuffer::NewBackingStore(env->isolate(), BN_num_bytes(b));
+    bs = ArrayBuffer::NewBackingStore(env->isolate(), Thin_BN_num_bytes(b));
   }
   CHECK_EQ(static_cast<int>(bs->ByteLength()),
-           BN_bn2binpad(
+           Thin_BN_bn2binpad(
                b, static_cast<unsigned char*>(bs->Data()), bs->ByteLength()));
 
   Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
@@ -295,7 +295,7 @@ void ECDH::SetPrivateKey(const FunctionCallbackInfo<Value>& args) {
   if (UNLIKELY(!priv_buffer.CheckSizeInt32()))
     return THROW_ERR_OUT_OF_RANGE(env, "key is too big");
 
-  BignumPointer priv(BN_bin2bn(
+  BignumPointer priv(Thin_BN_bin2bn(
       priv_buffer.data(), priv_buffer.size(), nullptr));
   if (!priv) {
     return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
@@ -307,10 +307,10 @@ void ECDH::SetPrivateKey(const FunctionCallbackInfo<Value>& args) {
         "Private key is not valid for specified curve.");
   }
 
-  ECKeyPointer new_key(EC_KEY_dup(ecdh->key_.get()));
+  ECKeyPointer new_key(Thin_EC_KEY_dup(ecdh->key_.get()));
   CHECK(new_key);
 
-  int result = EC_KEY_set_private_key(new_key.get(), priv.get());
+  int result = Thin_EC_KEY_set_private_key(new_key.get(), priv.get());
   priv.reset();
 
   if (!result) {
@@ -321,24 +321,24 @@ void ECDH::SetPrivateKey(const FunctionCallbackInfo<Value>& args) {
   MarkPopErrorOnReturn mark_pop_error_on_return;
   USE(&mark_pop_error_on_return);
 
-  const BIGNUM* priv_key = EC_KEY_get0_private_key(new_key.get());
+  const BIGNUM* priv_key = Thin_EC_KEY_get0_private_key(new_key.get());
   CHECK_NOT_NULL(priv_key);
 
-  ECPointPointer pub(EC_POINT_new(ecdh->group_));
+  ECPointPointer pub(Thin_EC_POINT_new(ecdh->group_));
   CHECK(pub);
 
-  if (!EC_POINT_mul(ecdh->group_, pub.get(), priv_key,
+  if (!Thin_EC_POINT_mul(ecdh->group_, pub.get(), priv_key,
                     nullptr, nullptr, nullptr)) {
     return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
         "Failed to generate ECDH public key");
   }
 
-  if (!EC_KEY_set_public_key(new_key.get(), pub.get()))
+  if (!Thin_EC_KEY_set_public_key(new_key.get(), pub.get()))
     return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
         "Failed to set generated public key");
 
   ecdh->key_ = std::move(new_key);
-  ecdh->group_ = EC_KEY_get0_group(ecdh->key_.get());
+  ecdh->group_ = Thin_EC_KEY_get0_group(ecdh->key_.get());
 }
 
 void ECDH::SetPublicKey(const FunctionCallbackInfo<Value>& args) {
@@ -360,7 +360,7 @@ void ECDH::SetPublicKey(const FunctionCallbackInfo<Value>& args) {
         "Failed to convert Buffer to EC_POINT");
   }
 
-  int r = EC_KEY_set_public_key(ecdh->key_.get(), pub.get());
+  int r = Thin_EC_KEY_set_public_key(ecdh->key_.get(), pub.get());
   if (!r) {
     return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
         "Failed to set EC_POINT as the public key");
@@ -372,19 +372,19 @@ bool ECDH::IsKeyValidForCurve(const BignumPointer& private_key) {
   CHECK(private_key);
   // Private keys must be in the range [1, n-1].
   // Ref: Section 3.2.1 - http://www.secg.org/sec1-v2.pdf
-  if (BN_cmp(private_key.get(), BN_value_one()) < 0) {
+  if (Thin_BN_cmp(private_key.get(), Thin_BN_value_one()) < 0) {
     return false;
   }
-  BignumPointer order(BN_new());
+  BignumPointer order(Thin_BN_new());
   CHECK(order);
-  return EC_GROUP_get_order(group_, order.get(), nullptr) &&
-         BN_cmp(private_key.get(), order.get()) < 0;
+  return Thin_EC_GROUP_get_order(group_, order.get(), nullptr) &&
+         Thin_BN_cmp(private_key.get(), order.get()) < 0;
 }
 
 bool ECDH::IsKeyPairValid() {
   MarkPopErrorOnReturn mark_pop_error_on_return;
   USE(&mark_pop_error_on_return);
-  return 1 == EC_KEY_check_key(key_.get());
+  return 1 == Thin_EC_KEY_check_key(key_.get());
 }
 
 // Convert the input public key to compressed, uncompressed, or hybrid formats.
@@ -403,12 +403,12 @@ void ECDH::ConvertKey(const FunctionCallbackInfo<Value>& args) {
 
   node::Utf8Value curve(env->isolate(), args[1]);
 
-  int nid = OBJ_sn2nid(*curve);
+  int nid = Thin_OBJ_sn2nid(*curve);
   if (nid == NID_undef)
     return THROW_ERR_CRYPTO_INVALID_CURVE(env);
 
   ECGroupPointer group(
-      EC_GROUP_new_by_curve_name(nid));
+      Thin_EC_GROUP_new_by_curve_name(nid));
   if (group == nullptr)
     return THROW_ERR_CRYPTO_OPERATION_FAILED(env, "Failed to get EC_GROUP");
 
@@ -492,20 +492,20 @@ bool ECDHBitsTraits::DeriveBits(Environment* env,
     case EVP_PKEY_X448: {
       EVPKeyCtxPointer ctx = nullptr;
       {
-        ctx.reset(EVP_PKEY_CTX_new(m_privkey.get(), nullptr));
+        ctx.reset(Thin_EVP_PKEY_CTX_new(m_privkey.get(), nullptr));
       }
       Mutex::ScopedLock pub_lock(*m_pubkey.mutex());
-      if (EVP_PKEY_derive_init(ctx.get()) <= 0 ||
-          EVP_PKEY_derive_set_peer(
+      if (Thin_EVP_PKEY_derive_init(ctx.get()) <= 0 ||
+          Thin_EVP_PKEY_derive_set_peer(
               ctx.get(),
               m_pubkey.get()) <= 0 ||
-          EVP_PKEY_derive(ctx.get(), nullptr, &len) <= 0) {
+          Thin_EVP_PKEY_derive(ctx.get(), nullptr, &len) <= 0) {
         return false;
       }
 
       ByteSource::Builder buf(len);
 
-      if (EVP_PKEY_derive(ctx.get(), buf.data<unsigned char>(), &len) <= 0) {
+      if (Thin_EVP_PKEY_derive(ctx.get(), buf.data<unsigned char>(), &len) <= 0) {
         return false;
       }
 
@@ -517,25 +517,25 @@ bool ECDHBitsTraits::DeriveBits(Environment* env,
       const EC_KEY* private_key;
       {
         Mutex::ScopedLock priv_lock(*m_privkey.mutex());
-        private_key = EVP_PKEY_get0_EC_KEY(m_privkey.get());
+        private_key = Thin_EVP_PKEY_get0_EC_KEY(m_privkey.get());
       }
 
       Mutex::ScopedLock pub_lock(*m_pubkey.mutex());
-      const EC_KEY* public_key = EVP_PKEY_get0_EC_KEY(m_pubkey.get());
+      const EC_KEY* public_key = Thin_EVP_PKEY_get0_EC_KEY(m_pubkey.get());
 
-      const EC_GROUP* group = EC_KEY_get0_group(private_key);
+      const EC_GROUP* group = Thin_EC_KEY_get0_group(private_key);
       if (group == nullptr)
         return false;
 
-      CHECK_EQ(EC_KEY_check_key(private_key), 1);
-      CHECK_EQ(EC_KEY_check_key(public_key), 1);
-      const EC_POINT* pub = EC_KEY_get0_public_key(public_key);
-      int field_size = EC_GROUP_get_degree(group);
+      CHECK_EQ(Thin_EC_KEY_check_key(private_key), 1);
+      CHECK_EQ(Thin_EC_KEY_check_key(public_key), 1);
+      const EC_POINT* pub = Thin_EC_KEY_get0_public_key(public_key);
+      int field_size = Thin_EC_GROUP_get_degree(group);
       len = (field_size + 7) / 8;
       ByteSource::Builder buf(len);
       CHECK_NOT_NULL(pub);
       CHECK_NOT_NULL(private_key);
-      if (ECDH_compute_key(buf.data<char>(), len, pub, private_key, nullptr) <=
+      if (Thin_ECDH_compute_key(buf.data<char>(), len, pub, private_key, nullptr) <=
           0) {
         return false;
       }
@@ -557,26 +557,26 @@ EVPKeyCtxPointer EcKeyGenTraits::Setup(EcKeyPairGenConfig* params) {
     case EVP_PKEY_X25519:
       // Fall through
     case EVP_PKEY_X448:
-      key_ctx.reset(EVP_PKEY_CTX_new_id(params->params.curve_nid, nullptr));
+      key_ctx.reset(Thin_EVP_PKEY_CTX_new_id(params->params.curve_nid, nullptr));
       break;
     default: {
-      EVPKeyCtxPointer param_ctx(EVP_PKEY_CTX_new_id(EVP_PKEY_EC, nullptr));
+      EVPKeyCtxPointer param_ctx(Thin_EVP_PKEY_CTX_new_id(EVP_PKEY_EC, nullptr));
       EVP_PKEY* raw_params = nullptr;
       if (!param_ctx ||
-          EVP_PKEY_paramgen_init(param_ctx.get()) <= 0 ||
-          EVP_PKEY_CTX_set_ec_paramgen_curve_nid(
+          Thin_EVP_PKEY_paramgen_init(param_ctx.get()) <= 0 ||
+          Thin_EVP_PKEY_CTX_set_ec_paramgen_curve_nid(
               param_ctx.get(), params->params.curve_nid) <= 0 ||
-          EVP_PKEY_CTX_set_ec_param_enc(
+          Thin_EVP_PKEY_CTX_set_ec_param_enc(
               param_ctx.get(), params->params.param_encoding) <= 0 ||
-          EVP_PKEY_paramgen(param_ctx.get(), &raw_params) <= 0) {
+          Thin_EVP_PKEY_paramgen(param_ctx.get(), &raw_params) <= 0) {
         return EVPKeyCtxPointer();
       }
       EVPKeyPointer key_params(raw_params);
-      key_ctx.reset(EVP_PKEY_CTX_new(key_params.get(), nullptr));
+      key_ctx.reset(Thin_EVP_PKEY_CTX_new(key_params.get(), nullptr));
     }
   }
 
-  if (key_ctx && EVP_PKEY_keygen_init(key_ctx.get()) <= 0)
+  if (key_ctx && Thin_EVP_PKEY_keygen_init(key_ctx.get()) <= 0)
     key_ctx.reset();
 
   return key_ctx;
@@ -629,7 +629,7 @@ WebCryptoKeyExportStatus EC_Raw_Export(
   CHECK(m_pkey);
   Mutex::ScopedLock lock(*m_pkey.mutex());
 
-  const EC_KEY* ec_key = EVP_PKEY_get0_EC_KEY(m_pkey.get());
+  const EC_KEY* ec_key = Thin_EVP_PKEY_get0_EC_KEY(m_pkey.get());
 
   size_t len = 0;
 
@@ -638,10 +638,10 @@ WebCryptoKeyExportStatus EC_Raw_Export(
     export_fn fn = nullptr;
     switch (key_data->GetKeyType()) {
       case kKeyTypePrivate:
-        fn = EVP_PKEY_get_raw_private_key;
+        fn = Thin_EVP_PKEY_get_raw_private_key;
         break;
       case kKeyTypePublic:
-        fn = EVP_PKEY_get_raw_public_key;
+        fn = Thin_EVP_PKEY_get_raw_public_key;
         break;
       case kKeyTypeSecret:
         UNREACHABLE();
@@ -657,16 +657,16 @@ WebCryptoKeyExportStatus EC_Raw_Export(
   } else {
     if (key_data->GetKeyType() != kKeyTypePublic)
       return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
-    const EC_GROUP* group = EC_KEY_get0_group(ec_key);
-    const EC_POINT* point = EC_KEY_get0_public_key(ec_key);
+    const EC_GROUP* group = Thin_EC_KEY_get0_group(ec_key);
+    const EC_POINT* point = Thin_EC_KEY_get0_public_key(ec_key);
     point_conversion_form_t form = POINT_CONVERSION_UNCOMPRESSED;
 
     // Get the allocated data size...
-    len = EC_POINT_point2oct(group, point, form, nullptr, 0, nullptr);
+    len = Thin_EC_POINT_point2oct(group, point, form, nullptr, 0, nullptr);
     if (len == 0)
       return WebCryptoKeyExportStatus::FAILED;
     ByteSource::Builder data(len);
-    size_t check_len = EC_POINT_point2oct(
+    size_t check_len = Thin_EC_POINT_point2oct(
         group, point, form, data.data<unsigned char>(), len, nullptr);
     if (check_len == 0)
       return WebCryptoKeyExportStatus::FAILED;
@@ -705,41 +705,41 @@ WebCryptoKeyExportStatus ECKeyExportTraits::DoExport(
         return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
 
       ManagedEVPPKey m_pkey = key_data->GetAsymmetricKey();
-      if (EVP_PKEY_id(m_pkey.get()) != EVP_PKEY_EC) {
+      if (Thin_EVP_PKEY_id(m_pkey.get()) != EVP_PKEY_EC) {
         return PKEY_SPKI_Export(key_data.get(), out);
       } else {
         // Ensure exported key is in uncompressed point format.
-        // The temporary EC key is so we can have i2d_PUBKEY_bio() write out
+        // The temporary EC key is so we can have Thin_i2d_PUBKEY_bio() write out
         // the header but it is a somewhat silly hoop to jump through because
         // the header is for all practical purposes a static 26 byte sequence
         // where only the second byte changes.
         Mutex::ScopedLock lock(*m_pkey.mutex());
-        const EC_KEY* ec_key = EVP_PKEY_get0_EC_KEY(m_pkey.get());
-        const EC_GROUP* group = EC_KEY_get0_group(ec_key);
-        const EC_POINT* point = EC_KEY_get0_public_key(ec_key);
+        const EC_KEY* ec_key = Thin_EVP_PKEY_get0_EC_KEY(m_pkey.get());
+        const EC_GROUP* group = Thin_EC_KEY_get0_group(ec_key);
+        const EC_POINT* point = Thin_EC_KEY_get0_public_key(ec_key);
         const point_conversion_form_t form = POINT_CONVERSION_UNCOMPRESSED;
         const size_t need =
-            EC_POINT_point2oct(group, point, form, nullptr, 0, nullptr);
+            Thin_EC_POINT_point2oct(group, point, form, nullptr, 0, nullptr);
         if (need == 0) return WebCryptoKeyExportStatus::FAILED;
         ByteSource::Builder data(need);
-        const size_t have = EC_POINT_point2oct(
+        const size_t have = Thin_EC_POINT_point2oct(
             group, point, form, data.data<unsigned char>(), need, nullptr);
         if (have == 0) return WebCryptoKeyExportStatus::FAILED;
         ECKeyPointer ec(EC_KEY_new());
         CHECK_EQ(1, EC_KEY_set_group(ec.get(), group));
-        ECPointPointer uncompressed(EC_POINT_new(group));
+        ECPointPointer uncompressed(Thin_EC_POINT_new(group));
         CHECK_EQ(1,
-                 EC_POINT_oct2point(group,
+                 Thin_EC_POINT_oct2point(group,
                                     uncompressed.get(),
                                     data.data<unsigned char>(),
                                     data.size(),
                                     nullptr));
-        CHECK_EQ(1, EC_KEY_set_public_key(ec.get(), uncompressed.get()));
-        EVPKeyPointer pkey(EVP_PKEY_new());
-        CHECK_EQ(1, EVP_PKEY_set1_EC_KEY(pkey.get(), ec.get()));
-        BIOPointer bio(BIO_new(BIO_s_mem()));
+        CHECK_EQ(1, Thin_EC_KEY_set_public_key(ec.get(), uncompressed.get()));
+        EVPKeyPointer pkey(Thin_EVP_PKEY_new());
+        CHECK_EQ(1, Thin_EVP_PKEY_set1_EC_KEY(pkey.get(), ec.get()));
+        BIOPointer bio(Thin_BIO_new(Thin_BIO_s_mem()));
         CHECK(bio);
-        if (!i2d_PUBKEY_bio(bio.get(), pkey.get()))
+        if (!Thin_i2d_PUBKEY_bio(bio.get(), pkey.get()))
           return WebCryptoKeyExportStatus::FAILED;
         *out = ByteSource::FromBIO(bio);
         return WebCryptoKeyExportStatus::OK;
@@ -756,23 +756,23 @@ Maybe<void> ExportJWKEcKey(
     Local<Object> target) {
   ManagedEVPPKey m_pkey = key->GetAsymmetricKey();
   Mutex::ScopedLock lock(*m_pkey.mutex());
-  CHECK_EQ(EVP_PKEY_id(m_pkey.get()), EVP_PKEY_EC);
+  CHECK_EQ(Thin_EVP_PKEY_id(m_pkey.get()), EVP_PKEY_EC);
 
-  const EC_KEY* ec = EVP_PKEY_get0_EC_KEY(m_pkey.get());
+  const EC_KEY* ec = Thin_EVP_PKEY_get0_EC_KEY(m_pkey.get());
   CHECK_NOT_NULL(ec);
 
-  const EC_POINT* pub = EC_KEY_get0_public_key(ec);
-  const EC_GROUP* group = EC_KEY_get0_group(ec);
+  const EC_POINT* pub = Thin_EC_KEY_get0_public_key(ec);
+  const EC_GROUP* group = Thin_EC_KEY_get0_group(ec);
 
-  int degree_bits = EC_GROUP_get_degree(group);
+  int degree_bits = Thin_EC_GROUP_get_degree(group);
   int degree_bytes =
     (degree_bits / CHAR_BIT) + (7 + (degree_bits % CHAR_BIT)) / 8;
 
-  BignumPointer x(BN_new());
-  BignumPointer y(BN_new());
+  BignumPointer x(Thin_BN_new());
+  BignumPointer y(Thin_BN_new());
 
-  if (!EC_POINT_get_affine_coordinates(group, pub, x.get(), y.get(), nullptr)) {
-    ThrowCryptoError(env, ERR_get_error(),
+  if (!Thin_EC_POINT_get_affine_coordinates(group, pub, x.get(), y.get(), nullptr)) {
+    ThrowCryptoError(env, Thin_ERR_get_error(),
                      "Failed to get elliptic-curve point coordinates");
     return Nothing<void>();
   }
@@ -800,7 +800,7 @@ Maybe<void> ExportJWKEcKey(
   }
 
   Local<String> crv_name;
-  const int nid = EC_GROUP_get_curve_name(group);
+  const int nid = Thin_EC_GROUP_get_curve_name(group);
   switch (nid) {
     case NID_X9_62_prime256v1:
       crv_name = OneByteString(env->isolate(), "P-256");
@@ -816,7 +816,7 @@ Maybe<void> ExportJWKEcKey(
       break;
     default: {
       THROW_ERR_CRYPTO_JWK_UNSUPPORTED_CURVE(
-          env, "Unsupported JWK EC curve: %s.", OBJ_nid2sn(nid));
+          env, "Unsupported JWK EC curve: %s.", Thin_OBJ_nid2sn(nid));
       return Nothing<void>();
     }
   }
@@ -828,7 +828,7 @@ Maybe<void> ExportJWKEcKey(
   }
 
   if (key->GetKeyType() == kKeyTypePrivate) {
-    const BIGNUM* pvt = EC_KEY_get0_private_key(ec);
+    const BIGNUM* pvt = Thin_EC_KEY_get0_private_key(ec);
     return SetEncodedValue(
       env,
       target,
@@ -848,7 +848,7 @@ Maybe<bool> ExportJWKEdKey(
   Mutex::ScopedLock lock(*pkey.mutex());
 
   const char* curve = nullptr;
-  switch (EVP_PKEY_id(pkey.get())) {
+  switch (Thin_EVP_PKEY_id(pkey.get())) {
     case EVP_PKEY_ED25519:
       curve = "Ed25519";
       break;
@@ -875,13 +875,13 @@ Maybe<bool> ExportJWKEdKey(
   Local<Value> encoded;
   Local<Value> error;
 
-  if (!EVP_PKEY_get_raw_public_key(pkey.get(), nullptr, &len))
+  if (!Thin_EVP_PKEY_get_raw_public_key(pkey.get(), nullptr, &len))
     return Nothing<bool>();
 
   ByteSource::Builder out(len);
 
   if (key->GetKeyType() == kKeyTypePrivate) {
-    if (!EVP_PKEY_get_raw_private_key(
+    if (!Thin_EVP_PKEY_get_raw_private_key(
             pkey.get(), out.data<unsigned char>(), &len) ||
         !StringBytes::Encode(
              env->isolate(), out.data<const char>(), len, BASE64URL, &error)
@@ -893,7 +893,7 @@ Maybe<bool> ExportJWKEdKey(
     }
   }
 
-  if (!EVP_PKEY_get_raw_public_key(
+  if (!Thin_EVP_PKEY_get_raw_public_key(
           pkey.get(), out.data<unsigned char>(), &len) ||
       !StringBytes::Encode(
            env->isolate(), out.data<const char>(), len, BASE64URL, &error)
@@ -947,7 +947,7 @@ std::shared_ptr<KeyObjectData> ImportJWKEcKey(
 
   KeyType type = d_value->IsString() ? kKeyTypePrivate : kKeyTypePublic;
 
-  ECKeyPointer ec(EC_KEY_new_by_curve_name(nid));
+  ECKeyPointer ec(Thin_EC_KEY_new_by_curve_name(nid));
   if (!ec) {
     THROW_ERR_CRYPTO_INVALID_JWK(env, "Invalid JWK EC key");
     return std::shared_ptr<KeyObjectData>();
@@ -956,7 +956,7 @@ std::shared_ptr<KeyObjectData> ImportJWKEcKey(
   ByteSource x = ByteSource::FromEncodedString(env, x_value.As<String>());
   ByteSource y = ByteSource::FromEncodedString(env, y_value.As<String>());
 
-  if (!EC_KEY_set_public_key_affine_coordinates(
+  if (!Thin_EC_KEY_set_public_key_affine_coordinates(
           ec.get(),
           x.ToBN().get(),
           y.ToBN().get())) {
@@ -966,14 +966,14 @@ std::shared_ptr<KeyObjectData> ImportJWKEcKey(
 
   if (type == kKeyTypePrivate) {
     ByteSource d = ByteSource::FromEncodedString(env, d_value.As<String>());
-    if (!EC_KEY_set_private_key(ec.get(), d.ToBN().get())) {
+    if (!Thin_EC_KEY_set_private_key(ec.get(), d.ToBN().get())) {
       THROW_ERR_CRYPTO_INVALID_JWK(env, "Invalid JWK EC key");
       return std::shared_ptr<KeyObjectData>();
     }
   }
 
-  EVPKeyPointer pkey(EVP_PKEY_new());
-  CHECK_EQ(EVP_PKEY_set1_EC_KEY(pkey.get(), ec.get()), 1);
+  EVPKeyPointer pkey(Thin_EVP_PKEY_new());
+  CHECK_EQ(Thin_EVP_PKEY_set1_EC_KEY(pkey.get(), ec.get()), 1);
 
   return KeyObjectData::CreateAsymmetric(type, ManagedEVPPKey(std::move(pkey)));
 }
@@ -984,18 +984,18 @@ Maybe<bool> GetEcKeyDetail(
     Local<Object> target) {
   ManagedEVPPKey m_pkey = key->GetAsymmetricKey();
   Mutex::ScopedLock lock(*m_pkey.mutex());
-  CHECK_EQ(EVP_PKEY_id(m_pkey.get()), EVP_PKEY_EC);
+  CHECK_EQ(Thin_EVP_PKEY_id(m_pkey.get()), EVP_PKEY_EC);
 
-  const EC_KEY* ec = EVP_PKEY_get0_EC_KEY(m_pkey.get());
+  const EC_KEY* ec = Thin_EVP_PKEY_get0_EC_KEY(m_pkey.get());
   CHECK_NOT_NULL(ec);
 
-  const EC_GROUP* group = EC_KEY_get0_group(ec);
-  int nid = EC_GROUP_get_curve_name(group);
+  const EC_GROUP* group = Thin_EC_KEY_get0_group(ec);
+  int nid = Thin_EC_GROUP_get_curve_name(group);
 
   return target->Set(
       env->context(),
       env->named_curve_string(),
-      OneByteString(env->isolate(), OBJ_nid2sn(nid)));
+      OneByteString(env->isolate(), Thin_OBJ_nid2sn(nid)));
 }
 
 // WebCrypto requires a different format for ECDSA signatures than
@@ -1004,12 +1004,12 @@ Maybe<bool> GetEcKeyDetail(
 // https://github.com/chromium/chromium/blob/7af6cfd/components/webcrypto/algorithms/ecdsa.cc
 
 size_t GroupOrderSize(const ManagedEVPPKey& key) {
-  const EC_KEY* ec = EVP_PKEY_get0_EC_KEY(key.get());
+  const EC_KEY* ec = Thin_EVP_PKEY_get0_EC_KEY(key.get());
   CHECK_NOT_NULL(ec);
-  const EC_GROUP* group = EC_KEY_get0_group(ec);
-  BignumPointer order(BN_new());
-  CHECK(EC_GROUP_get_order(group, order.get(), nullptr));
-  return BN_num_bytes(order.get());
+  const EC_GROUP* group = Thin_EC_KEY_get0_group(ec);
+  BignumPointer order(Thin_BN_new());
+  CHECK(Thin_EC_GROUP_get_order(group, order.get(), nullptr));
+  return Thin_BN_num_bytes(order.get());
 }
 }  // namespace crypto
 }  // namespace node
diff --git a/src/crypto/crypto_hash.cc b/src/crypto/crypto_hash.cc
index 46086018b6..b092a0b52d 100644
--- a/src/crypto/crypto_hash.cc
+++ b/src/crypto/crypto_hash.cc
@@ -36,7 +36,7 @@ void Hash::MemoryInfo(MemoryTracker* tracker) const {
   tracker->TrackFieldWithSize("md", digest_ ? md_len_ : 0);
 }
 
-#if OPENSSL_VERSION_MAJOR >= 3
+#if OPENSSL_VERSION_MAJOR >= 30
 void PushAliases(const char* name, void* data) {
   static_cast<std::vector<std::string>*>(data)->push_back(name);
 }
@@ -55,10 +55,10 @@ struct MaybeCachedMD {
 };
 
 MaybeCachedMD FetchAndMaybeCacheMD(Environment* env, const char* search_name) {
-  const EVP_MD* implicit_md = EVP_get_digestbyname(search_name);
+  const EVP_MD* implicit_md = Thin_EVP_get_digestbyname(search_name);
   if (!implicit_md) return {nullptr, nullptr, -1};
 
-  const char* real_name = EVP_MD_get0_name(implicit_md);
+  const char* real_name = Thin_EVP_MD_get0_name(implicit_md);
   if (!real_name) return {nullptr, implicit_md, -1};
 
   auto it = env->alias_to_md_id_map.find(real_name);
@@ -73,7 +73,7 @@ MaybeCachedMD FetchAndMaybeCacheMD(Environment* env, const char* search_name) {
   // instance if the algorithm is supported by the public OpenSSL APIs (some
   // algorithms are used internally by OpenSSL and are also passed to this
   // callback).
-  EVP_MD* explicit_md = EVP_MD_fetch(nullptr, real_name, nullptr);
+  EVP_MD* explicit_md = Thin_EVP_MD_fetch(nullptr, real_name, nullptr);
   if (!explicit_md) return {nullptr, implicit_md, -1};
 
   // Cache the EVP_MD* fetched.
@@ -82,7 +82,7 @@ MaybeCachedMD FetchAndMaybeCacheMD(Environment* env, const char* search_name) {
 
   // Add all the aliases to the map to speed up next lookup.
   std::vector<std::string> aliases;
-  EVP_MD_names_do_all(explicit_md, PushAliases, &aliases);
+  Thin_EVP_MD_names_do_all(explicit_md, PushAliases, &aliases);
   for (const auto& alias : aliases) {
     env->alias_to_md_id_map.emplace(alias, id);
   }
@@ -117,12 +117,12 @@ void SaveSupportedHashAlgorithms(const EVP_MD* md,
 const std::vector<std::string>& GetSupportedHashAlgorithms(Environment* env) {
   if (env->supported_hash_algorithms.empty()) {
     MarkPopErrorOnReturn mark_pop_error_on_return;
-#if OPENSSL_VERSION_MAJOR >= 3
+#if OPENSSL_VERSION_MAJOR >= 30
     // Since we'll fetch the EVP_MD*, cache them along the way to speed up
     // later lookups instead of throwing them away immediately.
-    EVP_MD_do_all_sorted(SaveSupportedHashAlgorithmsAndCacheMD, env);
+    Thin_EVP_MD_do_all_sorted(SaveSupportedHashAlgorithmsAndCacheMD, env);
 #else
-    EVP_MD_do_all_sorted(SaveSupportedHashAlgorithms, env);
+    Thin_EVP_MD_do_all_sorted(SaveSupportedHashAlgorithms, env);
 #endif
   }
   return env->supported_hash_algorithms;
@@ -170,7 +170,7 @@ const EVP_MD* GetDigestImplementation(Environment* env,
   CHECK(cache_id_val->IsInt32());
   CHECK(algorithm_cache->IsObject());
 
-#if OPENSSL_VERSION_MAJOR >= 3
+#if OPENSSL_VERSION_MAJOR >= 30
   int32_t cache_id = cache_id_val.As<Int32>()->Value();
   if (cache_id != -1) {  // Alias already cached, return the cached EVP_MD*.
     return GetCachedMDByID(env, cache_id);
@@ -198,7 +198,7 @@ const EVP_MD* GetDigestImplementation(Environment* env,
   return result.explicit_md ? result.explicit_md : result.implicit_md;
 #else
   Utf8Value utf8(env->isolate(), algorithm);
-  return EVP_get_digestbyname(*utf8);
+  return Thin_EVP_get_digestbyname(*utf8);
 #endif
 }
 
@@ -220,24 +220,24 @@ void Hash::OneShotDigest(const FunctionCallbackInfo<Value>& args) {
     Utf8Value method(isolate, args[0]);
     std::string message =
         "Digest method " + method.ToString() + " is not supported";
-    return ThrowCryptoError(env, ERR_get_error(), message.c_str());
+    return ThrowCryptoError(env, Thin_ERR_get_error(), message.c_str());
   }
 
   enum encoding output_enc = ParseEncoding(isolate, args[4], args[5], HEX);
 
-  int md_len = EVP_MD_size(md);
+  int md_len = Thin_EVP_MD_size(md);
   unsigned int result_size;
   ByteSource::Builder output(md_len);
   int success;
-  // On smaller inputs, EVP_Digest() can be slower than the
+  // On smaller inputs, Thin_EVP_Digest() can be slower than the
   // deprecated helpers e.g SHA256_XXX. The speedup may not
   // be worth using deprecated APIs, however, so we use
-  // EVP_Digest(), unless there's a better alternative
+  // Thin_EVP_Digest(), unless there's a better alternative
   // in the future.
   // https://github.com/openssl/openssl/issues/19612
   if (args[3]->IsString()) {
     Utf8Value utf8(isolate, args[3]);
-    success = EVP_Digest(utf8.out(),
+    success = Thin_EVP_Digest(utf8.out(),
                          utf8.length(),
                          output.data<unsigned char>(),
                          &result_size,
@@ -245,7 +245,7 @@ void Hash::OneShotDigest(const FunctionCallbackInfo<Value>& args) {
                          nullptr);
   } else {
     ArrayBufferViewContents<unsigned char> input(args[3]);
-    success = EVP_Digest(input.data(),
+    success = Thin_EVP_Digest(input.data(),
                          input.length(),
                          output.data<unsigned char>(),
                          &result_size,
@@ -253,7 +253,7 @@ void Hash::OneShotDigest(const FunctionCallbackInfo<Value>& args) {
                          nullptr);
   }
   if (!success) {
-    return ThrowCryptoError(env, ERR_get_error());
+    return ThrowCryptoError(env, Thin_ERR_get_error());
   }
 
   Local<Value> error;
@@ -310,7 +310,7 @@ void Hash::New(const FunctionCallbackInfo<Value>& args) {
   const EVP_MD* md = nullptr;
   if (args[0]->IsObject()) {
     ASSIGN_OR_RETURN_UNWRAP(&orig, args[0].As<Object>());
-    md = EVP_MD_CTX_md(orig->mdctx_.get());
+    md = Thin_EVP_MD_CTX_md(orig->mdctx_.get());
   } else {
     md = GetDigestImplementation(env, args[0], args[2], args[3]);
   }
@@ -323,29 +323,29 @@ void Hash::New(const FunctionCallbackInfo<Value>& args) {
 
   Hash* hash = new Hash(env, args.This());
   if (md == nullptr || !hash->HashInit(md, xof_md_len)) {
-    return ThrowCryptoError(env, ERR_get_error(),
+    return ThrowCryptoError(env, Thin_ERR_get_error(),
                             "Digest method not supported");
   }
 
   if (orig != nullptr &&
-      0 >= EVP_MD_CTX_copy(hash->mdctx_.get(), orig->mdctx_.get())) {
-    return ThrowCryptoError(env, ERR_get_error(), "Digest copy error");
+      0 >= Thin_EVP_MD_CTX_copy(hash->mdctx_.get(), orig->mdctx_.get())) {
+    return ThrowCryptoError(env, Thin_ERR_get_error(), "Digest copy error");
   }
 }
 
 bool Hash::HashInit(const EVP_MD* md, Maybe<unsigned int> xof_md_len) {
-  mdctx_.reset(EVP_MD_CTX_new());
-  if (!mdctx_ || EVP_DigestInit_ex(mdctx_.get(), md, nullptr) <= 0) {
+  mdctx_.reset(Thin_EVP_MD_CTX_new());
+  if (!mdctx_ || Thin_EVP_DigestInit_ex(mdctx_.get(), md, nullptr) <= 0) {
     mdctx_.reset();
     return false;
   }
 
-  md_len_ = EVP_MD_size(md);
+  md_len_ = Thin_EVP_MD_size(md);
   if (xof_md_len.IsJust() && xof_md_len.FromJust() != md_len_) {
     // This is a little hack to cause createHash to fail when an incorrect
     // hashSize option was passed for a non-XOF hash function.
-    if ((EVP_MD_flags(md) & EVP_MD_FLAG_XOF) == 0) {
-      EVPerr(EVP_F_EVP_DIGESTFINALXOF, EVP_R_NOT_XOF_OR_INVALID_LENGTH);
+    if ((Thin_EVP_MD_flags(md) & EVP_MD_FLAG_XOF) == 0) {
+      Thin_EVPerr(EVP_F_EVP_DIGESTFINALXOF, EVP_R_NOT_XOF_OR_INVALID_LENGTH);
       return false;
     }
     md_len_ = xof_md_len.FromJust();
@@ -357,7 +357,7 @@ bool Hash::HashInit(const EVP_MD* md, Maybe<unsigned int> xof_md_len) {
 bool Hash::HashUpdate(const char* data, size_t len) {
   if (!mdctx_)
     return false;
-  return EVP_DigestUpdate(mdctx_.get(), data, len) == 1;
+  return Thin_EVP_DigestUpdate(mdctx_.get(), data, len) == 1;
 }
 
 void Hash::HashUpdate(const FunctionCallbackInfo<Value>& args) {
@@ -394,27 +394,27 @@ void Hash::HashDigest(const FunctionCallbackInfo<Value>& args) {
 
   if (!hash->digest_ && len > 0) {
     // Some hash algorithms such as SHA3 do not support calling
-    // EVP_DigestFinal_ex more than once, however, Hash._flush
+    // Thin_EVP_DigestFinal_ex more than once, however, Hash._flush
     // and Hash.digest can both be used to retrieve the digest,
     // so we need to cache it.
     // See https://github.com/nodejs/node/issues/28245.
 
     ByteSource::Builder digest(len);
 
-    size_t default_len = EVP_MD_CTX_size(hash->mdctx_.get());
+    size_t default_len = Thin_EVP_MD_CTX_size(hash->mdctx_.get());
     int ret;
     if (len == default_len) {
-      ret = EVP_DigestFinal_ex(
+      ret = Thin_EVP_DigestFinal_ex(
           hash->mdctx_.get(), digest.data<unsigned char>(), &len);
       // The output length should always equal hash->md_len_
       CHECK_EQ(len, hash->md_len_);
     } else {
-      ret = EVP_DigestFinalXOF(
+      ret = Thin_EVP_DigestFinalXOF(
           hash->mdctx_.get(), digest.data<unsigned char>(), len);
     }
 
     if (ret != 1)
-      return ThrowCryptoError(env, ERR_get_error());
+      return ThrowCryptoError(env, Thin_ERR_get_error());
 
     hash->digest_ = std::move(digest).release();
   }
@@ -468,7 +468,7 @@ Maybe<bool> HashTraits::AdditionalConfig(
 
   CHECK(args[offset]->IsString());  // Hash algorithm
   Utf8Value digest(env->isolate(), args[offset]);
-  params->digest = EVP_get_digestbyname(*digest);
+  params->digest = Thin_EVP_get_digestbyname(*digest);
   if (UNLIKELY(params->digest == nullptr)) {
     THROW_ERR_CRYPTO_INVALID_DIGEST(env, "Invalid digest: %s", *digest);
     return Nothing<bool>();
@@ -483,7 +483,7 @@ Maybe<bool> HashTraits::AdditionalConfig(
       ? data.ToCopy()
       : data.ToByteSource();
 
-  unsigned int expected = EVP_MD_size(params->digest);
+  unsigned int expected = Thin_EVP_MD_size(params->digest);
   params->length = expected;
   if (UNLIKELY(args[offset + 2]->IsUint32())) {
     // length is expressed in terms of bits
@@ -491,7 +491,7 @@ Maybe<bool> HashTraits::AdditionalConfig(
         static_cast<uint32_t>(args[offset + 2]
             .As<Uint32>()->Value()) / CHAR_BIT;
     if (params->length != expected) {
-      if ((EVP_MD_flags(params->digest) & EVP_MD_FLAG_XOF) == 0) {
+      if ((Thin_EVP_MD_flags(params->digest) & EVP_MD_FLAG_XOF) == 0) {
         THROW_ERR_CRYPTO_INVALID_DIGEST(env, "Digest method not supported");
         return Nothing<bool>();
       }
@@ -505,11 +505,11 @@ bool HashTraits::DeriveBits(
     Environment* env,
     const HashConfig& params,
     ByteSource* out) {
-  EVPMDCtxPointer ctx(EVP_MD_CTX_new());
+  EVPMDCtxPointer ctx(Thin_EVP_MD_CTX_new());
 
   if (UNLIKELY(!ctx ||
-               EVP_DigestInit_ex(ctx.get(), params.digest, nullptr) <= 0 ||
-               EVP_DigestUpdate(
+               Thin_EVP_DigestInit_ex(ctx.get(), params.digest, nullptr) <= 0 ||
+               Thin_EVP_DigestUpdate(
                    ctx.get(), params.in.data<char>(), params.in.size()) <= 0)) {
     return false;
   }
@@ -518,12 +518,12 @@ bool HashTraits::DeriveBits(
     unsigned int length = params.length;
     ByteSource::Builder buf(length);
 
-    size_t expected = EVP_MD_CTX_size(ctx.get());
+    size_t expected = Thin_EVP_MD_CTX_size(ctx.get());
 
     int ret =
         (length == expected)
-            ? EVP_DigestFinal_ex(ctx.get(), buf.data<unsigned char>(), &length)
-            : EVP_DigestFinalXOF(ctx.get(), buf.data<unsigned char>(), length);
+            ? Thin_EVP_DigestFinal_ex(ctx.get(), buf.data<unsigned char>(), &length)
+            : Thin_EVP_DigestFinalXOF(ctx.get(), buf.data<unsigned char>(), length);
 
     if (UNLIKELY(ret != 1))
       return false;
@@ -548,21 +548,21 @@ void InternalVerifyIntegrity(const v8::FunctionCallbackInfo<v8::Value>& args) {
   CHECK(args[2]->IsArrayBufferView());
   ArrayBufferOrViewContents<unsigned char> expected(args[2]);
 
-  const EVP_MD* md_type = EVP_get_digestbyname(*algorithm);
+  const EVP_MD* md_type = Thin_EVP_get_digestbyname(*algorithm);
   unsigned char digest[EVP_MAX_MD_SIZE];
   unsigned int digest_size;
-  if (md_type == nullptr || EVP_Digest(content.data(),
+  if (md_type == nullptr || Thin_EVP_Digest(content.data(),
                                        content.size(),
                                        digest,
                                        &digest_size,
                                        md_type,
                                        nullptr) != 1) {
     return ThrowCryptoError(
-        env, ERR_get_error(), "Digest method not supported");
+        env, Thin_ERR_get_error(), "Digest method not supported");
   }
 
   if (digest_size != expected.size() ||
-      CRYPTO_memcmp(digest, expected.data(), digest_size) != 0) {
+      Thin_CRYPTO_memcmp(digest, expected.data(), digest_size) != 0) {
     Local<Value> error;
     MaybeLocal<Value> rc =
         StringBytes::Encode(env->isolate(),
diff --git a/src/crypto/crypto_hkdf.cc b/src/crypto/crypto_hkdf.cc
index 0dd9b42473..290f2315d4 100644
--- a/src/crypto/crypto_hkdf.cc
+++ b/src/crypto/crypto_hkdf.cc
@@ -56,7 +56,7 @@ Maybe<bool> HKDFTraits::AdditionalConfig(
   CHECK(args[offset + 4]->IsUint32());  // Length
 
   Utf8Value hash(env->isolate(), args[offset]);
-  params->digest = EVP_get_digestbyname(*hash);
+  params->digest = Thin_EVP_get_digestbyname(*hash);
   if (params->digest == nullptr) {
     THROW_ERR_CRYPTO_INVALID_DIGEST(env, "Invalid digest: %s", *hash);
     return Nothing<bool>();
@@ -91,7 +91,7 @@ Maybe<bool> HKDFTraits::AdditionalConfig(
   // output of the hash function. 255 is a hard limit because HKDF appends an
   // 8-bit counter to each HMAC'd message, starting at 1.
   constexpr size_t kMaxDigestMultiplier = 255;
-  size_t max_length = EVP_MD_size(params->digest) * kMaxDigestMultiplier;
+  size_t max_length = Thin_EVP_MD_size(params->digest) * kMaxDigestMultiplier;
   if (params->length > max_length) {
     THROW_ERR_CRYPTO_INVALID_KEYLEN(env);
     return Nothing<bool>();
@@ -105,10 +105,10 @@ bool HKDFTraits::DeriveBits(
     const HKDFConfig& params,
     ByteSource* out) {
   EVPKeyCtxPointer ctx =
-      EVPKeyCtxPointer(EVP_PKEY_CTX_new_id(EVP_PKEY_HKDF, nullptr));
-  if (!ctx || !EVP_PKEY_derive_init(ctx.get()) ||
-      !EVP_PKEY_CTX_set_hkdf_md(ctx.get(), params.digest) ||
-      !EVP_PKEY_CTX_add1_hkdf_info(
+      EVPKeyCtxPointer(Thin_EVP_PKEY_CTX_new_id(EVP_PKEY_HKDF, nullptr));
+  if (!ctx || !Thin_EVP_PKEY_derive_init(ctx.get()) ||
+      !Thin_EVP_PKEY_CTX_set_hkdf_md(ctx.get(), params.digest) ||
+      !Thin_EVP_PKEY_CTX_add1_hkdf_info(
           ctx.get(), params.info.data<unsigned char>(), params.info.size())) {
     return false;
   }
@@ -122,11 +122,11 @@ bool HKDFTraits::DeriveBits(
     salt = {params.salt.data<char>(), params.salt.size()};
   } else {
     static const char default_salt[EVP_MAX_MD_SIZE] = {0};
-    salt = {default_salt, static_cast<unsigned>(EVP_MD_size(params.digest))};
+    salt = {default_salt, static_cast<unsigned>(Thin_EVP_MD_size(params.digest))};
   }
 
   // We do not use EVP_PKEY_HKDEF_MODE_EXTRACT_AND_EXPAND and instead implement
-  // the extraction step ourselves because EVP_PKEY_derive does not handle
+  // the extraction step ourselves because Thin_EVP_PKEY_derive does not handle
   // zero-length keys, which are required for Web Crypto.
   unsigned char pseudorandom_key[EVP_MAX_MD_SIZE];
   unsigned int prk_len = sizeof(pseudorandom_key);
@@ -140,14 +140,14 @@ bool HKDFTraits::DeriveBits(
           &prk_len) == nullptr) {
     return false;
   }
-  if (!EVP_PKEY_CTX_hkdf_mode(ctx.get(), EVP_PKEY_HKDEF_MODE_EXPAND_ONLY) ||
-      !EVP_PKEY_CTX_set1_hkdf_key(ctx.get(), pseudorandom_key, prk_len)) {
+  if (!Thin_EVP_PKEY_CTX_hkdf_mode(ctx.get(), EVP_PKEY_HKDEF_MODE_EXPAND_ONLY) ||
+      !Thin_EVP_PKEY_CTX_set1_hkdf_key(ctx.get(), pseudorandom_key, prk_len)) {
     return false;
   }
 
   size_t length = params.length;
   ByteSource::Builder buf(length);
-  if (EVP_PKEY_derive(ctx.get(), buf.data<unsigned char>(), &length) <= 0)
+  if (Thin_EVP_PKEY_derive(ctx.get(), buf.data<unsigned char>(), &length) <= 0)
     return false;
 
   *out = std::move(buf).release();
diff --git a/src/crypto/crypto_hmac.cc b/src/crypto/crypto_hmac.cc
index b101d5c7b0..96c10db8a6 100644
--- a/src/crypto/crypto_hmac.cc
+++ b/src/crypto/crypto_hmac.cc
@@ -69,17 +69,17 @@ void Hmac::New(const FunctionCallbackInfo<Value>& args) {
 void Hmac::HmacInit(const char* hash_type, const char* key, int key_len) {
   HandleScope scope(env()->isolate());
 
-  const EVP_MD* md = EVP_get_digestbyname(hash_type);
+  const EVP_MD* md = Thin_EVP_get_digestbyname(hash_type);
   if (md == nullptr)
     return THROW_ERR_CRYPTO_INVALID_DIGEST(
         env(), "Invalid digest: %s", hash_type);
   if (key_len == 0) {
     key = "";
   }
-  ctx_.reset(HMAC_CTX_new());
-  if (!ctx_ || !HMAC_Init_ex(ctx_.get(), key, key_len, md, nullptr)) {
+  ctx_.reset(Thin_HMAC_CTX_new());
+  if (!ctx_ || !Thin_HMAC_Init_ex(ctx_.get(), key, key_len, md, nullptr)) {
     ctx_.reset();
-    return ThrowCryptoError(env(), ERR_get_error());
+    return ThrowCryptoError(env(), Thin_ERR_get_error());
   }
 }
 
@@ -94,7 +94,7 @@ void Hmac::HmacInit(const FunctionCallbackInfo<Value>& args) {
 }
 
 bool Hmac::HmacUpdate(const char* data, size_t len) {
-  return ctx_ && HMAC_Update(ctx_.get(),
+  return ctx_ && Thin_HMAC_Update(ctx_.get(),
                              reinterpret_cast<const unsigned char*>(data),
                              len) == 1;
 }
@@ -125,10 +125,10 @@ void Hmac::HmacDigest(const FunctionCallbackInfo<Value>& args) {
   unsigned int md_len = 0;
 
   if (hmac->ctx_) {
-    bool ok = HMAC_Final(hmac->ctx_.get(), md_value, &md_len);
+    bool ok = Thin_HMAC_Final(hmac->ctx_.get(), md_value, &md_len);
     hmac->ctx_.reset();
     if (!ok) {
-      return ThrowCryptoError(env, ERR_get_error(), "Failed to finalize HMAC");
+      return ThrowCryptoError(env, Thin_ERR_get_error(), "Failed to finalize HMAC");
     }
   }
 
@@ -187,7 +187,7 @@ Maybe<bool> HmacTraits::AdditionalConfig(
   CHECK(args[offset + 2]->IsObject());  // Key
 
   Utf8Value digest(env->isolate(), args[offset + 1]);
-  params->digest = EVP_get_digestbyname(*digest);
+  params->digest = Thin_EVP_get_digestbyname(*digest);
   if (params->digest == nullptr) {
     THROW_ERR_CRYPTO_INVALID_DIGEST(env, "Invalid digest: %s", *digest);
     return Nothing<bool>();
@@ -224,10 +224,10 @@ bool HmacTraits::DeriveBits(
     Environment* env,
     const HmacConfig& params,
     ByteSource* out) {
-  HMACCtxPointer ctx(HMAC_CTX_new());
+  HMACCtxPointer ctx(Thin_HMAC_CTX_new());
 
   if (!ctx ||
-      !HMAC_Init_ex(
+      !Thin_HMAC_Init_ex(
           ctx.get(),
           params.key->GetSymmetricKey(),
           params.key->GetSymmetricKeySize(),
@@ -236,7 +236,7 @@ bool HmacTraits::DeriveBits(
     return false;
   }
 
-  if (!HMAC_Update(
+  if (!Thin_HMAC_Update(
           ctx.get(),
           params.data.data<unsigned char>(),
           params.data.size())) {
@@ -246,7 +246,7 @@ bool HmacTraits::DeriveBits(
   ByteSource::Builder buf(EVP_MAX_MD_SIZE);
   unsigned int len;
 
-  if (!HMAC_Final(ctx.get(), buf.data<unsigned char>(), &len)) {
+  if (!Thin_HMAC_Final(ctx.get(), buf.data<unsigned char>(), &len)) {
     return false;
   }
 
diff --git a/src/crypto/crypto_keygen.cc b/src/crypto/crypto_keygen.cc
index b36f908a0b..58b0a299ab 100644
--- a/src/crypto/crypto_keygen.cc
+++ b/src/crypto/crypto_keygen.cc
@@ -45,8 +45,8 @@ Maybe<bool> NidKeyPairGenTraits::AdditionalConfig(
 
 EVPKeyCtxPointer NidKeyPairGenTraits::Setup(NidKeyPairGenConfig* params) {
   EVPKeyCtxPointer ctx =
-      EVPKeyCtxPointer(EVP_PKEY_CTX_new_id(params->params.id, nullptr));
-  if (!ctx || EVP_PKEY_keygen_init(ctx.get()) <= 0)
+      EVPKeyCtxPointer(Thin_EVP_PKEY_CTX_new_id(params->params.id, nullptr));
+  if (!ctx || Thin_EVP_PKEY_keygen_init(ctx.get()) <= 0)
     return EVPKeyCtxPointer();
 
   return ctx;
diff --git a/src/crypto/crypto_keygen.h b/src/crypto/crypto_keygen.h
index 389b6b5e8d..6190f46ca1 100644
--- a/src/crypto/crypto_keygen.h
+++ b/src/crypto/crypto_keygen.h
@@ -171,7 +171,7 @@ struct KeyPairGenTraits final {
 
     // Generate the key
     EVP_PKEY* pkey = nullptr;
-    if (!EVP_PKEY_keygen(ctx.get(), &pkey))
+    if (!Thin_EVP_PKEY_keygen(ctx.get(), &pkey))
       return KeyGenJobStatus::FAILED;
 
     params->key = ManagedEVPPKey(EVPKeyPointer(pkey));
diff --git a/src/crypto/crypto_keys.cc b/src/crypto/crypto_keys.cc
index d850af9257..c48e9ba36d 100644
--- a/src/crypto/crypto_keys.cc
+++ b/src/crypto/crypto_keys.cc
@@ -87,7 +87,7 @@ ParseKeyResult TryParsePublicKey(
   // This skips surrounding data and decodes PEM to DER.
   {
     MarkPopErrorOnReturn mark_pop_error_on_return;
-    if (PEM_bytes_read_bio(&der_data, &der_len, nullptr, name,
+    if (Thin_PEM_bytes_read_bio(&der_data, &der_len, nullptr, name,
                            bp.get(), nullptr, nullptr) != 1)
       return ParseKeyResult::kParseKeyNotRecognized;
   }
@@ -95,7 +95,7 @@ ParseKeyResult TryParsePublicKey(
   // OpenSSL might modify the pointer, so we need to make a copy before parsing.
   const unsigned char* p = der_data;
   pkey->reset(parse(&p, der_len));
-  OPENSSL_clear_free(der_data, der_len);
+  Thin_OPENSSL_clear_free(der_data, der_len);
 
   return *pkey ? ParseKeyResult::kParseKeyOk :
                  ParseKeyResult::kParseKeyFailed;
@@ -104,7 +104,7 @@ ParseKeyResult TryParsePublicKey(
 ParseKeyResult ParsePublicKeyPEM(EVPKeyPointer* pkey,
                                  const char* key_pem,
                                  int key_pem_len) {
-  BIOPointer bp(BIO_new_mem_buf(const_cast<char*>(key_pem), key_pem_len));
+  BIOPointer bp(Thin_BIO_new_mem_buf(const_cast<char*>(key_pem), key_pem_len));
   if (!bp)
     return ParseKeyResult::kParseKeyFailed;
 
@@ -113,26 +113,26 @@ ParseKeyResult ParsePublicKeyPEM(EVPKeyPointer* pkey,
   // Try parsing as a SubjectPublicKeyInfo first.
   ret = TryParsePublicKey(pkey, bp, "PUBLIC KEY",
       [](const unsigned char** p, long l) {  // NOLINT(runtime/int)
-        return d2i_PUBKEY(nullptr, p, l);
+        return Thin_d2i_PUBKEY(nullptr, p, l);
       });
   if (ret != ParseKeyResult::kParseKeyNotRecognized)
     return ret;
 
   // Maybe it is PKCS#1.
-  CHECK(BIO_reset(bp.get()));
+  CHECK(Thin_BIO_reset(bp.get()));
   ret = TryParsePublicKey(pkey, bp, "RSA PUBLIC KEY",
       [](const unsigned char** p, long l) {  // NOLINT(runtime/int)
-        return d2i_PublicKey(EVP_PKEY_RSA, nullptr, p, l);
+        return Thin_d2i_PublicKey(EVP_PKEY_RSA, nullptr, p, l);
       });
   if (ret != ParseKeyResult::kParseKeyNotRecognized)
     return ret;
 
   // X.509 fallback.
-  CHECK(BIO_reset(bp.get()));
+  CHECK(Thin_BIO_reset(bp.get()));
   return TryParsePublicKey(pkey, bp, "CERTIFICATE",
       [](const unsigned char** p, long l) {  // NOLINT(runtime/int)
-        X509Pointer x509(d2i_X509(nullptr, p, l));
-        return x509 ? X509_get_pubkey(x509.get()) : nullptr;
+        X509Pointer x509(Thin_d2i_X509(nullptr, p, l));
+        return x509 ? Thin_X509_get_pubkey(x509.get()) : nullptr;
       });
 }
 
@@ -147,10 +147,10 @@ ParseKeyResult ParsePublicKey(EVPKeyPointer* pkey,
 
     const unsigned char* p = reinterpret_cast<const unsigned char*>(key);
     if (config.type_.ToChecked() == kKeyEncodingPKCS1) {
-      pkey->reset(d2i_PublicKey(EVP_PKEY_RSA, nullptr, &p, key_len));
+      pkey->reset(Thin_d2i_PublicKey(EVP_PKEY_RSA, nullptr, &p, key_len));
     } else {
       CHECK_EQ(config.type_.ToChecked(), kKeyEncodingSPKI);
-      pkey->reset(d2i_PUBKEY(nullptr, &p, key_len));
+      pkey->reset(Thin_d2i_PUBKEY(nullptr, &p, key_len));
     }
 
     return *pkey ? ParseKeyResult::kParseKeyOk :
@@ -218,11 +218,11 @@ ParseKeyResult ParsePrivateKey(EVPKeyPointer* pkey,
   const ByteSource* passphrase = config.passphrase_.get();
 
   if (config.format_ == kKeyFormatPEM) {
-    BIOPointer bio(BIO_new_mem_buf(key, key_len));
+    BIOPointer bio(Thin_BIO_new_mem_buf(key, key_len));
     if (!bio)
       return ParseKeyResult::kParseKeyFailed;
 
-    pkey->reset(PEM_read_bio_PrivateKey(bio.get(),
+    pkey->reset(Thin_PEM_read_bio_PrivateKey(bio.get(),
                                         nullptr,
                                         PasswordCallback,
                                         &passphrase));
@@ -231,32 +231,32 @@ ParseKeyResult ParsePrivateKey(EVPKeyPointer* pkey,
 
     if (config.type_.ToChecked() == kKeyEncodingPKCS1) {
       const unsigned char* p = reinterpret_cast<const unsigned char*>(key);
-      pkey->reset(d2i_PrivateKey(EVP_PKEY_RSA, nullptr, &p, key_len));
+      pkey->reset(Thin_d2i_PrivateKey(EVP_PKEY_RSA, nullptr, &p, key_len));
     } else if (config.type_.ToChecked() == kKeyEncodingPKCS8) {
-      BIOPointer bio(BIO_new_mem_buf(key, key_len));
+      BIOPointer bio(Thin_BIO_new_mem_buf(key, key_len));
       if (!bio)
         return ParseKeyResult::kParseKeyFailed;
 
       if (IsEncryptedPrivateKeyInfo(
               reinterpret_cast<const unsigned char*>(key), key_len)) {
-        pkey->reset(d2i_PKCS8PrivateKey_bio(bio.get(),
+        pkey->reset(Thin_d2i_PKCS8PrivateKey_bio(bio.get(),
                                             nullptr,
                                             PasswordCallback,
                                             &passphrase));
       } else {
-        PKCS8Pointer p8inf(d2i_PKCS8_PRIV_KEY_INFO_bio(bio.get(), nullptr));
+        PKCS8Pointer p8inf(Thin_d2i_PKCS8_PRIV_KEY_INFO_bio(bio.get(), nullptr));
         if (p8inf)
-          pkey->reset(EVP_PKCS82PKEY(p8inf.get()));
+          pkey->reset(Thin_EVP_PKCS82PKEY(p8inf.get()));
       }
     } else {
       CHECK_EQ(config.type_.ToChecked(), kKeyEncodingSEC1);
       const unsigned char* p = reinterpret_cast<const unsigned char*>(key);
-      pkey->reset(d2i_PrivateKey(EVP_PKEY_EC, nullptr, &p, key_len));
+      pkey->reset(Thin_d2i_PrivateKey(EVP_PKEY_EC, nullptr, &p, key_len));
     }
   }
 
   // OpenSSL can fail to parse the key but still return a non-null pointer.
-  unsigned long err = ERR_peek_error();  // NOLINT(runtime/int)
+  unsigned long err = Thin_ERR_peek_error();  // NOLINT(runtime/int)
   if (err != 0)
     pkey->reset();
 
@@ -275,7 +275,7 @@ MaybeLocal<Value> BIOToStringOrBuffer(
     BIO* bio,
     PKFormatType format) {
   BUF_MEM* bptr;
-  BIO_get_mem_ptr(bio, &bptr);
+  Thin_BIO_get_mem_ptr(bio, &bptr);
   if (format == kKeyFormatPEM) {
     // PEM is an ASCII format, so we will return it as a string.
     return String::NewFromUtf8(env->isolate(), bptr->data,
@@ -294,7 +294,7 @@ MaybeLocal<Value> WritePrivateKey(
     Environment* env,
     EVP_PKEY* pkey,
     const PrivateKeyEncodingConfig& config) {
-  BIOPointer bio(BIO_new(BIO_s_mem()));
+  BIOPointer bio(Thin_BIO_new(Thin_BIO_s_mem()));
   CHECK(bio);
 
   // If an empty string was passed as the passphrase, the ByteSource might
@@ -325,12 +325,12 @@ MaybeLocal<Value> WritePrivateKey(
   PKEncodingType encoding_type = config.type_.ToChecked();
   if (encoding_type == kKeyEncodingPKCS1) {
     // PKCS#1 is only permitted for RSA keys.
-    CHECK_EQ(EVP_PKEY_id(pkey), EVP_PKEY_RSA);
+    CHECK_EQ(Thin_EVP_PKEY_id(pkey), EVP_PKEY_RSA);
 
-    RSAPointer rsa(EVP_PKEY_get1_RSA(pkey));
+    RSAPointer rsa(Thin_EVP_PKEY_get1_RSA(pkey));
     if (config.format_ == kKeyFormatPEM) {
       // Encode PKCS#1 as PEM.
-      err = PEM_write_bio_RSAPrivateKey(
+      err = Thin_PEM_write_bio_RSAPrivateKey(
                 bio.get(), rsa.get(),
                 config.cipher_,
                 reinterpret_cast<unsigned char*>(pass),
@@ -340,12 +340,12 @@ MaybeLocal<Value> WritePrivateKey(
       // Encode PKCS#1 as DER. This does not permit encryption.
       CHECK_EQ(config.format_, kKeyFormatDER);
       CHECK_NULL(config.cipher_);
-      err = i2d_RSAPrivateKey_bio(bio.get(), rsa.get()) != 1;
+      err = Thin_i2d_RSAPrivateKey_bio(bio.get(), rsa.get()) != 1;
     }
   } else if (encoding_type == kKeyEncodingPKCS8) {
     if (config.format_ == kKeyFormatPEM) {
       // Encode PKCS#8 as PEM.
-      err = PEM_write_bio_PKCS8PrivateKey(
+      err = Thin_PEM_write_bio_PKCS8PrivateKey(
                 bio.get(), pkey,
                 config.cipher_,
                 pass,
@@ -354,7 +354,7 @@ MaybeLocal<Value> WritePrivateKey(
     } else {
       // Encode PKCS#8 as DER.
       CHECK_EQ(config.format_, kKeyFormatDER);
-      err = i2d_PKCS8PrivateKey_bio(
+      err = Thin_i2d_PKCS8PrivateKey_bio(
                 bio.get(), pkey,
                 config.cipher_,
                 pass,
@@ -365,12 +365,12 @@ MaybeLocal<Value> WritePrivateKey(
     CHECK_EQ(encoding_type, kKeyEncodingSEC1);
 
     // SEC1 is only permitted for EC keys.
-    CHECK_EQ(EVP_PKEY_id(pkey), EVP_PKEY_EC);
+    CHECK_EQ(Thin_EVP_PKEY_id(pkey), EVP_PKEY_EC);
 
-    ECKeyPointer ec_key(EVP_PKEY_get1_EC_KEY(pkey));
+    ECKeyPointer ec_key(Thin_EVP_PKEY_get1_EC_KEY(pkey));
     if (config.format_ == kKeyFormatPEM) {
       // Encode SEC1 as PEM.
-      err = PEM_write_bio_ECPrivateKey(
+      err = Thin_PEM_write_bio_ECPrivateKey(
                 bio.get(), ec_key.get(),
                 config.cipher_,
                 reinterpret_cast<unsigned char*>(pass),
@@ -380,12 +380,12 @@ MaybeLocal<Value> WritePrivateKey(
       // Encode SEC1 as DER. This does not permit encryption.
       CHECK_EQ(config.format_, kKeyFormatDER);
       CHECK_NULL(config.cipher_);
-      err = i2d_ECPrivateKey_bio(bio.get(), ec_key.get()) != 1;
+      err = Thin_i2d_ECPrivateKey_bio(bio.get(), ec_key.get()) != 1;
     }
   }
 
   if (err) {
-    ThrowCryptoError(env, ERR_get_error(), "Failed to encode private key");
+    ThrowCryptoError(env, Thin_ERR_get_error(), "Failed to encode private key");
     return MaybeLocal<Value>();
   }
   return BIOToStringOrBuffer(env, bio.get(), config.format_);
@@ -396,25 +396,25 @@ bool WritePublicKeyInner(EVP_PKEY* pkey,
                          const PublicKeyEncodingConfig& config) {
   if (config.type_.ToChecked() == kKeyEncodingPKCS1) {
     // PKCS#1 is only valid for RSA keys.
-    CHECK_EQ(EVP_PKEY_id(pkey), EVP_PKEY_RSA);
-    RSAPointer rsa(EVP_PKEY_get1_RSA(pkey));
+    CHECK_EQ(Thin_EVP_PKEY_id(pkey), EVP_PKEY_RSA);
+    RSAPointer rsa(Thin_EVP_PKEY_get1_RSA(pkey));
     if (config.format_ == kKeyFormatPEM) {
       // Encode PKCS#1 as PEM.
-      return PEM_write_bio_RSAPublicKey(bio.get(), rsa.get()) == 1;
+      return Thin_PEM_write_bio_RSAPublicKey(bio.get(), rsa.get()) == 1;
     } else {
       // Encode PKCS#1 as DER.
       CHECK_EQ(config.format_, kKeyFormatDER);
-      return i2d_RSAPublicKey_bio(bio.get(), rsa.get()) == 1;
+      return Thin_i2d_RSAPublicKey_bio(bio.get(), rsa.get()) == 1;
     }
   } else {
     CHECK_EQ(config.type_.ToChecked(), kKeyEncodingSPKI);
     if (config.format_ == kKeyFormatPEM) {
       // Encode SPKI as PEM.
-      return PEM_write_bio_PUBKEY(bio.get(), pkey) == 1;
+      return Thin_PEM_write_bio_PUBKEY(bio.get(), pkey) == 1;
     } else {
       // Encode SPKI as DER.
       CHECK_EQ(config.format_, kKeyFormatDER);
-      return i2d_PUBKEY_bio(bio.get(), pkey) == 1;
+      return Thin_i2d_PUBKEY_bio(bio.get(), pkey) == 1;
     }
   }
 }
@@ -422,11 +422,11 @@ bool WritePublicKeyInner(EVP_PKEY* pkey,
 MaybeLocal<Value> WritePublicKey(Environment* env,
                                  EVP_PKEY* pkey,
                                  const PublicKeyEncodingConfig& config) {
-  BIOPointer bio(BIO_new(BIO_s_mem()));
+  BIOPointer bio(Thin_BIO_new(Thin_BIO_s_mem()));
   CHECK(bio);
 
   if (!WritePublicKeyInner(pkey, bio, config)) {
-    ThrowCryptoError(env, ERR_get_error(), "Failed to encode public key");
+    ThrowCryptoError(env, Thin_ERR_get_error(), "Failed to encode public key");
     return MaybeLocal<Value>();
   }
   return BIOToStringOrBuffer(env, bio.get(), config.format_);
@@ -489,7 +489,7 @@ Maybe<bool> ExportJWKAsymmetricKey(
     std::shared_ptr<KeyObjectData> key,
     Local<Object> target,
     bool handleRsaPss) {
-  switch (EVP_PKEY_id(key->GetAsymmetricKey().get())) {
+  switch (Thin_EVP_PKEY_id(key->GetAsymmetricKey().get())) {
     case EVP_PKEY_RSA_PSS: {
       if (handleRsaPss) return ExportJWKRsaKey(env, key, target);
       break;
@@ -542,7 +542,7 @@ Maybe<bool> GetAsymmetricKeyDetail(
   Environment* env,
   std::shared_ptr<KeyObjectData> key,
   Local<Object> target) {
-  switch (EVP_PKEY_id(key->GetAsymmetricKey().get())) {
+  switch (Thin_EVP_PKEY_id(key->GetAsymmetricKey().get())) {
     case EVP_PKEY_RSA:
       // Fall through
     case EVP_PKEY_RSA_PSS: return GetRsaKeyDetail(env, key, target);
@@ -568,7 +568,7 @@ ManagedEVPPKey& ManagedEVPPKey::operator=(const ManagedEVPPKey& that) {
   pkey_.reset(that.get());
 
   if (pkey_)
-    EVP_PKEY_up_ref(pkey_.get());
+    Thin_EVP_PKEY_up_ref(pkey_.get());
 
   mutex_ = that.mutex_;
 
@@ -596,13 +596,13 @@ void ManagedEVPPKey::MemoryInfo(MemoryTracker* tracker) const {
 
 size_t ManagedEVPPKey::size_of_private_key() const {
   size_t len = 0;
-  return (pkey_ && EVP_PKEY_get_raw_private_key(
+  return (pkey_ && Thin_EVP_PKEY_get_raw_private_key(
       pkey_.get(), nullptr, &len) == 1) ? len : 0;
 }
 
 size_t ManagedEVPPKey::size_of_public_key() const {
   size_t len = 0;
-  return (pkey_ && EVP_PKEY_get_raw_public_key(
+  return (pkey_ && Thin_EVP_PKEY_get_raw_public_key(
       pkey_.get(), nullptr, &len) == 1) ? len : 0;
 }
 
@@ -686,7 +686,7 @@ ManagedEVPPKey::GetPrivateKeyEncodingFromJs(
     if (context != kKeyContextInput) {
       if (args[*offset]->IsString()) {
         Utf8Value cipher_name(env->isolate(), args[*offset]);
-        result.cipher_ = EVP_get_cipherbyname(*cipher_name);
+        result.cipher_ = Thin_EVP_get_cipherbyname(*cipher_name);
         if (result.cipher_ == nullptr) {
           THROW_ERR_CRYPTO_UNKNOWN_CIPHER(env);
           return NonCopyableMaybe<PrivateKeyEncodingConfig>();
@@ -830,7 +830,7 @@ ManagedEVPPKey ManagedEVPPKey::GetParsedKey(Environment* env,
                                    "Passphrase required for encrypted key");
       break;
     default:
-      ThrowCryptoError(env, ERR_get_error(), default_msg);
+      ThrowCryptoError(env, Thin_ERR_get_error(), default_msg);
   }
 
   return ManagedEVPPKey(std::move(pkey));
@@ -1061,22 +1061,22 @@ void KeyObjectHandle::InitECRaw(const FunctionCallbackInfo<Value>& args) {
 
   MarkPopErrorOnReturn mark_pop_error_on_return;
 
-  int id = OBJ_txt2nid(*name);
-  ECKeyPointer eckey(EC_KEY_new_by_curve_name(id));
+  int id = Thin_OBJ_txt2nid(*name);
+  ECKeyPointer eckey(Thin_EC_KEY_new_by_curve_name(id));
   if (!eckey)
     return args.GetReturnValue().Set(false);
 
-  const EC_GROUP* group = EC_KEY_get0_group(eckey.get());
+  const EC_GROUP* group = Thin_EC_KEY_get0_group(eckey.get());
   ECPointPointer pub(ECDH::BufferToPoint(env, group, args[1]));
 
   if (!pub ||
       !eckey ||
-      !EC_KEY_set_public_key(eckey.get(), pub.get())) {
+      !Thin_EC_KEY_set_public_key(eckey.get(), pub.get())) {
     return args.GetReturnValue().Set(false);
   }
 
-  EVPKeyPointer pkey(EVP_PKEY_new());
-  if (!EVP_PKEY_assign_EC_KEY(pkey.get(), eckey.get()))
+  EVPKeyPointer pkey(Thin_EVP_PKEY_new());
+  if (!Thin_EVP_PKEY_assign_EC_KEY(pkey.get(), eckey.get()))
     args.GetReturnValue().Set(false);
 
   eckey.release();  // Release ownership of the key
@@ -1104,8 +1104,8 @@ void KeyObjectHandle::InitEDRaw(const FunctionCallbackInfo<Value>& args) {
 
   typedef EVP_PKEY* (*new_key_fn)(int, ENGINE*, const unsigned char*, size_t);
   new_key_fn fn = type == kKeyTypePrivate
-      ? EVP_PKEY_new_raw_private_key
-      : EVP_PKEY_new_raw_public_key;
+      ? Thin_EVP_PKEY_new_raw_private_key
+      : Thin_EVP_PKEY_new_raw_public_key;
 
   int id = GetOKPCurveFromName(*name);
 
@@ -1147,7 +1147,7 @@ void KeyObjectHandle::Equals(const FunctionCallbackInfo<Value>& args) {
     case kKeyTypeSecret: {
       size_t size = key->GetSymmetricKeySize();
       if (size == key2->GetSymmetricKeySize()) {
-        ret = CRYPTO_memcmp(
+        ret = Thin_CRYPTO_memcmp(
           key->GetSymmetricKey(),
           key2->GetSymmetricKey(),
           size) == 0;
@@ -1161,7 +1161,7 @@ void KeyObjectHandle::Equals(const FunctionCallbackInfo<Value>& args) {
       EVP_PKEY* pkey = key->GetAsymmetricKey().get();
       EVP_PKEY* pkey2 = key2->GetAsymmetricKey().get();
 #if OPENSSL_VERSION_MAJOR >= 3
-      int ok = EVP_PKEY_eq(pkey, pkey2);
+      int ok = Thin_EVP_PKEY_eq(pkey, pkey2);
 #else
       int ok = EVP_PKEY_cmp(pkey, pkey2);
 #endif
@@ -1208,7 +1208,7 @@ void KeyObjectHandle::GetKeyDetail(const FunctionCallbackInfo<Value>& args) {
 
 Local<Value> KeyObjectHandle::GetAsymmetricKeyType() const {
   const ManagedEVPPKey& key = data_->GetAsymmetricKey();
-  switch (EVP_PKEY_id(key.get())) {
+  switch (Thin_EVP_PKEY_id(key.get())) {
   case EVP_PKEY_RSA:
     return env()->crypto_rsa_string();
   case EVP_PKEY_RSA_PSS:
@@ -1241,27 +1241,23 @@ void KeyObjectHandle::GetAsymmetricKeyType(
 }
 
 bool KeyObjectHandle::CheckEcKeyData() const {
-#ifndef OPENSSL_IS_BORINGSSL
   MarkPopErrorOnReturn mark_pop_error_on_return;
 
   const ManagedEVPPKey& key = data_->GetAsymmetricKey();
   KeyType type = data_->GetKeyType();
   CHECK_NE(type, kKeyTypeSecret);
-  EVPKeyCtxPointer ctx(EVP_PKEY_CTX_new(key.get(), nullptr));
+  EVPKeyCtxPointer ctx(Thin_EVP_PKEY_CTX_new(key.get(), nullptr));
   CHECK(ctx);
-  CHECK_EQ(EVP_PKEY_id(key.get()), EVP_PKEY_EC);
+  CHECK_EQ(Thin_EVP_PKEY_id(key.get()), EVP_PKEY_EC);
 
   if (type == kKeyTypePrivate) {
-    return EVP_PKEY_check(ctx.get()) == 1;
+    return Thin_EVP_PKEY_check(ctx.get()) == 1;
   }
 
 #if OPENSSL_VERSION_MAJOR >= 3
-  return EVP_PKEY_public_check_quick(ctx.get()) == 1;
+  return Thin_EVP_PKEY_public_check_quick(ctx.get()) == 1;
 #else
-  return EVP_PKEY_public_check(ctx.get()) == 1;
-#endif
-#else
-  return true;
+  return Thin_EVP_PKEY_public_check(ctx.get()) == 1;
 #endif
 }
 
@@ -1454,9 +1450,9 @@ WebCryptoKeyExportStatus PKEY_SPKI_Export(
   CHECK_EQ(key_data->GetKeyType(), kKeyTypePublic);
   ManagedEVPPKey m_pkey = key_data->GetAsymmetricKey();
   Mutex::ScopedLock lock(*m_pkey.mutex());
-  BIOPointer bio(BIO_new(BIO_s_mem()));
+  BIOPointer bio(Thin_BIO_new(Thin_BIO_s_mem()));
   CHECK(bio);
-  if (!i2d_PUBKEY_bio(bio.get(), m_pkey.get()))
+  if (!Thin_i2d_PUBKEY_bio(bio.get(), m_pkey.get()))
     return WebCryptoKeyExportStatus::FAILED;
 
   *out = ByteSource::FromBIO(bio);
@@ -1470,10 +1466,10 @@ WebCryptoKeyExportStatus PKEY_PKCS8_Export(
   ManagedEVPPKey m_pkey = key_data->GetAsymmetricKey();
   Mutex::ScopedLock lock(*m_pkey.mutex());
 
-  BIOPointer bio(BIO_new(BIO_s_mem()));
+  BIOPointer bio(Thin_BIO_new(Thin_BIO_s_mem()));
   CHECK(bio);
-  PKCS8Pointer p8inf(EVP_PKEY2PKCS8(m_pkey.get()));
-  if (!i2d_PKCS8_PRIV_KEY_INFO_bio(bio.get(), p8inf.get()))
+  PKCS8Pointer p8inf(Thin_EVP_PKEY2PKCS8(m_pkey.get()));
+  if (!Thin_i2d_PKCS8_PRIV_KEY_INFO_bio(bio.get(), p8inf.get()))
     return WebCryptoKeyExportStatus::FAILED;
 
   *out = ByteSource::FromBIO(bio);
diff --git a/src/crypto/crypto_keys.h b/src/crypto/crypto_keys.h
index 820d26cc15..da7f3f3d04 100644
--- a/src/crypto/crypto_keys.h
+++ b/src/crypto/crypto_keys.h
@@ -11,7 +11,7 @@
 #include "node_worker.h"
 #include "v8.h"
 
-#include <openssl/evp.h>
+// #include <openssl/evp.h>
 
 #include <memory>
 #include <string>
diff --git a/src/crypto/crypto_pbkdf2.cc b/src/crypto/crypto_pbkdf2.cc
index 963d0db6c6..a5c9685137 100644
--- a/src/crypto/crypto_pbkdf2.cc
+++ b/src/crypto/crypto_pbkdf2.cc
@@ -102,7 +102,7 @@ Maybe<bool> PBKDF2Traits::AdditionalConfig(
   }
 
   Utf8Value name(args.GetIsolate(), args[offset + 4]);
-  params->digest = EVP_get_digestbyname(*name);
+  params->digest = Thin_EVP_get_digestbyname(*name);
   if (params->digest == nullptr) {
     THROW_ERR_CRYPTO_INVALID_DIGEST(env, "Invalid digest: %s", *name);
     return Nothing<bool>();
@@ -121,7 +121,7 @@ bool PBKDF2Traits::DeriveBits(
   // The generated bytes are stored in buf, which is
   // assigned to out on success.
 
-  if (PKCS5_PBKDF2_HMAC(params.pass.data<char>(),
+  if (Thin_PKCS5_PBKDF2_HMAC(params.pass.data<char>(),
                         params.pass.size(),
                         params.salt.data<unsigned char>(),
                         params.salt.size(),
diff --git a/src/crypto/crypto_random.cc b/src/crypto/crypto_random.cc
index 6431e5c306..06ba0601ed 100644
--- a/src/crypto/crypto_random.cc
+++ b/src/crypto/crypto_random.cc
@@ -6,8 +6,8 @@
 #include "threadpoolwork-inl.h"
 #include "v8.h"
 
-#include <openssl/bn.h>
-#include <openssl/rand.h>
+// #include <openssl/bn.h>
+// #include <openssl/rand.h>
 
 namespace node {
 
@@ -72,11 +72,11 @@ Maybe<bool> RandomPrimeTraits::EncodeOutput(
     const RandomPrimeConfig& params,
     ByteSource* unused,
     v8::Local<v8::Value>* result) {
-  size_t size = BN_num_bytes(params.prime.get());
+  size_t size = Thin_BN_num_bytes(params.prime.get());
   std::shared_ptr<BackingStore> store =
       ArrayBuffer::NewBackingStore(env->isolate(), size);
   CHECK_EQ(static_cast<int>(size),
-           BN_bn2binpad(params.prime.get(),
+           Thin_BN_bn2binpad(params.prime.get(),
                         reinterpret_cast<unsigned char*>(store->Data()),
                         size));
   *result = ArrayBuffer::New(env->isolate(), store);
@@ -98,7 +98,7 @@ Maybe<bool> RandomPrimeTraits::AdditionalConfig(
 
   if (!args[offset + 2]->IsUndefined()) {
     ArrayBufferOrViewContents<unsigned char> add(args[offset + 2]);
-    params->add.reset(BN_bin2bn(add.data(), add.size(), nullptr));
+    params->add.reset(Thin_BN_bin2bn(add.data(), add.size(), nullptr));
     if (!params->add) {
       THROW_ERR_CRYPTO_OPERATION_FAILED(env, "could not generate prime");
       return Nothing<bool>();
@@ -107,7 +107,7 @@ Maybe<bool> RandomPrimeTraits::AdditionalConfig(
 
   if (!args[offset + 3]->IsUndefined()) {
     ArrayBufferOrViewContents<unsigned char> rem(args[offset + 3]);
-    params->rem.reset(BN_bin2bn(rem.data(), rem.size(), nullptr));
+    params->rem.reset(Thin_BN_bin2bn(rem.data(), rem.size(), nullptr));
     if (!params->rem) {
       THROW_ERR_CRYPTO_OPERATION_FAILED(env, "could not generate prime");
       return Nothing<bool>();
@@ -119,7 +119,7 @@ Maybe<bool> RandomPrimeTraits::AdditionalConfig(
   CHECK_GT(bits, 0);
 
   if (params->add) {
-    if (BN_num_bits(params->add.get()) > bits) {
+    if (Thin_BN_num_bits(params->add.get()) > bits) {
       // If we allowed this, the best case would be returning a static prime
       // that wasn't generated randomly. The worst case would be an infinite
       // loop within OpenSSL, blocking the main thread or one of the threads
@@ -129,7 +129,7 @@ Maybe<bool> RandomPrimeTraits::AdditionalConfig(
     }
 
     if (params->rem) {
-      if (BN_cmp(params->add.get(), params->rem.get()) != 1) {
+      if (Thin_BN_cmp(params->add.get(), params->rem.get()) != 1) {
         // This would definitely lead to an infinite loop if allowed since
         // OpenSSL does not check this condition.
         THROW_ERR_OUT_OF_RANGE(env, "invalid options.rem");
@@ -140,7 +140,7 @@ Maybe<bool> RandomPrimeTraits::AdditionalConfig(
 
   params->bits = bits;
   params->safe = safe;
-  params->prime.reset(BN_new());
+  params->prime.reset(Thin_BN_secure_new());
   if (!params->prime) {
     THROW_ERR_CRYPTO_OPERATION_FAILED(env, "could not generate prime");
     return Nothing<bool>();
@@ -152,11 +152,11 @@ Maybe<bool> RandomPrimeTraits::AdditionalConfig(
 bool RandomPrimeTraits::DeriveBits(Environment* env,
                                    const RandomPrimeConfig& params,
                                    ByteSource* unused) {
-  // BN_generate_prime_ex() calls RAND_bytes_ex() internally.
+  // Thin_BN_generate_prime_ex() calls Thin_RAND_bytes_ex() internally.
   // Make sure the CSPRNG is properly seeded.
   CHECK(CSPRNG(nullptr, 0).is_ok());
 
-  if (BN_generate_prime_ex(
+  if (Thin_BN_generate_prime_ex(
           params.prime.get(),
           params.bits,
           params.safe ? 1 : 0,
@@ -171,7 +171,7 @@ bool RandomPrimeTraits::DeriveBits(Environment* env,
 
 void CheckPrimeConfig::MemoryInfo(MemoryTracker* tracker) const {
   tracker->TrackFieldWithSize(
-      "prime", candidate ? BN_num_bytes(candidate.get()) : 0);
+      "prime", candidate ? Thin_BN_num_bytes(candidate.get()) : 0);
 }
 
 Maybe<bool> CheckPrimeTraits::AdditionalConfig(
@@ -182,7 +182,7 @@ Maybe<bool> CheckPrimeTraits::AdditionalConfig(
   ArrayBufferOrViewContents<unsigned char> candidate(args[offset]);
 
   params->candidate =
-      BignumPointer(BN_bin2bn(
+      BignumPointer(Thin_BN_bin2bn(
           candidate.data(),
           candidate.size(),
           nullptr));
@@ -199,9 +199,9 @@ bool CheckPrimeTraits::DeriveBits(
     const CheckPrimeConfig& params,
     ByteSource* out) {
 
-  BignumCtxPointer ctx(BN_CTX_new());
+  BignumCtxPointer ctx(Thin_BN_CTX_new());
 
-  int ret = BN_is_prime_ex(
+  int ret = Thin_BN_is_prime_ex(
             params.candidate.get(),
             params.checks,
             ctx.get(),
diff --git a/src/crypto/crypto_rsa.cc b/src/crypto/crypto_rsa.cc
index 349abd4d06..b5c6697616 100644
--- a/src/crypto/crypto_rsa.cc
+++ b/src/crypto/crypto_rsa.cc
@@ -9,8 +9,8 @@
 #include "threadpoolwork-inl.h"
 #include "v8.h"
 
-#include <openssl/bn.h>
-#include <openssl/rsa.h>
+// #include <openssl/bn.h>
+// #include <openssl/rsa.h>
 
 namespace node {
 
@@ -31,16 +31,16 @@ using v8::Value;
 namespace crypto {
 EVPKeyCtxPointer RsaKeyGenTraits::Setup(RsaKeyPairGenConfig* params) {
   EVPKeyCtxPointer ctx(
-      EVP_PKEY_CTX_new_id(
+      Thin_EVP_PKEY_CTX_new_id(
           params->params.variant == kKeyVariantRSA_PSS
               ? EVP_PKEY_RSA_PSS
               : EVP_PKEY_RSA,
           nullptr));
 
-  if (EVP_PKEY_keygen_init(ctx.get()) <= 0)
+  if (Thin_EVP_PKEY_keygen_init(ctx.get()) <= 0)
     return EVPKeyCtxPointer();
 
-  if (EVP_PKEY_CTX_set_rsa_keygen_bits(
+  if (Thin_EVP_PKEY_CTX_set_rsa_keygen_bits(
           ctx.get(),
           params->params.modulus_bits) <= 0) {
     return EVPKeyCtxPointer();
@@ -48,11 +48,11 @@ EVPKeyCtxPointer RsaKeyGenTraits::Setup(RsaKeyPairGenConfig* params) {
 
   // 0x10001 is the default RSA exponent.
   if (params->params.exponent != 0x10001) {
-    BignumPointer bn(BN_new());
+    BignumPointer bn(Thin_BN_new());
     CHECK_NOT_NULL(bn.get());
-    CHECK(BN_set_word(bn.get(), params->params.exponent));
+    CHECK(Thin_BN_set_word(bn.get(), params->params.exponent));
     // EVP_CTX accepts ownership of bn on success.
-    if (EVP_PKEY_CTX_set_rsa_keygen_pubexp(ctx.get(), bn.get()) <= 0)
+    if (Thin_EVP_PKEY_CTX_set_rsa_keygen_pubexp(ctx.get(), bn.get()) <= 0)
       return EVPKeyCtxPointer();
 
     bn.release();
@@ -60,7 +60,7 @@ EVPKeyCtxPointer RsaKeyGenTraits::Setup(RsaKeyPairGenConfig* params) {
 
   if (params->params.variant == kKeyVariantRSA_PSS) {
     if (params->params.md != nullptr &&
-        EVP_PKEY_CTX_set_rsa_pss_keygen_md(ctx.get(), params->params.md) <= 0) {
+        Thin_EVP_PKEY_CTX_set_rsa_pss_keygen_md(ctx.get(), params->params.md) <= 0) {
       return EVPKeyCtxPointer();
     }
 
@@ -74,7 +74,7 @@ EVPKeyCtxPointer RsaKeyGenTraits::Setup(RsaKeyPairGenConfig* params) {
     }
 
     if (mgf1_md != nullptr &&
-        EVP_PKEY_CTX_set_rsa_pss_keygen_mgf1_md(
+        Thin_EVP_PKEY_CTX_set_rsa_pss_keygen_mgf1_md(
             ctx.get(),
             mgf1_md) <= 0) {
       return EVPKeyCtxPointer();
@@ -82,11 +82,11 @@ EVPKeyCtxPointer RsaKeyGenTraits::Setup(RsaKeyPairGenConfig* params) {
 
     int saltlen = params->params.saltlen;
     if (saltlen < 0 && params->params.md != nullptr) {
-      saltlen = EVP_MD_size(params->params.md);
+      saltlen = Thin_EVP_MD_size(params->params.md);
     }
 
     if (saltlen >= 0 &&
-        EVP_PKEY_CTX_set_rsa_pss_keygen_saltlen(
+        Thin_EVP_PKEY_CTX_set_rsa_pss_keygen_saltlen(
             ctx.get(),
             saltlen) <= 0) {
       return EVPKeyCtxPointer();
@@ -151,7 +151,7 @@ Maybe<bool> RsaKeyGenTraits::AdditionalConfig(
     if (!args[*offset]->IsUndefined()) {
       CHECK(args[*offset]->IsString());
       Utf8Value digest(env->isolate(), args[*offset]);
-      params->params.md = EVP_get_digestbyname(*digest);
+      params->params.md = Thin_EVP_get_digestbyname(*digest);
       if (params->params.md == nullptr) {
         THROW_ERR_CRYPTO_INVALID_DIGEST(env, "Invalid digest: %s", *digest);
         return Nothing<bool>();
@@ -161,7 +161,7 @@ Maybe<bool> RsaKeyGenTraits::AdditionalConfig(
     if (!args[*offset + 1]->IsUndefined()) {
       CHECK(args[*offset + 1]->IsString());
       Utf8Value digest(env->isolate(), args[*offset + 1]);
-      params->params.mgf1_md = EVP_get_digestbyname(*digest);
+      params->params.mgf1_md = Thin_EVP_get_digestbyname(*digest);
       if (params->params.mgf1_md == nullptr) {
         THROW_ERR_CRYPTO_INVALID_DIGEST(
             env, "Invalid MGF1 digest: %s", *digest);
@@ -206,18 +206,18 @@ WebCryptoCipherStatus RSA_Cipher(
   ManagedEVPPKey m_pkey = key_data->GetAsymmetricKey();
   Mutex::ScopedLock lock(*m_pkey.mutex());
 
-  EVPKeyCtxPointer ctx(EVP_PKEY_CTX_new(m_pkey.get(), nullptr));
+  EVPKeyCtxPointer ctx(Thin_EVP_PKEY_CTX_new(m_pkey.get(), nullptr));
 
   if (!ctx || init(ctx.get()) <= 0)
     return WebCryptoCipherStatus::FAILED;
 
-  if (EVP_PKEY_CTX_set_rsa_padding(ctx.get(), params.padding) <= 0) {
+  if (Thin_EVP_PKEY_CTX_set_rsa_padding(ctx.get(), params.padding) <= 0) {
     return WebCryptoCipherStatus::FAILED;
   }
 
   if (params.digest != nullptr &&
-      (EVP_PKEY_CTX_set_rsa_oaep_md(ctx.get(), params.digest) <= 0 ||
-       EVP_PKEY_CTX_set_rsa_mgf1_md(ctx.get(), params.digest) <= 0)) {
+      (Thin_EVP_PKEY_CTX_set_rsa_oaep_md(ctx.get(), params.digest) <= 0 ||
+       Thin_EVP_PKEY_CTX_set_rsa_mgf1_md(ctx.get(), params.digest) <= 0)) {
     return WebCryptoCipherStatus::FAILED;
   }
 
@@ -315,7 +315,7 @@ Maybe<bool> RSACipherTraits::AdditionalConfig(
       CHECK(args[offset + 1]->IsString());  // digest
       Utf8Value digest(env->isolate(), args[offset + 1]);
 
-      params->digest = EVP_get_digestbyname(*digest);
+      params->digest = Thin_EVP_get_digestbyname(*digest);
       if (params->digest == nullptr) {
         THROW_ERR_CRYPTO_INVALID_DIGEST(env, "Invalid digest: %s", *digest);
         return Nothing<bool>();
@@ -349,11 +349,11 @@ WebCryptoCipherStatus RSACipherTraits::DoCipher(
   switch (cipher_mode) {
     case kWebCryptoCipherEncrypt:
       CHECK_EQ(key_data->GetKeyType(), kKeyTypePublic);
-      return RSA_Cipher<EVP_PKEY_encrypt_init, EVP_PKEY_encrypt>(
+      return RSA_Cipher<Thin_EVP_PKEY_encrypt_init, Thin_EVP_PKEY_encrypt>(
           env, key_data.get(), params, in, out);
     case kWebCryptoCipherDecrypt:
       CHECK_EQ(key_data->GetKeyType(), kKeyTypePrivate);
-      return RSA_Cipher<EVP_PKEY_decrypt_init, EVP_PKEY_decrypt>(
+      return RSA_Cipher<Thin_EVP_PKEY_decrypt_init, Thin_EVP_PKEY_decrypt>(
           env, key_data.get(), params, in, out);
   }
   return WebCryptoCipherStatus::FAILED;
@@ -365,16 +365,16 @@ Maybe<bool> ExportJWKRsaKey(
     Local<Object> target) {
   ManagedEVPPKey m_pkey = key->GetAsymmetricKey();
   Mutex::ScopedLock lock(*m_pkey.mutex());
-  int type = EVP_PKEY_id(m_pkey.get());
+  int type = Thin_EVP_PKEY_id(m_pkey.get());
   CHECK(type == EVP_PKEY_RSA || type == EVP_PKEY_RSA_PSS);
 
   // TODO(tniessen): Remove the "else" branch once we drop support for OpenSSL
   // versions older than 1.1.1e via FIPS / dynamic linking.
   const RSA* rsa;
-  if (OpenSSL_version_num() >= 0x1010105fL) {
-    rsa = EVP_PKEY_get0_RSA(m_pkey.get());
+  if (Thin_OpenSSL_version_num() >= 0x1010105fL) {
+    rsa = Thin_EVP_PKEY_get0_RSA(m_pkey.get());
   } else {
-    rsa = static_cast<const RSA*>(EVP_PKEY_get0(m_pkey.get()));
+    rsa = static_cast<const RSA*>(Thin_EVP_PKEY_get0(m_pkey.get()));
   }
   CHECK_NOT_NULL(rsa);
 
@@ -386,7 +386,7 @@ Maybe<bool> ExportJWKRsaKey(
   const BIGNUM* dp;
   const BIGNUM* dq;
   const BIGNUM* qi;
-  RSA_get0_key(rsa, &n, &e, &d);
+  Thin_RSA_get0_key(rsa, &n, &e, &d);
 
   if (target->Set(
           env->context(),
@@ -401,8 +401,8 @@ Maybe<bool> ExportJWKRsaKey(
   }
 
   if (key->GetKeyType() == kKeyTypePrivate) {
-    RSA_get0_factors(rsa, &p, &q);
-    RSA_get0_crt_params(rsa, &dp, &dq, &qi);
+    Thin_RSA_get0_factors(rsa, &p, &q);
+    Thin_RSA_get0_crt_params(rsa, &dp, &dq, &qi);
     if (SetEncodedValue(env, target, env->jwk_d_string(), d).IsNothing() ||
         SetEncodedValue(env, target, env->jwk_p_string(), p).IsNothing() ||
         SetEncodedValue(env, target, env->jwk_q_string(), q).IsNothing() ||
@@ -441,12 +441,12 @@ std::shared_ptr<KeyObjectData> ImportJWKRsaKey(
 
   KeyType type = d_value->IsString() ? kKeyTypePrivate : kKeyTypePublic;
 
-  RsaPointer rsa(RSA_new());
+  RsaPointer rsa(Thin_RSA_new());
 
   ByteSource n = ByteSource::FromEncodedString(env, n_value.As<String>());
   ByteSource e = ByteSource::FromEncodedString(env, e_value.As<String>());
 
-  if (!RSA_set0_key(
+  if (!Thin_RSA_set0_key(
           rsa.get(),
           n.ToBN().release(),
           e.ToBN().release(),
@@ -487,9 +487,9 @@ std::shared_ptr<KeyObjectData> ImportJWKRsaKey(
     ByteSource dq = ByteSource::FromEncodedString(env, dq_value.As<String>());
     ByteSource qi = ByteSource::FromEncodedString(env, qi_value.As<String>());
 
-    if (!RSA_set0_key(rsa.get(), nullptr, nullptr, d.ToBN().release()) ||
-        !RSA_set0_factors(rsa.get(), p.ToBN().release(), q.ToBN().release()) ||
-        !RSA_set0_crt_params(
+    if (!Thin_RSA_set0_key(rsa.get(), nullptr, nullptr, d.ToBN().release()) ||
+        !Thin_RSA_set0_factors(rsa.get(), p.ToBN().release(), q.ToBN().release()) ||
+        !Thin_RSA_set0_crt_params(
             rsa.get(),
             dp.ToBN().release(),
             dq.ToBN().release(),
@@ -499,8 +499,8 @@ std::shared_ptr<KeyObjectData> ImportJWKRsaKey(
     }
   }
 
-  EVPKeyPointer pkey(EVP_PKEY_new());
-  CHECK_EQ(EVP_PKEY_set1_RSA(pkey.get(), rsa.get()), 1);
+  EVPKeyPointer pkey(Thin_EVP_PKEY_new());
+  CHECK_EQ(Thin_EVP_PKEY_set1_RSA(pkey.get(), rsa.get()), 1);
 
   return KeyObjectData::CreateAsymmetric(type, ManagedEVPPKey(std::move(pkey)));
 }
@@ -514,22 +514,22 @@ Maybe<bool> GetRsaKeyDetail(
 
   ManagedEVPPKey m_pkey = key->GetAsymmetricKey();
   Mutex::ScopedLock lock(*m_pkey.mutex());
-  int type = EVP_PKEY_id(m_pkey.get());
+  int type = Thin_EVP_PKEY_id(m_pkey.get());
   CHECK(type == EVP_PKEY_RSA || type == EVP_PKEY_RSA_PSS);
 
   // TODO(tniessen): Remove the "else" branch once we drop support for OpenSSL
   // versions older than 1.1.1e via FIPS / dynamic linking.
   const RSA* rsa;
-  if (OpenSSL_version_num() >= 0x1010105fL) {
-    rsa = EVP_PKEY_get0_RSA(m_pkey.get());
+  if (Thin_OpenSSL_version_num() >= 0x1010105fL) {
+    rsa = Thin_EVP_PKEY_get0_RSA(m_pkey.get());
   } else {
-    rsa = static_cast<const RSA*>(EVP_PKEY_get0(m_pkey.get()));
+    rsa = static_cast<const RSA*>(Thin_EVP_PKEY_get0(m_pkey.get()));
   }
   CHECK_NOT_NULL(rsa);
 
-  RSA_get0_key(rsa, &n, &e, nullptr);
+  Thin_RSA_get0_key(rsa, &n, &e, nullptr);
 
-  size_t modulus_length = BN_num_bits(n);
+  size_t modulus_length = Thin_BN_num_bits(n);
 
   if (target
           ->Set(
@@ -544,9 +544,9 @@ Maybe<bool> GetRsaKeyDetail(
   {
     NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
     public_exponent =
-        ArrayBuffer::NewBackingStore(env->isolate(), BN_num_bytes(e));
+        ArrayBuffer::NewBackingStore(env->isolate(), Thin_BN_num_bytes(e));
   }
-  CHECK_EQ(BN_bn2binpad(e,
+  CHECK_EQ(Thin_BN_bn2binpad(e,
                         static_cast<unsigned char*>(public_exponent->Data()),
                         public_exponent->ByteLength()),
            static_cast<int>(public_exponent->ByteLength()));
@@ -563,13 +563,13 @@ Maybe<bool> GetRsaKeyDetail(
     // Due to the way ASN.1 encoding works, default values are omitted when
     // encoding the data structure. However, there are also RSA-PSS keys for
     // which no parameters are set. In that case, the ASN.1 RSASSA-PSS-params
-    // sequence will be missing entirely and RSA_get0_pss_params will return
+    // sequence will be missing entirely and Thin_RSA_get0_pss_params will return
     // nullptr. If parameters are present but all parameters are set to their
     // default values, an empty sequence will be stored in the ASN.1 structure.
-    // In that case, RSA_get0_pss_params does not return nullptr but all fields
+    // In that case, Thin_RSA_get0_pss_params does not return nullptr but all fields
     // of the returned RSA_PSS_PARAMS will be set to nullptr.
 
-    const RSA_PSS_PARAMS* params = RSA_get0_pss_params(rsa);
+    const RSA_PSS_PARAMS* params = Thin_RSA_get0_pss_params(rsa);
     if (params != nullptr) {
       int hash_nid = NID_sha1;
       int mgf_nid = NID_mgf1;
@@ -579,14 +579,14 @@ Maybe<bool> GetRsaKeyDetail(
       if (params->hashAlgorithm != nullptr) {
         const ASN1_OBJECT* hash_obj;
         X509_ALGOR_get0(&hash_obj, nullptr, nullptr, params->hashAlgorithm);
-        hash_nid = OBJ_obj2nid(hash_obj);
+        hash_nid = Thin_OBJ_obj2nid(hash_obj);
       }
 
       if (target
               ->Set(
                   env->context(),
                   env->hash_algorithm_string(),
-                  OneByteString(env->isolate(), OBJ_nid2ln(hash_nid)))
+                  OneByteString(env->isolate(), Thin_OBJ_nid2ln(hash_nid)))
               .IsNothing()) {
         return Nothing<bool>();
       }
@@ -594,11 +594,11 @@ Maybe<bool> GetRsaKeyDetail(
       if (params->maskGenAlgorithm != nullptr) {
         const ASN1_OBJECT* mgf_obj;
         X509_ALGOR_get0(&mgf_obj, nullptr, nullptr, params->maskGenAlgorithm);
-        mgf_nid = OBJ_obj2nid(mgf_obj);
+        mgf_nid = Thin_OBJ_obj2nid(mgf_obj);
         if (mgf_nid == NID_mgf1) {
           const ASN1_OBJECT* mgf1_hash_obj;
           X509_ALGOR_get0(&mgf1_hash_obj, nullptr, nullptr, params->maskHash);
-          mgf1_hash_nid = OBJ_obj2nid(mgf1_hash_obj);
+          mgf1_hash_nid = Thin_OBJ_obj2nid(mgf1_hash_obj);
         }
       }
 
@@ -609,7 +609,7 @@ Maybe<bool> GetRsaKeyDetail(
                 ->Set(
                     env->context(),
                     env->mgf1_hash_algorithm_string(),
-                    OneByteString(env->isolate(), OBJ_nid2ln(mgf1_hash_nid)))
+                    OneByteString(env->isolate(), Thin_OBJ_nid2ln(mgf1_hash_nid)))
                 .IsNothing()) {
           return Nothing<bool>();
         }
@@ -617,10 +617,10 @@ Maybe<bool> GetRsaKeyDetail(
 
       if (params->saltLength != nullptr) {
         // TODO(codebytere): Upstream a shim to BoringSSL?
-        // if (ASN1_INTEGER_get_int64(&salt_length, params->saltLength) != 1) {
-        //   ThrowCryptoError(env, ERR_get_error(), "ASN1_INTEGER_get_in64 error");
-        //   return Nothing<bool>();
-        // }
+        if (Thin_ASN1_INTEGER_get_int64(&salt_length, params->saltLength) != 1) {
+          ThrowCryptoError(env, Thin_ERR_get_error(), "ASN1_INTEGER_get_in64 error");
+          return Nothing<bool>();
+        }
       }
 
       if (target
diff --git a/src/crypto/crypto_scrypt.cc b/src/crypto/crypto_scrypt.cc
index 4dae07f136..0470946d96 100644
--- a/src/crypto/crypto_scrypt.cc
+++ b/src/crypto/crypto_scrypt.cc
@@ -93,7 +93,7 @@ Maybe<bool> ScryptTraits::AdditionalConfig(
   params->p = args[offset + 4].As<Uint32>()->Value();
   params->maxmem = args[offset + 5]->IntegerValue(env->context()).ToChecked();
 
-  if (EVP_PBE_scrypt(
+  if (Thin_EVP_PBE_scrypt(
           nullptr,
           0,
           nullptr,
@@ -122,7 +122,7 @@ bool ScryptTraits::DeriveBits(
 
   // Both the pass and salt may be zero-length at this point
 
-  if (!EVP_PBE_scrypt(params.pass.data<char>(),
+  if (!Thin_EVP_PBE_scrypt(params.pass.data<char>(),
                       params.pass.size(),
                       params.salt.data<unsigned char>(),
                       params.salt.size(),
diff --git a/src/crypto/crypto_sig.cc b/src/crypto/crypto_sig.cc
index ab020efbae..d5668c1fc0 100644
--- a/src/crypto/crypto_sig.cc
+++ b/src/crypto/crypto_sig.cc
@@ -32,18 +32,18 @@ namespace {
 bool ValidateDSAParameters(EVP_PKEY* key) {
   /* Validate DSA2 parameters from FIPS 186-4 */
 #if OPENSSL_VERSION_MAJOR >= 3
-  if (EVP_default_properties_is_fips_enabled(nullptr) &&
-      EVP_PKEY_DSA == EVP_PKEY_base_id(key)) {
+  if (Thin_EVP_default_properties_is_fips_enabled(nullptr) &&
+      EVP_PKEY_DSA == Thin_EVP_PKEY_base_id(key)) {
 #else
-  if (FIPS_mode() && EVP_PKEY_DSA == EVP_PKEY_base_id(key)) {
+  if (Thin_FIPS_mode() && EVP_PKEY_DSA == Thin_EVP_PKEY_base_id(key)) {
 #endif
-    const DSA* dsa = EVP_PKEY_get0_DSA(key);
+    const DSA* dsa = Thin_EVP_PKEY_get0_DSA(key);
     const BIGNUM* p;
-    DSA_get0_pqg(dsa, &p, nullptr, nullptr);
-    size_t L = BN_num_bits(p);
+    Thin_DSA_get0_pqg(dsa, &p, nullptr, nullptr);
+    size_t L = Thin_BN_num_bits(p);
     const BIGNUM* q;
-    DSA_get0_pqg(dsa, nullptr, &q, nullptr);
-    size_t N = BN_num_bits(q);
+    Thin_DSA_get0_pqg(dsa, nullptr, &q, nullptr);
+    size_t N = Thin_BN_num_bits(q);
 
     return (L == 1024 && N == 160) ||
            (L == 2048 && N == 224) ||
@@ -58,13 +58,13 @@ bool ApplyRSAOptions(const ManagedEVPPKey& pkey,
                      EVP_PKEY_CTX* pkctx,
                      int padding,
                      const Maybe<int>& salt_len) {
-  if (EVP_PKEY_id(pkey.get()) == EVP_PKEY_RSA ||
-      EVP_PKEY_id(pkey.get()) == EVP_PKEY_RSA2 ||
-      EVP_PKEY_id(pkey.get()) == EVP_PKEY_RSA_PSS) {
-    if (EVP_PKEY_CTX_set_rsa_padding(pkctx, padding) <= 0)
+  if (Thin_EVP_PKEY_id(pkey.get()) == EVP_PKEY_RSA ||
+      Thin_EVP_PKEY_id(pkey.get()) == EVP_PKEY_RSA2 ||
+      Thin_EVP_PKEY_id(pkey.get()) == EVP_PKEY_RSA_PSS) {
+    if (Thin_EVP_PKEY_CTX_set_rsa_padding(pkctx, padding) <= 0)
       return false;
     if (padding == RSA_PKCS1_PSS_PADDING && salt_len.IsJust()) {
-      if (EVP_PKEY_CTX_set_rsa_pss_saltlen(pkctx, salt_len.FromJust()) <= 0)
+      if (Thin_EVP_PKEY_CTX_set_rsa_pss_saltlen(pkctx, salt_len.FromJust()) <= 0)
         return false;
     }
   }
@@ -80,10 +80,10 @@ std::unique_ptr<BackingStore> Node_SignFinal(Environment* env,
   unsigned char m[EVP_MAX_MD_SIZE];
   unsigned int m_len;
 
-  if (!EVP_DigestFinal_ex(mdctx.get(), m, &m_len))
+  if (!Thin_EVP_DigestFinal_ex(mdctx.get(), m, &m_len))
     return nullptr;
 
-  int signed_sig_len = EVP_PKEY_size(pkey.get());
+  int signed_sig_len = Thin_EVP_PKEY_size(pkey.get());
   CHECK_GE(signed_sig_len, 0);
   size_t sig_len = static_cast<size_t>(signed_sig_len);
   std::unique_ptr<BackingStore> sig;
@@ -91,12 +91,12 @@ std::unique_ptr<BackingStore> Node_SignFinal(Environment* env,
     NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
     sig = ArrayBuffer::NewBackingStore(env->isolate(), sig_len);
   }
-  EVPKeyCtxPointer pkctx(EVP_PKEY_CTX_new(pkey.get(), nullptr));
+  EVPKeyCtxPointer pkctx(Thin_EVP_PKEY_CTX_new(pkey.get(), nullptr));
   if (pkctx &&
-      EVP_PKEY_sign_init(pkctx.get()) &&
+      Thin_EVP_PKEY_sign_init(pkctx.get()) &&
       ApplyRSAOptions(pkey, pkctx.get(), padding, pss_salt_len) &&
-      EVP_PKEY_CTX_set_signature_md(pkctx.get(), EVP_MD_CTX_md(mdctx.get())) &&
-      EVP_PKEY_sign(pkctx.get(), static_cast<unsigned char*>(sig->Data()),
+      Thin_EVP_PKEY_CTX_set_signature_md(pkctx.get(), Thin_EVP_MD_CTX_md(mdctx.get())) &&
+      Thin_EVP_PKEY_sign(pkctx.get(), static_cast<unsigned char*>(sig->Data()),
                     &sig_len, m, m_len)) {
     CHECK_LE(sig_len, sig->ByteLength());
     if (sig_len == 0) {
@@ -115,21 +115,21 @@ std::unique_ptr<BackingStore> Node_SignFinal(Environment* env,
 }
 
 int GetDefaultSignPadding(const ManagedEVPPKey& m_pkey) {
-  return EVP_PKEY_id(m_pkey.get()) == EVP_PKEY_RSA_PSS ? RSA_PKCS1_PSS_PADDING :
+  return Thin_EVP_PKEY_id(m_pkey.get()) == EVP_PKEY_RSA_PSS ? RSA_PKCS1_PSS_PADDING :
                                                          RSA_PKCS1_PADDING;
 }
 
 unsigned int GetBytesOfRS(const ManagedEVPPKey& pkey) {
-  int bits, base_id = EVP_PKEY_base_id(pkey.get());
+  int bits, base_id = Thin_EVP_PKEY_base_id(pkey.get());
 
   if (base_id == EVP_PKEY_DSA) {
-    const DSA* dsa_key = EVP_PKEY_get0_DSA(pkey.get());
+    const DSA* dsa_key = Thin_EVP_PKEY_get0_DSA(pkey.get());
     // Both r and s are computed mod q, so their width is limited by that of q.
-    bits = BN_num_bits(DSA_get0_q(dsa_key));
+    bits = Thin_BN_num_bits(Thin_DSA_get0_q(dsa_key));
   } else if (base_id == EVP_PKEY_EC) {
-    const EC_KEY* ec_key = EVP_PKEY_get0_EC_KEY(pkey.get());
-    const EC_GROUP* ec_group = EC_KEY_get0_group(ec_key);
-    bits = EC_GROUP_order_bits(ec_group);
+    const EC_KEY* ec_key = Thin_EVP_PKEY_get0_EC_KEY(pkey.get());
+    const EC_GROUP* ec_group = Thin_EC_KEY_get0_group(ec_key);
+    bits = Thin_EC_GROUP_order_bits(ec_group);
   } else {
     return kNoDsaSignature;
   }
@@ -142,14 +142,14 @@ bool ExtractP1363(
     unsigned char* out,
     size_t len,
     size_t n) {
-  ECDSASigPointer asn1_sig(d2i_ECDSA_SIG(nullptr, &sig_data, len));
+  ECDSASigPointer asn1_sig(Thin_d2i_ECDSA_SIG(nullptr, &sig_data, len));
   if (!asn1_sig)
     return false;
 
-  const BIGNUM* pr = ECDSA_SIG_get0_r(asn1_sig.get());
-  const BIGNUM* ps = ECDSA_SIG_get0_s(asn1_sig.get());
+  const BIGNUM* pr = Thin_ECDSA_SIG_get0_r(asn1_sig.get());
+  const BIGNUM* ps = Thin_ECDSA_SIG_get0_s(asn1_sig.get());
 
-  return BN_bn2binpad(pr, out, n) > 0 && BN_bn2binpad(ps, out + n, n) > 0;
+  return Thin_BN_bn2binpad(pr, out, n) > 0 && Thin_BN_bn2binpad(ps, out + n, n) > 0;
 }
 
 // Returns the maximum size of each of the integers (r, s) of the DSA signature.
@@ -204,18 +204,18 @@ ByteSource ConvertSignatureToDER(
   if (out.size() != 2 * n)
     return ByteSource();
 
-  ECDSASigPointer asn1_sig(ECDSA_SIG_new());
+  ECDSASigPointer asn1_sig(Thin_ECDSA_SIG_new());
   CHECK(asn1_sig);
-  BIGNUM* r = BN_new();
+  BIGNUM* r = Thin_BN_new();
   CHECK_NOT_NULL(r);
-  BIGNUM* s = BN_new();
+  BIGNUM* s = Thin_BN_new();
   CHECK_NOT_NULL(s);
-  CHECK_EQ(r, BN_bin2bn(sig_data, n, r));
-  CHECK_EQ(s, BN_bin2bn(sig_data + n, n, s));
-  CHECK_EQ(1, ECDSA_SIG_set0(asn1_sig.get(), r, s));
+  CHECK_EQ(r, Thin_BN_bin2bn(sig_data, n, r));
+  CHECK_EQ(s, Thin_BN_bin2bn(sig_data + n, n, s));
+  CHECK_EQ(1, Thin_ECDSA_SIG_set0(asn1_sig.get(), r, s));
 
   unsigned char* data = nullptr;
-  int len = i2d_ECDSA_SIG(asn1_sig.get(), &data);
+  int len = Thin_i2d_ECDSA_SIG(asn1_sig.get(), &data);
 
   if (len <= 0)
     return ByteSource();
@@ -243,7 +243,7 @@ void CheckThrow(Environment* env, SignBase::Error error) {
     case SignBase::Error::kSignPrivateKey:
     case SignBase::Error::kSignPublicKey:
       {
-        unsigned long err = ERR_get_error();  // NOLINT(runtime/int)
+        unsigned long err = Thin_ERR_get_error();  // NOLINT(runtime/int)
         if (err)
           return ThrowCryptoError(env, err);
         switch (error) {
@@ -255,7 +255,7 @@ void CheckThrow(Environment* env, SignBase::Error error) {
                 "EVP_SignUpdate failed");
           case SignBase::Error::kSignPrivateKey:
             return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
-                "PEM_read_bio_PrivateKey failed");
+                "Thin_PEM_read_bio_PrivateKey failed");
           case SignBase::Error::kSignPublicKey:
             return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
                 "PEM_read_bio_PUBKEY failed");
@@ -270,7 +270,7 @@ void CheckThrow(Environment* env, SignBase::Error error) {
 }
 
 bool IsOneShot(const ManagedEVPPKey& key) {
-  switch (EVP_PKEY_id(key.get())) {
+  switch (Thin_EVP_PKEY_id(key.get())) {
     case EVP_PKEY_ED25519:
     case EVP_PKEY_ED448:
       return true;
@@ -281,7 +281,7 @@ bool IsOneShot(const ManagedEVPPKey& key) {
 
 bool UseP1363Encoding(const ManagedEVPPKey& key,
                       const DSASigEnc& dsa_encoding) {
-  switch (EVP_PKEY_id(key.get())) {
+  switch (Thin_EVP_PKEY_id(key.get())) {
     case EVP_PKEY_EC:
     case EVP_PKEY_DSA:
       return dsa_encoding == kSigEncP1363;
@@ -297,14 +297,14 @@ SignBase::Error SignBase::Init(const char* sign_type) {
   // exposed through the public API.
   if (strcmp(sign_type, "dss1") == 0 ||
       strcmp(sign_type, "DSS1") == 0) {
-    sign_type = "SHA1";
+    sign_type = "Thin_SHA1";
   }
-  const EVP_MD* md = EVP_get_digestbyname(sign_type);
+  const EVP_MD* md = Thin_EVP_get_digestbyname(sign_type);
   if (md == nullptr)
     return kSignUnknownDigest;
 
-  mdctx_.reset(EVP_MD_CTX_new());
-  if (!mdctx_ || !EVP_DigestInit_ex(mdctx_.get(), md, nullptr)) {
+  mdctx_.reset(Thin_EVP_MD_CTX_new());
+  if (!mdctx_ || !Thin_EVP_DigestInit_ex(mdctx_.get(), md, nullptr)) {
     mdctx_.reset();
     return kSignInit;
   }
@@ -315,7 +315,7 @@ SignBase::Error SignBase::Init(const char* sign_type) {
 SignBase::Error SignBase::Update(const char* data, size_t len) {
   if (mdctx_ == nullptr)
     return kSignNotInitialised;
-  if (!EVP_DigestUpdate(mdctx_.get(), data, len))
+  if (!Thin_EVP_DigestUpdate(mdctx_.get(), data, len))
     return kSignUpdate;
   return kSignOk;
 }
@@ -523,17 +523,17 @@ SignBase::Error Verify::VerifyFinal(const ManagedEVPPKey& pkey,
   *verify_result = false;
   EVPMDCtxPointer mdctx = std::move(mdctx_);
 
-  if (!EVP_DigestFinal_ex(mdctx.get(), m, &m_len))
+  if (!Thin_EVP_DigestFinal_ex(mdctx.get(), m, &m_len))
     return kSignPublicKey;
 
-  EVPKeyCtxPointer pkctx(EVP_PKEY_CTX_new(pkey.get(), nullptr));
+  EVPKeyCtxPointer pkctx(Thin_EVP_PKEY_CTX_new(pkey.get(), nullptr));
   if (pkctx &&
-      EVP_PKEY_verify_init(pkctx.get()) > 0 &&
+      Thin_EVP_PKEY_verify_init(pkctx.get()) > 0 &&
       ApplyRSAOptions(pkey, pkctx.get(), padding, saltlen) &&
-      EVP_PKEY_CTX_set_signature_md(pkctx.get(),
-                                    EVP_MD_CTX_md(mdctx.get())) > 0) {
+      Thin_EVP_PKEY_CTX_set_signature_md(pkctx.get(),
+                                    Thin_EVP_MD_CTX_md(mdctx.get())) > 0) {
     const unsigned char* s = sig.data<unsigned char>();
-    const int r = EVP_PKEY_verify(pkctx.get(), s, sig.size(), m, m_len);
+    const int r = Thin_EVP_PKEY_verify(pkctx.get(), s, sig.size(), m, m_len);
     *verify_result = r == 1;
   }
 
@@ -657,7 +657,7 @@ Maybe<bool> SignTraits::AdditionalConfig(
 
   if (args[offset + 6]->IsString()) {
     Utf8Value digest(env->isolate(), args[offset + 6]);
-    params->digest = EVP_get_digestbyname(*digest);
+    params->digest = Thin_EVP_get_digestbyname(*digest);
     if (params->digest == nullptr) {
       THROW_ERR_CRYPTO_INVALID_DIGEST(env, "Invalid digest: %s", *digest);
       return Nothing<bool>();
@@ -711,12 +711,12 @@ bool SignTraits::DeriveBits(
     const SignConfiguration& params,
     ByteSource* out) {
   ClearErrorOnReturn clear_error_on_return;
-  EVPMDCtxPointer context(EVP_MD_CTX_new());
+  EVPMDCtxPointer context(Thin_EVP_MD_CTX_new());
   EVP_PKEY_CTX* ctx = nullptr;
 
   switch (params.mode) {
     case SignConfiguration::kSign:
-      if (!EVP_DigestSignInit(
+      if (!Thin_EVP_DigestSignInit(
               context.get(),
               &ctx,
               params.digest,
@@ -727,7 +727,7 @@ bool SignTraits::DeriveBits(
       }
       break;
     case SignConfiguration::kVerify:
-      if (!EVP_DigestVerifyInit(
+      if (!Thin_EVP_DigestVerifyInit(
               context.get(),
               &ctx,
               params.digest,
@@ -759,7 +759,7 @@ bool SignTraits::DeriveBits(
     case SignConfiguration::kSign: {
       if (IsOneShot(params.key)) {
         size_t len;
-        if (!EVP_DigestSign(
+        if (!Thin_EVP_DigestSign(
             context.get(),
             nullptr,
             &len,
@@ -769,7 +769,7 @@ bool SignTraits::DeriveBits(
           return false;
         }
         ByteSource::Builder buf(len);
-        if (!EVP_DigestSign(context.get(),
+        if (!Thin_EVP_DigestSign(context.get(),
                             buf.data<unsigned char>(),
                             &len,
                             params.data.data<unsigned char>(),
@@ -780,16 +780,16 @@ bool SignTraits::DeriveBits(
         *out = std::move(buf).release(len);
       } else {
         size_t len;
-        if (!EVP_DigestSignUpdate(
+        if (!Thin_EVP_DigestSignUpdate(
                 context.get(),
                 params.data.data<unsigned char>(),
                 params.data.size()) ||
-            !EVP_DigestSignFinal(context.get(), nullptr, &len)) {
+            !Thin_EVP_DigestSignFinal(context.get(), nullptr, &len)) {
           crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
           return false;
         }
         ByteSource::Builder buf(len);
-        if (!EVP_DigestSignFinal(
+        if (!Thin_EVP_DigestSignFinal(
                 context.get(), buf.data<unsigned char>(), &len)) {
           crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
           return false;
@@ -807,7 +807,7 @@ bool SignTraits::DeriveBits(
     case SignConfiguration::kVerify: {
       ByteSource::Builder buf(1);
       buf.data<char>()[0] = 0;
-      if (EVP_DigestVerify(
+      if (Thin_EVP_DigestVerify(
               context.get(),
               params.signature.data<unsigned char>(),
               params.signature.size(),
diff --git a/src/crypto/crypto_spkac.cc b/src/crypto/crypto_spkac.cc
index 92484847af..36478a1808 100644
--- a/src/crypto/crypto_spkac.cc
+++ b/src/crypto/crypto_spkac.cc
@@ -18,22 +18,17 @@ namespace crypto {
 namespace SPKAC {
 bool VerifySpkac(const ArrayBufferOrViewContents<char>& input) {
   size_t length = input.size();
-#ifdef OPENSSL_IS_BORINGSSL
-  // OpenSSL uses EVP_DecodeBlock, which explicitly removes trailing characters,
-  // while BoringSSL uses EVP_DecodedLength and EVP_DecodeBase64, which do not.
-  // As such, we trim those characters here for compatibility.
-  length = std::string(input.data()).find_last_not_of(" \n\r\t") + 1;
-#endif
+
   NetscapeSPKIPointer spki(
-      NETSCAPE_SPKI_b64_decode(input.data(), length));
+      Thin_NETSCAPE_SPKI_b64_decode(input.data(), length));
   if (!spki)
     return false;
 
-  EVPKeyPointer pkey(X509_PUBKEY_get(spki->spkac->pubkey));
+  EVPKeyPointer pkey(Thin_X509_PUBKEY_get(spki->spkac->pubkey));
   if (!pkey)
     return false;
 
-  return NETSCAPE_SPKI_verify(spki.get(), pkey.get()) > 0;
+  return Thin_NETSCAPE_SPKI_verify(spki.get(), pkey.get()) > 0;
 }
 
 void VerifySpkac(const FunctionCallbackInfo<Value>& args) {
@@ -50,24 +45,19 @@ void VerifySpkac(const FunctionCallbackInfo<Value>& args) {
 
 ByteSource ExportPublicKey(Environment* env,
                            const ArrayBufferOrViewContents<char>& input) {
-  BIOPointer bio(BIO_new(BIO_s_mem()));
+  BIOPointer bio(Thin_BIO_new(Thin_BIO_s_mem()));
   if (!bio) return ByteSource();
 
   size_t length = input.size();
-#ifdef OPENSSL_IS_BORINGSSL
-  // OpenSSL uses EVP_DecodeBlock, which explicitly removes trailing characters,
-  // while BoringSSL uses EVP_DecodedLength and EVP_DecodeBase64, which do not.
-  // As such, we trim those characters here for compatibility.
-  length = std::string(input.data()).find_last_not_of(" \n\r\t") + 1;
-#endif
+
   NetscapeSPKIPointer spki(
-      NETSCAPE_SPKI_b64_decode(input.data(), length));
+      Thin_NETSCAPE_SPKI_b64_decode(input.data(), length));
   if (!spki) return ByteSource();
 
-  EVPKeyPointer pkey(NETSCAPE_SPKI_get_pubkey(spki.get()));
+  EVPKeyPointer pkey(Thin_NETSCAPE_SPKI_get_pubkey(spki.get()));
   if (!pkey) return ByteSource();
 
-  if (PEM_write_bio_PUBKEY(bio.get(), pkey.get()) <= 0) return ByteSource();
+  if (Thin_PEM_write_bio_PUBKEY(bio.get(), pkey.get()) <= 0) return ByteSource();
 
   return ByteSource::FromBIO(bio);
 }
@@ -89,19 +79,13 @@ void ExportPublicKey(const FunctionCallbackInfo<Value>& args) {
 
 ByteSource ExportChallenge(const ArrayBufferOrViewContents<char>& input) {
   size_t length = input.size();
-#ifdef OPENSSL_IS_BORINGSSL
-  // OpenSSL uses EVP_DecodeBlock, which explicitly removes trailing characters,
-  // while BoringSSL uses EVP_DecodedLength and EVP_DecodeBase64, which do not.
-  // As such, we trim those characters here for compatibility.
-  length = std::string(input.data()).find_last_not_of(" \n\r\t") + 1;
-#endif
   NetscapeSPKIPointer sp(
-      NETSCAPE_SPKI_b64_decode(input.data(), length));
+      Thin_NETSCAPE_SPKI_b64_decode(input.data(), length));
   if (!sp)
     return ByteSource();
 
   unsigned char* buf = nullptr;
-  int buf_size = ASN1_STRING_to_UTF8(&buf, sp->spkac->challenge);
+  int buf_size = Thin_ASN1_STRING_to_UTF8(&buf, sp->spkac->challenge);
   return (buf_size >= 0) ? ByteSource::Allocated(buf, buf_size) : ByteSource();
 }
 
diff --git a/src/crypto/crypto_spkac.h b/src/crypto/crypto_spkac.h
index bdd9f6b35c..a1b50f4a0b 100644
--- a/src/crypto/crypto_spkac.h
+++ b/src/crypto/crypto_spkac.h
@@ -6,7 +6,7 @@
 #include "env.h"
 #include "v8.h"
 
-#include <openssl/evp.h>
+// #include <openssl/evp.h>
 
 namespace node {
 namespace crypto {
diff --git a/src/crypto/crypto_timing.cc b/src/crypto/crypto_timing.cc
index 103a620d63..793d726ae3 100644
--- a/src/crypto/crypto_timing.cc
+++ b/src/crypto/crypto_timing.cc
@@ -5,7 +5,7 @@
 #include "v8.h"
 #include "node.h"
 
-#include <openssl/crypto.h>
+// #include <openssl/crypto.h>
 
 namespace node {
 
@@ -45,7 +45,7 @@ void TimingSafeEqual(const FunctionCallbackInfo<Value>& args) {
   }
 
   return args.GetReturnValue().Set(
-      CRYPTO_memcmp(buf1.data(), buf2.data(), buf1.size()) == 0);
+      Thin_CRYPTO_memcmp(buf1.data(), buf2.data(), buf1.size()) == 0);
 }
 
 bool FastTimingSafeEqual(Local<Value> receiver,
@@ -61,7 +61,7 @@ bool FastTimingSafeEqual(Local<Value> receiver,
     return false;
   }
 
-  return CRYPTO_memcmp(data_a, data_b, a.length()) == 0;
+  return Thin_CRYPTO_memcmp(data_a, data_b, a.length()) == 0;
 }
 
 static v8::CFunction fast_equal(v8::CFunction::Make(FastTimingSafeEqual));
diff --git a/src/crypto/crypto_tls.cc b/src/crypto/crypto_tls.cc
index ad99ae2e68..6e764b45cf 100644
--- a/src/crypto/crypto_tls.cc
+++ b/src/crypto/crypto_tls.cc
@@ -70,7 +70,7 @@ SSL_SESSION* GetSessionCallback(
     const unsigned char* key,
     int len,
     int* copy) {
-  TLSWrap* w = static_cast<TLSWrap*>(SSL_get_app_data(s));
+  TLSWrap* w = static_cast<TLSWrap*>(Thin_SSL_get_app_data(s));
   *copy = 0;
   return w->ReleaseSession();
 }
@@ -113,7 +113,7 @@ void OnClientHello(
 }
 
 void KeylogCallback(const SSL* s, const char* line) {
-  TLSWrap* w = static_cast<TLSWrap*>(SSL_get_app_data(s));
+  TLSWrap* w = static_cast<TLSWrap*>(Thin_SSL_get_app_data(s));
   Environment* env = w->env();
   HandleScope handle_scope(env->isolate());
   Context::Scope context_scope(env->context());
@@ -130,7 +130,7 @@ void KeylogCallback(const SSL* s, const char* line) {
 }
 
 int NewSessionCallback(SSL* s, SSL_SESSION* sess) {
-  TLSWrap* w = static_cast<TLSWrap*>(SSL_get_app_data(s));
+  TLSWrap* w = static_cast<TLSWrap*>(Thin_SSL_get_app_data(s));
   Environment* env = w->env();
   HandleScope handle_scope(env->isolate());
   Context::Scope context_scope(env->context());
@@ -139,7 +139,7 @@ int NewSessionCallback(SSL* s, SSL_SESSION* sess) {
     return 0;
 
   // Check if session is small enough to be stored
-  int size = i2d_SSL_SESSION(sess, nullptr);
+  int size = Thin_i2d_SSL_SESSION(sess, nullptr);
   if (UNLIKELY(size > SecureContext::kMaxSessionSize))
     return 0;
 
@@ -151,11 +151,11 @@ int NewSessionCallback(SSL* s, SSL_SESSION* sess) {
   unsigned char* session_data =
       reinterpret_cast<unsigned char*>(Buffer::Data(session));
 
-  CHECK_EQ(i2d_SSL_SESSION(sess, &session_data), size);
+  CHECK_EQ(Thin_i2d_SSL_SESSION(sess, &session_data), size);
 
   unsigned int session_id_length;
   const unsigned char* session_id_data =
-      SSL_SESSION_get_id(sess, &session_id_length);
+      Thin_SSL_SESSION_get_id(sess, &session_id_length);
 
   Local<Object> session_id = Buffer::Copy(
       env,
@@ -180,7 +180,7 @@ int NewSessionCallback(SSL* s, SSL_SESSION* sess) {
 }
 
 int SSLCertCallback(SSL* s, void* arg) {
-  TLSWrap* w = static_cast<TLSWrap*>(SSL_get_app_data(s));
+  TLSWrap* w = static_cast<TLSWrap*>(Thin_SSL_get_app_data(s));
 
   if (!w->is_server() || !w->is_waiting_cert_cb())
     return 1;
@@ -203,7 +203,7 @@ int SSLCertCallback(SSL* s, void* arg) {
       : OneByteString(env->isolate(), servername, strlen(servername));
 
   Local<Value> ocsp = Boolean::New(
-      env->isolate(), SSL_get_tlsext_status_type(s) == TLSEXT_STATUSTYPE_ocsp);
+      env->isolate(), Thin_SSL_get_tlsext_status_type(s) == TLSEXT_STATUSTYPE_ocsp);
 
   if (info->Set(env->context(), env->servername_string(), servername_str)
           .IsNothing() ||
@@ -224,7 +224,7 @@ int SelectALPNCallback(
     const unsigned char* in,
     unsigned int inlen,
     void* arg) {
-  TLSWrap* w = static_cast<TLSWrap*>(SSL_get_app_data(s));
+  TLSWrap* w = static_cast<TLSWrap*>(Thin_SSL_get_app_data(s));
   if (w->alpn_callback_enabled_) {
     Environment* env = w->env();
     HandleScope handle_scope(env->isolate());
@@ -267,7 +267,7 @@ int SelectALPNCallback(
 
   if (alpn_protos.empty()) return SSL_TLSEXT_ERR_NOACK;
 
-  int status = SSL_select_next_proto(const_cast<unsigned char**>(out),
+  int status = Thin_SSL_select_next_proto(const_cast<unsigned char**>(out),
                                      outlen,
                                      alpn_protos.data(),
                                      alpn_protos.size(),
@@ -284,7 +284,7 @@ int SelectALPNCallback(
 }
 
 int TLSExtStatusCallback(SSL* s, void* arg) {
-  TLSWrap* w = static_cast<TLSWrap*>(SSL_get_app_data(s));
+  TLSWrap* w = static_cast<TLSWrap*>(Thin_SSL_get_app_data(s));
   Environment* env = w->env();
   HandleScope handle_scope(env->isolate());
 
@@ -313,8 +313,8 @@ int TLSExtStatusCallback(SSL* s, void* arg) {
   unsigned char* data = MallocOpenSSL<unsigned char>(len);
   obj->CopyContents(data, len);
 
-  if (!SSL_set_tlsext_status_ocsp_resp(s, data, len))
-    OPENSSL_free(data);
+  if (!Thin_SSL_set_tlsext_status_ocsp_resp(s, data, len))
+    Thin_OPENSSL_free(data);
 
   w->ClearOcspResponse();
 
@@ -323,8 +323,8 @@ int TLSExtStatusCallback(SSL* s, void* arg) {
 
 void ConfigureSecureContext(SecureContext* sc) {
   // OCSP stapling
-  SSL_CTX_set_tlsext_status_cb(sc->ctx().get(), TLSExtStatusCallback);
-  SSL_CTX_set_tlsext_status_arg(sc->ctx().get(), nullptr);
+  Thin_SSL_CTX_set_tlsext_status_cb(sc->ctx().get(), TLSExtStatusCallback);
+  Thin_SSL_CTX_set_tlsext_status_arg(sc->ctx().get(), nullptr);
 }
 
 inline bool Set(
@@ -344,7 +344,7 @@ inline bool Set(
 
 std::string GetBIOError() {
   std::string ret;
-  ERR_print_errors_cb(
+  Thin_ERR_print_errors_cb(
       [](const char* str, size_t len, void* opaque) {
         static_cast<std::string*>(opaque)->assign(str, len);
         return 0;
@@ -425,34 +425,28 @@ void TLSWrap::InitSSL() {
   enc_in_ = NodeBIO::New(env()).release();
   enc_out_ = NodeBIO::New(env()).release();
 
-  SSL_set_bio(ssl_.get(), enc_in_, enc_out_);
+  Thin_SSL_set_bio(ssl_.get(), enc_in_, enc_out_);
 
   // NOTE: This could be overridden in SetVerifyMode
-  SSL_set_verify(ssl_.get(), SSL_VERIFY_NONE, VerifyCallback);
+  Thin_SSL_set_verify(ssl_.get(), SSL_VERIFY_NONE, VerifyCallback);
 
 #ifdef SSL_MODE_RELEASE_BUFFERS
-  SSL_set_mode(ssl_.get(), SSL_MODE_RELEASE_BUFFERS);
+  Thin_SSL_set_mode(ssl_.get(), SSL_MODE_RELEASE_BUFFERS);
 #endif  // SSL_MODE_RELEASE_BUFFERS
 
   // This is default in 1.1.1, but set it anyway, Cycle() doesn't currently
-  // re-call ClearIn() if SSL_read() returns SSL_ERROR_WANT_READ, so data can be
+  // re-call ClearIn() if Thin_SSL_read() returns SSL_ERROR_WANT_READ, so data can be
   // left sitting in the incoming enc_in_ and never get processed.
   // - https://wiki.openssl.org/index.php/TLS1.3#Non-application_data_records
-  SSL_set_mode(ssl_.get(), SSL_MODE_AUTO_RETRY);
+  Thin_SSL_set_mode(ssl_.get(), SSL_MODE_AUTO_RETRY);
 
-#ifdef OPENSSL_IS_BORINGSSL
-  // OpenSSL allows renegotiation by default, but BoringSSL disables it.
-  // Configure BoringSSL to match OpenSSL's behavior.
-  SSL_set_renegotiate_mode(ssl_.get(), ssl_renegotiate_freely);
-#endif
-
-  SSL_set_app_data(ssl_.get(), this);
+  Thin_SSL_set_app_data(ssl_.get(), this);
   // Using InfoCallback isn't how we are supposed to check handshake progress:
   //   https://github.com/openssl/openssl/issues/7199#issuecomment-420915993
   //
   // Note on when this gets called on various openssl versions:
   //   https://github.com/openssl/openssl/issues/7199#issuecomment-420670544
-  SSL_set_info_callback(ssl_.get(), SSLInfoCallback);
+  Thin_SSL_set_info_callback(ssl_.get(), SSLInfoCallback);
 
   if (is_server())
     sc_->SetSelectSNIContextCallback(SelectSNIContextCallback);
@@ -462,14 +456,14 @@ void TLSWrap::InitSSL() {
   }
   ConfigureSecureContext(sc_.get());
 
-  SSL_set_cert_cb(ssl_.get(), SSLCertCallback, this);
+  Thin_SSL_set_cert_cb(ssl_.get(), SSLCertCallback, this);
 
   if (is_server()) {
-    SSL_set_accept_state(ssl_.get());
+    Thin_SSL_set_accept_state(ssl_.get());
   } else if (is_client()) {
     // Enough space for server response (hello, cert)
     NodeBIO::FromBIO(enc_in_)->set_initial(kInitialClientBufferLength);
-    SSL_set_connect_state(ssl_.get());
+    Thin_SSL_set_connect_state(ssl_.get());
   } else {
     // Unexpected
     ABORT();
@@ -539,7 +533,7 @@ void TLSWrap::Start(const FunctionCallbackInfo<Value>& args) {
 
   // Send ClientHello handshake
   CHECK(wrap->is_client());
-  // Seems odd to read when when we want to send, but SSL_read() triggers a
+  // Seems odd to read when when we want to send, but Thin_SSL_read() triggers a
   // handshake if a session isn't established, and handshake will cause
   // encrypted data to become available for output.
   wrap->ClearOut();
@@ -550,9 +544,9 @@ void TLSWrap::SSLInfoCallback(const SSL* ssl_, int where, int ret) {
   if (!(where & (SSL_CB_HANDSHAKE_START | SSL_CB_HANDSHAKE_DONE)))
     return;
 
-  // SSL_renegotiate_pending() should take `const SSL*`, but it does not.
+  // Thin_SSL_renegotiate_pending() should take `const SSL*`, but it does not.
   SSL* ssl = const_cast<SSL*>(ssl_);
-  TLSWrap* c = static_cast<TLSWrap*>(SSL_get_app_data(ssl_));
+  TLSWrap* c = static_cast<TLSWrap*>(Thin_SSL_get_app_data(ssl_));
   Environment* env = c->env();
   HandleScope handle_scope(env->isolate());
   Context::Scope context_scope(env->context());
@@ -574,9 +568,9 @@ void TLSWrap::SSLInfoCallback(const SSL* ssl_, int where, int ret) {
   // SSL_CB_HANDSHAKE_START and SSL_CB_HANDSHAKE_DONE are called
   // sending HelloRequest in OpenSSL-1.1.1.
   // We need to check whether this is in a renegotiation state or not.
-  if (where & SSL_CB_HANDSHAKE_DONE && !SSL_renegotiate_pending(ssl)) {
+  if (where & SSL_CB_HANDSHAKE_DONE && !Thin_SSL_renegotiate_pending(ssl)) {
     Debug(c, "SSLInfoCallback(SSL_CB_HANDSHAKE_DONE);");
-    CHECK(!SSL_renegotiate_pending(ssl));
+    CHECK(!Thin_SSL_renegotiate_pending(ssl));
     Local<Value> callback;
 
     c->established_ = true;
@@ -628,7 +622,7 @@ void TLSWrap::EncOut() {
   }
 
   // No encrypted output ready to write to the underlying stream.
-  if (BIO_pending(enc_out_) == 0) {
+  if (Thin_BIO_pending(enc_out_) == 0) {
     Debug(this, "No pending encrypted output");
     if (!pending_cleartext_input_ ||
         pending_cleartext_input_->ByteLength() == 0) {
@@ -638,7 +632,7 @@ void TLSWrap::EncOut() {
       } else {
         Debug(this, "No pending cleartext input, inside DoWrite()");
         // TODO(@sam-github, @addaleax) If in_dowrite_ is true, appdata was
-        // passed to SSL_write().  If we are here, the data was not encrypted to
+        // passed to Thin_SSL_write().  If we are here, the data was not encrypted to
         // enc_out_ yet.  Calling Done() "works", but since the write is not
         // flushed, its too soon.  Just returning and letting the next EncOut()
         // call Done() passes the test suite, but without more careful analysis,
@@ -757,7 +751,7 @@ void TLSWrap::ClearOut() {
   char out[kClearOutChunkSize];
   int read;
   for (;;) {
-    read = SSL_read(ssl_.get(), out, sizeof(out));
+    read = Thin_SSL_read(ssl_.get(), out, sizeof(out));
     Debug(this, "Read %d bytes of cleartext output", read);
 
     if (read <= 0)
@@ -788,14 +782,14 @@ void TLSWrap::ClearOut() {
 
   // We need to check whether an error occurred or the connection was
   // shutdown cleanly (SSL_ERROR_ZERO_RETURN) even when read == 0.
-  // See node#1642 and SSL_read(3SSL) for details. SSL_get_error must be
-  // called immediately after SSL_read, without calling into JS, which may
+  // See node#1642 and Thin_SSL_read(3SSL) for details. Thin_SSL_get_error must be
+  // called immediately after Thin_SSL_read, without calling into JS, which may
   // change OpenSSL's error queue, modify ssl_, or even destroy ssl_
   // altogether.
   if (read <= 0) {
     HandleScope handle_scope(env()->isolate());
     Local<Value> error;
-    int err = SSL_get_error(ssl_.get(), read);
+    int err = Thin_SSL_get_error(ssl_.get(), read);
     switch (err) {
       case SSL_ERROR_ZERO_RETURN:
       case SSL_ERROR_WANT_X509_LOOKUP:
@@ -808,7 +802,7 @@ void TLSWrap::ClearOut() {
       case SSL_ERROR_SSL:
       case SSL_ERROR_SYSCALL:
         {
-          unsigned long ssl_err = ERR_peek_error();  // NOLINT(runtime/int)
+          unsigned long ssl_err = Thin_ERR_peek_error();  // NOLINT(runtime/int)
 
           Local<Context> context = env()->isolate()->GetCurrentContext();
           if (UNLIKELY(context.IsEmpty())) return;
@@ -821,9 +815,9 @@ void TLSWrap::ClearOut() {
           Local<Object> obj;
           if (UNLIKELY(!error->ToObject(context).ToLocal(&obj))) return;
 
-          const char* ls = ERR_lib_error_string(ssl_err);
-          const char* fs = ERR_func_error_string(ssl_err);
-          const char* rs = ERR_reason_error_string(ssl_err);
+          const char* ls = Thin_ERR_lib_error_string(ssl_err);
+          const char* fs = Thin_ERR_func_error_string(ssl_err);
+          const char* rs = Thin_ERR_reason_error_string(ssl_err);
           if (!Set(env(), obj, env()->library_string(), ls) ||
               !Set(env(), obj, env()->function_string(), fs) ||
               !Set(env(), obj, env()->reason_string(), rs, false)) return;
@@ -850,7 +844,7 @@ void TLSWrap::ClearOut() {
     Debug(this, "Got SSL error (%d), calling onerror", err);
     // When TLS Alert are stored in wbio,
     // it should be flushed to socket before destroyed.
-    if (BIO_pending(enc_out_) != 0)
+    if (Thin_BIO_pending(enc_out_) != 0)
       EncOut();
 
     MakeCallback(env()->onerror_string(), 1, &error);
@@ -880,7 +874,7 @@ void TLSWrap::ClearIn() {
   MarkPopErrorOnReturn mark_pop_error_on_return;
 
   NodeBIO::FromBIO(enc_out_)->set_allocate_tls_hint(bs->ByteLength());
-  int written = SSL_write(ssl_.get(), bs->Data(), bs->ByteLength());
+  int written = Thin_SSL_write(ssl_.get(), bs->Data(), bs->ByteLength());
   Debug(this, "Writing %zu bytes, written = %d", bs->ByteLength(), written);
   CHECK(written == -1 || written == static_cast<int>(bs->ByteLength()));
 
@@ -891,7 +885,7 @@ void TLSWrap::ClearIn() {
   }
 
   // Error or partial write
-  int err = SSL_get_error(ssl_.get(), written);
+  int err = Thin_SSL_get_error(ssl_.get(), written);
   if (err == SSL_ERROR_SSL || err == SSL_ERROR_SYSCALL) {
     Debug(this, "Got SSL error (%d)", err);
     write_callback_scheduled_ = true;
@@ -986,7 +980,7 @@ int TLSWrap::DoWrite(WriteWrap* w,
   // We want to trigger a Write() on the underlying stream to drive the stream
   // system, but don't want to encrypt empty buffers into a TLS frame, so see
   // if we can find something to Write().
-  // First, call ClearOut(). It does an SSL_read(), which might cause handshake
+  // First, call ClearOut(). It does an Thin_SSL_read(), which might cause handshake
   // or other internal messages to be encrypted. If it does, write them later
   // with EncOut().
   // If there is still no encrypted output, call Write(bufs) on the underlying
@@ -996,7 +990,7 @@ int TLSWrap::DoWrite(WriteWrap* w,
   if (length == 0) {
     Debug(this, "Empty write");
     ClearOut();
-    if (BIO_pending(enc_out_) == 0) {
+    if (Thin_BIO_pending(enc_out_) == 0) {
       Debug(this, "No pending encrypted output, writing to underlying stream");
       CHECK(!current_empty_write_);
       current_empty_write_.reset(w->GetAsyncWrap());
@@ -1048,12 +1042,12 @@ int TLSWrap::DoWrite(WriteWrap* w,
     }
 
     NodeBIO::FromBIO(enc_out_)->set_allocate_tls_hint(length);
-    written = SSL_write(ssl_.get(), bs->Data(), length);
+    written = Thin_SSL_write(ssl_.get(), bs->Data(), length);
   } else {
     // Only one buffer: try to write directly, only store if it fails
     uv_buf_t* buf = &bufs[nonempty_i];
     NodeBIO::FromBIO(enc_out_)->set_allocate_tls_hint(buf->len);
-    written = SSL_write(ssl_.get(), buf->base, buf->len);
+    written = Thin_SSL_write(ssl_.get(), buf->base, buf->len);
 
     if (written == -1) {
       NoArrayBufferZeroFillScope no_zero_fill_scope(env()->isolate_data());
@@ -1067,7 +1061,7 @@ int TLSWrap::DoWrite(WriteWrap* w,
 
   if (written == -1) {
     // If we stopped writing because of an error, it's fatal, discard the data.
-    int err = SSL_get_error(ssl_.get(), written);
+    int err = Thin_SSL_get_error(ssl_.get(), written);
     if (err == SSL_ERROR_SSL || err == SSL_ERROR_SYSCALL) {
       // TODO(@jasnell): What are we doing with the error?
       Debug(this, "Got SSL error (%d), returning UV_EPROTO", err);
@@ -1153,8 +1147,8 @@ int TLSWrap::DoShutdown(ShutdownWrap* req_wrap) {
   Debug(this, "DoShutdown()");
   MarkPopErrorOnReturn mark_pop_error_on_return;
 
-  if (ssl_ && SSL_shutdown(ssl_.get()) == 0)
-    SSL_shutdown(ssl_.get());
+  if (ssl_ && Thin_SSL_shutdown(ssl_.get()) == 0)
+    Thin_SSL_shutdown(ssl_.get());
 
   shutdown_ = true;
   EncOut();
@@ -1190,7 +1184,7 @@ void TLSWrap::SetVerifyMode(const FunctionCallbackInfo<Value>& args) {
   }
 
   // Always allow a connection. We'll reject in javascript.
-  SSL_set_verify(wrap->ssl_.get(), verify_mode, VerifyCallback);
+  Thin_SSL_set_verify(wrap->ssl_.get(), verify_mode, VerifyCallback);
 }
 
 void TLSWrap::EnableSessionCallbacks(const FunctionCallbackInfo<Value>& args) {
@@ -1217,8 +1211,8 @@ void TLSWrap::EnableKeylogCallback(const FunctionCallbackInfo<Value>& args) {
 }
 
 // Check required capabilities were not excluded from the OpenSSL build:
-// - OPENSSL_NO_SSL_TRACE excludes SSL_trace()
-// - OPENSSL_NO_STDIO excludes BIO_new_fp()
+// - OPENSSL_NO_SSL_TRACE excludes Thin_SSL_trace()
+// - OPENSSL_NO_STDIO excludes Thin_BIO_new_fp()
 // HAVE_SSL_TRACE is available on the internal tcp_wrap binding for the tests.
 #if defined(OPENSSL_NO_SSL_TRACE) || defined(OPENSSL_NO_STDIO)
 # define HAVE_SSL_TRACE 0
@@ -1232,19 +1226,19 @@ void TLSWrap::EnableTrace(const FunctionCallbackInfo<Value>& args) {
 
 #if HAVE_SSL_TRACE
   if (wrap->ssl_) {
-    wrap->bio_trace_.reset(BIO_new_fp(stderr,  BIO_NOCLOSE | BIO_FP_TEXT));
-    SSL_set_msg_callback(wrap->ssl_.get(), [](int write_p, int version, int
+    wrap->bio_trace_.reset(Thin_BIO_new_fp(stderr,  BIO_NOCLOSE | BIO_FP_TEXT));
+    Thin_SSL_set_msg_callback(wrap->ssl_.get(), [](int write_p, int version, int
           content_type, const void* buf, size_t len, SSL* ssl, void* arg)
         -> void {
-        // BIO_write(), etc., called by SSL_trace, may error. The error should
+        // Thin_BIO_write(), etc., called by Thin_SSL_trace, may error. The error should
         // be ignored, trace is a "best effort", and its usually because stderr
         // is a non-blocking pipe, and its buffer has overflowed. Leaving errors
         // on the stack that can get picked up by later SSL_ calls causes
         // unwanted failures in SSL_ calls, so keep the error stack unchanged.
         MarkPopErrorOnReturn mark_pop_error_on_return;
-        SSL_trace(write_p,  version, content_type, buf, len, ssl, arg);
+        Thin_SSL_trace(write_p,  version, content_type, buf, len, ssl, arg);
     });
-    SSL_set_msg_callback_arg(wrap->ssl_.get(), wrap->bio_trace_.get());
+    Thin_SSL_set_msg_callback_arg(wrap->ssl_.get(), wrap->bio_trace_.get());
   }
 #endif
 }
@@ -1301,8 +1295,8 @@ void TLSWrap::EnableALPNCb(const FunctionCallbackInfo<Value>& args) {
   wrap->alpn_callback_enabled_ = true;
 
   SSL* ssl = wrap->ssl_.get();
-  SSL_CTX* ssl_ctx = SSL_get_SSL_CTX(ssl);
-  SSL_CTX_set_alpn_select_cb(ssl_ctx, SelectALPNCallback, nullptr);
+  SSL_CTX* ssl_ctx = Thin_SSL_get_SSL_CTX(ssl);
+  Thin_SSL_CTX_set_alpn_select_cb(ssl_ctx, SelectALPNCallback, nullptr);
 }
 
 void TLSWrap::GetServername(const FunctionCallbackInfo<Value>& args) {
@@ -1335,11 +1329,11 @@ void TLSWrap::SetServername(const FunctionCallbackInfo<Value>& args) {
   CHECK(wrap->ssl_);
 
   Utf8Value servername(env->isolate(), args[0].As<String>());
-  SSL_set_tlsext_host_name(wrap->ssl_.get(), *servername);
+  Thin_SSL_set_tlsext_host_name(wrap->ssl_.get(), *servername);
 }
 
 int TLSWrap::SelectSNIContextCallback(SSL* s, int* ad, void* arg) {
-  TLSWrap* p = static_cast<TLSWrap*>(SSL_get_app_data(s));
+  TLSWrap* p = static_cast<TLSWrap*>(Thin_SSL_get_app_data(s));
   Environment* env = p->env();
   HandleScope handle_scope(env->isolate());
   Context::Scope context_scope(env->context());
@@ -1366,14 +1360,14 @@ int TLSWrap::SelectSNIContextCallback(SSL* s, int* ad, void* arg) {
   p->sni_context_ = BaseObjectPtr<SecureContext>(sc);
 
   ConfigureSecureContext(sc);
-  CHECK_EQ(SSL_set_SSL_CTX(p->ssl_.get(), sc->ctx().get()), sc->ctx().get());
+  CHECK_EQ(Thin_SSL_set_SSL_CTX(p->ssl_.get(), sc->ctx().get()), sc->ctx().get());
   p->SetCACerts(sc);
 
   return SSL_TLSEXT_ERR_OK;
 }
 
 int TLSWrap::SelectClientCertCallback(SSL* s, X509 **cert, EVP_PKEY ** key) {
-  TLSWrap* p = static_cast<TLSWrap*>(SSL_get_app_data(s));
+  TLSWrap* p = static_cast<TLSWrap*>(Thin_SSL_get_app_data(s));
   if (!p->is_client())
     return 0;
 
@@ -1389,12 +1383,12 @@ int TLSWrap::SelectClientCertCallback(SSL* s, X509 **cert, EVP_PKEY ** key) {
 
   Local<Array> distinguishedNames = Array::New(env->isolate());
   char buf[BUFSIZ];
-  STACK_OF(X509_NAME) * sk = SSL_get_client_CA_list(s);
+  STACK_OF(X509_NAME) * sk = Thin_SSL_get_client_CA_list(s);
   X509_NAME *name;
-  if (sk != NULL && (sk_X509_NAME_num(sk) > 0)) {
-    for (int i = 0; i < sk_X509_NAME_num(sk); i++) {
-      name = sk_X509_NAME_value(sk, i);
-      X509_NAME_oneline(name, buf, sizeof(buf));
+  if (sk != NULL && (Thin_sk_X509_NAME_num(sk) > 0)) {
+    for (int i = 0; i < Thin_sk_X509_NAME_num(sk); i++) {
+      name = Thin_sk_X509_NAME_value(sk, i);
+      Thin_X509_NAME_oneline(name, buf, sizeof(buf));
       distinguishedNames->Set(env->context(), i, OneByteString(env->isolate(), buf)).Check();
     }
   }
@@ -1411,16 +1405,16 @@ int TLSWrap::SelectClientCertCallback(SSL* s, X509 **cert, EVP_PKEY ** key) {
 }
 
 int TLSWrap::SetCACerts(SecureContext* sc) {
-  int err = SSL_set1_verify_cert_store(ssl_.get(),
-                                       SSL_CTX_get_cert_store(sc->ctx().get()));
+  int err = Thin_SSL_set1_verify_cert_store(ssl_.get(),
+                                       Thin_SSL_CTX_get_cert_store(sc->ctx().get()));
   if (err != 1)
     return err;
 
   STACK_OF(X509_NAME)* list =
-      SSL_dup_CA_list(SSL_CTX_get_client_CA_list(sc->ctx().get()));
+      Thin_SSL_dup_CA_list(Thin_SSL_CTX_get_client_CA_list(sc->ctx().get()));
 
-  // NOTE: `SSL_set_client_CA_list` takes the ownership of `list`
-  SSL_set_client_CA_list(ssl_.get(), list);
+  // NOTE: `Thin_SSL_set_client_CA_list` takes the ownership of `list`
+  Thin_SSL_set_client_CA_list(ssl_.get(), list);
   return 1;
 }
 
@@ -1437,7 +1431,7 @@ void TLSWrap::SetPskIdentityHint(const FunctionCallbackInfo<Value>& args) {
   CHECK(args[0]->IsString());
   Utf8Value hint(isolate, args[0].As<String>());
 
-  if (!SSL_use_psk_identity_hint(p->ssl_.get(), *hint)) {
+  if (!Thin_SSL_use_psk_identity_hint(p->ssl_.get(), *hint)) {
     Local<Value> err = node::ERR_TLS_PSK_SET_IDENTIY_HINT_FAILED(isolate);
     p->MakeCallback(env->onerror_string(), 1, &err);
   }
@@ -1448,8 +1442,8 @@ void TLSWrap::EnablePskCallback(const FunctionCallbackInfo<Value>& args) {
   ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
   CHECK_NOT_NULL(wrap->ssl_);
 
-  SSL_set_psk_server_callback(wrap->ssl_.get(), PskServerCallback);
-  SSL_set_psk_client_callback(wrap->ssl_.get(), PskClientCallback);
+  Thin_SSL_set_psk_server_callback(wrap->ssl_.get(), PskServerCallback);
+  Thin_SSL_set_psk_client_callback(wrap->ssl_.get(), PskClientCallback);
 }
 
 unsigned int TLSWrap::PskServerCallback(
@@ -1457,7 +1451,7 @@ unsigned int TLSWrap::PskServerCallback(
     const char* identity,
     unsigned char* psk,
     unsigned int max_psk_len) {
-  TLSWrap* p = static_cast<TLSWrap*>(SSL_get_app_data(s));
+  TLSWrap* p = static_cast<TLSWrap*>(Thin_SSL_get_app_data(s));
 
   Environment* env = p->env();
   HandleScope scope(env->isolate());
@@ -1498,7 +1492,7 @@ unsigned int TLSWrap::PskClientCallback(
     unsigned int max_identity_len,
     unsigned char* psk,
     unsigned int max_psk_len) {
-  TLSWrap* p = static_cast<TLSWrap*>(SSL_get_app_data(s));
+  TLSWrap* p = static_cast<TLSWrap*>(Thin_SSL_get_app_data(s));
 
   Environment* env = p->env();
   HandleScope scope(env->isolate());
@@ -1560,7 +1554,7 @@ void TLSWrap::GetWriteQueueSize(const FunctionCallbackInfo<Value>& info) {
   if (!wrap->ssl_)
     return info.GetReturnValue().Set(0);
 
-  uint32_t write_queue_size = BIO_pending(wrap->enc_out_);
+  uint32_t write_queue_size = Thin_BIO_pending(wrap->enc_out_);
   info.GetReturnValue().Set(write_queue_size);
 }
 
@@ -1599,7 +1593,7 @@ void TLSWrap::CertCbDone(const FunctionCallbackInfo<Value>& args) {
     if (UseSNIContext(w->ssl_, w->sni_context_) && !w->SetCACerts(sc)) {
       // Not clear why sometimes we throw error, and sometimes we call
       // onerror(). Both cause .destroy(), but onerror does a bit more.
-      unsigned long err = ERR_get_error();  // NOLINT(runtime/int)
+      unsigned long err = Thin_ERR_get_error();  // NOLINT(runtime/int)
       return ThrowCryptoError(env, err, "CertCbDone");
     }
   } else if (ctx->IsObject()) {
@@ -1632,12 +1626,12 @@ void TLSWrap::SetALPNProtocols(const FunctionCallbackInfo<Value>& args) {
   ArrayBufferViewContents<uint8_t> protos(args[0].As<ArrayBufferView>());
   SSL* ssl = w->ssl_.get();
   if (w->is_client()) {
-    CHECK_EQ(0, SSL_set_alpn_protos(ssl, protos.data(), protos.length()));
+    CHECK_EQ(0, Thin_SSL_set_alpn_protos(ssl, protos.data(), protos.length()));
   } else {
     w->alpn_protos_ = std::vector<unsigned char>(
         protos.data(), protos.data() + protos.length());
-    SSL_CTX* ssl_ctx = SSL_get_SSL_CTX(ssl);
-    SSL_CTX_set_alpn_select_cb(ssl_ctx, SelectALPNCallback, nullptr);
+    SSL_CTX* ssl_ctx = Thin_SSL_get_SSL_CTX(ssl);
+    Thin_SSL_CTX_set_alpn_select_cb(ssl_ctx, SelectALPNCallback, nullptr);
   }
 }
 
@@ -1696,13 +1690,13 @@ void TLSWrap::GetFinished(const FunctionCallbackInfo<Value>& args) {
   TLSWrap* w;
   ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
 
-  // We cannot just pass nullptr to SSL_get_finished()
+  // We cannot just pass nullptr to Thin_SSL_get_finished()
   // because it would further be propagated to memcpy(),
   // where the standard requirements as described in ISO/IEC 9899:2011
   // sections 7.21.2.1, 7.21.1.2, and 7.1.4, would be violated.
   // Thus, we use a dummy byte.
   char dummy[1];
-  size_t len = SSL_get_finished(w->ssl_.get(), dummy, sizeof dummy);
+  size_t len = Thin_SSL_get_finished(w->ssl_.get(), dummy, sizeof dummy);
   if (len == 0)
     return;
 
@@ -1713,7 +1707,7 @@ void TLSWrap::GetFinished(const FunctionCallbackInfo<Value>& args) {
   }
 
   CHECK_EQ(bs->ByteLength(),
-           SSL_get_finished(w->ssl_.get(), bs->Data(), bs->ByteLength()));
+           Thin_SSL_get_finished(w->ssl_.get(), bs->Data(), bs->ByteLength()));
 
   Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
   Local<Value> buffer;
@@ -1727,13 +1721,13 @@ void TLSWrap::GetPeerFinished(const FunctionCallbackInfo<Value>& args) {
   TLSWrap* w;
   ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
 
-  // We cannot just pass nullptr to SSL_get_peer_finished()
+  // We cannot just pass nullptr to Thin_SSL_get_peer_finished()
   // because it would further be propagated to memcpy(),
   // where the standard requirements as described in ISO/IEC 9899:2011
   // sections 7.21.2.1, 7.21.1.2, and 7.1.4, would be violated.
   // Thus, we use a dummy byte.
   char dummy[1];
-  size_t len = SSL_get_peer_finished(w->ssl_.get(), dummy, sizeof dummy);
+  size_t len = Thin_SSL_get_peer_finished(w->ssl_.get(), dummy, sizeof dummy);
   if (len == 0)
     return;
 
@@ -1744,7 +1738,7 @@ void TLSWrap::GetPeerFinished(const FunctionCallbackInfo<Value>& args) {
   }
 
   CHECK_EQ(bs->ByteLength(),
-           SSL_get_peer_finished(w->ssl_.get(), bs->Data(), bs->ByteLength()));
+           Thin_SSL_get_peer_finished(w->ssl_.get(), bs->Data(), bs->ByteLength()));
 
   Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
   Local<Value> buffer;
@@ -1758,11 +1752,11 @@ void TLSWrap::GetSession(const FunctionCallbackInfo<Value>& args) {
   TLSWrap* w;
   ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
 
-  SSL_SESSION* sess = SSL_get_session(w->ssl_.get());
+  SSL_SESSION* sess = Thin_SSL_get_session(w->ssl_.get());
   if (sess == nullptr)
     return;
 
-  int slen = i2d_SSL_SESSION(sess, nullptr);
+  int slen = Thin_i2d_SSL_SESSION(sess, nullptr);
   if (slen <= 0)
     return;  // Invalid or malformed session.
 
@@ -1773,7 +1767,7 @@ void TLSWrap::GetSession(const FunctionCallbackInfo<Value>& args) {
   }
 
   unsigned char* p = static_cast<unsigned char*>(bs->Data());
-  CHECK_LT(0, i2d_SSL_SESSION(sess, &p));
+  CHECK_LT(0, Thin_i2d_SSL_SESSION(sess, &p));
 
   Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
   Local<Value> buffer;
@@ -1797,13 +1791,13 @@ void TLSWrap::SetSession(const FunctionCallbackInfo<Value>& args) {
     return;  // TODO(tniessen): figure out error handling
 
   if (!SetTLSSession(w->ssl_, sess))
-    return env->ThrowError("SSL_set_session error");
+    return env->ThrowError("Thin_SSL_set_session error");
 }
 
 void TLSWrap::IsSessionReused(const FunctionCallbackInfo<Value>& args) {
   TLSWrap* w;
   ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
-  bool yes = SSL_session_reused(w->ssl_.get());
+  bool yes = Thin_SSL_session_reused(w->ssl_.get());
   args.GetReturnValue().Set(yes);
 }
 
@@ -1823,7 +1817,7 @@ void TLSWrap::VerifyError(const FunctionCallbackInfo<Value>& args) {
   if (x509_verify_error == X509_V_OK)
     return args.GetReturnValue().SetNull();
 
-  const char* reason = X509_verify_cert_error_string(x509_verify_error);
+  const char* reason = Thin_X509_verify_cert_error_string(x509_verify_error);
   const char* code = X509ErrorCode(x509_verify_error);
 
   Local<Object> error =
@@ -1852,7 +1846,7 @@ void TLSWrap::LoadSession(const FunctionCallbackInfo<Value>& args) {
     ArrayBufferViewContents<unsigned char> sbuf(args[0]);
 
     const unsigned char* p = sbuf.data();
-    SSL_SESSION* sess = d2i_SSL_SESSION(nullptr, &p, sbuf.length());
+    SSL_SESSION* sess = Thin_d2i_SSL_SESSION(nullptr, &p, sbuf.length());
 
     // Setup next session and move hello to the BIO buffer
     w->next_sess_.reset(sess);
@@ -1865,7 +1859,7 @@ void TLSWrap::GetSharedSigalgs(const FunctionCallbackInfo<Value>& args) {
   ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
 
   SSL* ssl = w->ssl_.get();
-  int nsig = SSL_get_shared_sigalgs(ssl, 0, nullptr, nullptr, nullptr, nullptr,
+  int nsig = Thin_SSL_get_shared_sigalgs(ssl, 0, nullptr, nullptr, nullptr, nullptr,
                                     nullptr);
   MaybeStackBuffer<Local<Value>, 16> ret_arr(nsig);
 
@@ -1874,7 +1868,7 @@ void TLSWrap::GetSharedSigalgs(const FunctionCallbackInfo<Value>& args) {
     int sign_nid;
     std::string sig_with_md;
 
-    SSL_get_shared_sigalgs(ssl, i, &sign_nid, &hash_nid, nullptr, nullptr,
+    Thin_SSL_get_shared_sigalgs(ssl, i, &sign_nid, &hash_nid, nullptr, nullptr,
                            nullptr);
 
     switch (sign_nid) {
@@ -1915,7 +1909,7 @@ void TLSWrap::GetSharedSigalgs(const FunctionCallbackInfo<Value>& args) {
         break;
 #endif  // !OPENSSL_NO_GOST
       default:
-        const char* sn = OBJ_nid2sn(sign_nid);
+        const char* sn = Thin_OBJ_nid2sn(sign_nid);
 
         if (sn != nullptr) {
           sig_with_md = std::string(sn) + "+";
@@ -1925,7 +1919,7 @@ void TLSWrap::GetSharedSigalgs(const FunctionCallbackInfo<Value>& args) {
         break;
     }
 
-    const char* sn_hash = OBJ_nid2sn(hash_nid);
+    const char* sn_hash = Thin_OBJ_nid2sn(hash_nid);
     if (sn_hash != nullptr) {
       sig_with_md += std::string(sn_hash);
     } else {
@@ -1960,7 +1954,7 @@ void TLSWrap::ExportKeyingMaterial(const FunctionCallbackInfo<Value>& args) {
   if (use_context)
     context = ByteSource::FromBuffer(args[2]);
 
-  if (SSL_export_keying_material(
+  if (Thin_SSL_export_keying_material(
           w->ssl_.get(),
           static_cast<unsigned char*>(bs->Data()),
           olen,
@@ -1971,8 +1965,8 @@ void TLSWrap::ExportKeyingMaterial(const FunctionCallbackInfo<Value>& args) {
           use_context) != 1) {
     return ThrowCryptoError(
          env,
-         ERR_get_error(),
-         "SSL_export_keying_material");
+         Thin_ERR_get_error(),
+         "Thin_SSL_export_keying_material");
   }
 
   Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
@@ -1991,8 +1985,8 @@ void TLSWrap::Renegotiate(const FunctionCallbackInfo<Value>& args) {
   TLSWrap* w;
   ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
   ClearErrorOnReturn clear_error_on_return;
-  if (SSL_renegotiate(w->ssl_.get()) != 1)
-    return ThrowCryptoError(w->env(), ERR_get_error());
+  if (Thin_SSL_renegotiate(w->ssl_.get()) != 1)
+    return ThrowCryptoError(w->env(), Thin_ERR_get_error());
 }
 
 void TLSWrap::GetTLSTicket(const FunctionCallbackInfo<Value>& args) {
@@ -2000,13 +1994,13 @@ void TLSWrap::GetTLSTicket(const FunctionCallbackInfo<Value>& args) {
   ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
   Environment* env = w->env();
 
-  SSL_SESSION* sess = SSL_get_session(w->ssl_.get());
+  SSL_SESSION* sess = Thin_SSL_get_session(w->ssl_.get());
   if (sess == nullptr)
     return;
 
   const unsigned char* ticket;
   size_t length;
-  SSL_SESSION_get0_ticket(sess, &ticket, &length);
+  Thin_SSL_SESSION_get0_ticket(sess, &ticket, &length);
 
   if (ticket != nullptr) {
     args.GetReturnValue().Set(
@@ -2039,7 +2033,7 @@ void TLSWrap::RequestOCSP(const FunctionCallbackInfo<Value>& args) {
   TLSWrap* w;
   ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
 
-  SSL_set_tlsext_status_type(w->ssl_.get(), TLSEXT_STATUSTYPE_ocsp);
+  Thin_SSL_set_tlsext_status_type(w->ssl_.get(), TLSEXT_STATUSTYPE_ocsp);
 }
 
 void TLSWrap::GetEphemeralKeyInfo(const FunctionCallbackInfo<Value>& args) {
@@ -2057,7 +2051,7 @@ void TLSWrap::GetEphemeralKeyInfo(const FunctionCallbackInfo<Value>& args) {
       .FromMaybe(Local<Value>()));
 
   // TODO(@sam-github) semver-major: else return ThrowCryptoError(env,
-  // ERR_get_error())
+  // Thin_ERR_get_error())
 }
 
 void TLSWrap::GetProtocol(const FunctionCallbackInfo<Value>& args) {
@@ -2065,7 +2059,7 @@ void TLSWrap::GetProtocol(const FunctionCallbackInfo<Value>& args) {
   TLSWrap* w;
   ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
   args.GetReturnValue().Set(
-      OneByteString(env->isolate(), SSL_get_version(w->ssl_.get())));
+      OneByteString(env->isolate(), Thin_SSL_get_version(w->ssl_.get())));
 }
 
 void TLSWrap::GetALPNNegotiatedProto(const FunctionCallbackInfo<Value>& args) {
@@ -2076,7 +2070,7 @@ void TLSWrap::GetALPNNegotiatedProto(const FunctionCallbackInfo<Value>& args) {
   const unsigned char* alpn_proto;
   unsigned int alpn_proto_len;
 
-  SSL_get0_alpn_selected(w->ssl_.get(), &alpn_proto, &alpn_proto_len);
+  Thin_SSL_get0_alpn_selected(w->ssl_.get(), &alpn_proto, &alpn_proto_len);
 
   Local<Value> result;
   if (alpn_proto_len == 0) {
@@ -2117,18 +2111,18 @@ void TLSWrap::Cycle() {
   }
 }
 
-#ifdef SSL_set_max_send_fragment
+#ifdef Thin_SSL_set_max_send_fragment
 void TLSWrap::SetMaxSendFragment(const FunctionCallbackInfo<Value>& args) {
   CHECK(args.Length() >= 1 && args[0]->IsNumber());
   Environment* env = Environment::GetCurrent(args);
   TLSWrap* w;
   ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
-  int rv = SSL_set_max_send_fragment(
+  int rv = Thin_SSL_set_max_send_fragment(
       w->ssl_.get(),
       args[0]->Int32Value(env->context()).FromJust());
   args.GetReturnValue().Set(rv);
 }
-#endif  // SSL_set_max_send_fragment
+#endif  // Thin_SSL_set_max_send_fragment
 
 void TLSWrap::Initialize(
     Local<Object> target,
@@ -2209,9 +2203,9 @@ void TLSWrap::Initialize(
   SetProtoMethodNoSideEffect(isolate, t, "getTLSTicket", GetTLSTicket);
   SetProtoMethodNoSideEffect(isolate, t, "verifyError", VerifyError);
 
-#ifdef SSL_set_max_send_fragment
+#ifdef Thin_SSL_set_max_send_fragment
   SetProtoMethod(isolate, t, "setMaxSendFragment", SetMaxSendFragment);
-#endif  // SSL_set_max_send_fragment
+#endif  // Thin_SSL_set_max_send_fragment
 
 #ifndef OPENSSL_NO_PSK
   SetProtoMethod(isolate, t, "enablePskCallback", EnablePskCallback);
@@ -2269,9 +2263,9 @@ void TLSWrap::RegisterExternalReferences(ExternalReferenceRegistry* registry) {
   registry->Register(VerifyError);
   registry->Register(WritesIssuedByPrevListenerDone);
 
-#ifdef SSL_set_max_send_fragment
+#ifdef Thin_SSL_set_max_send_fragment
   registry->Register(SetMaxSendFragment);
-#endif  // SSL_set_max_send_fragment
+#endif  // Thin_SSL_set_max_send_fragment
 
 #ifndef OPENSSL_NO_PSK
   registry->Register(EnablePskCallback);
diff --git a/src/crypto/crypto_tls.h b/src/crypto/crypto_tls.h
index e89374cbb5..e5184a5365 100644
--- a/src/crypto/crypto_tls.h
+++ b/src/crypto/crypto_tls.h
@@ -31,7 +31,7 @@
 #include "stream_wrap.h"
 #include "v8.h"
 
-#include <openssl/ssl.h>
+// #include <openssl/ssl.h>
 
 #include <string>
 #include <vector>
@@ -150,15 +150,15 @@ class TLSWrap : public AsyncWrap,
   // EncIn() doesn't exist. Encrypted data is pushed from underlying stream into
   // enc_in_ via the stream listener's OnStreamAlloc()/OnStreamRead() interface.
   void EncOut();  // Write encrypted data from enc_out_ to underlying stream.
-  void ClearIn();  // SSL_write() clear data "in" to SSL.
-  void ClearOut();  // SSL_read() clear text "out" from SSL.
+  void ClearIn();  // Thin_SSL_write() clear data "in" to SSL.
+  void ClearOut();  // Thin_SSL_read() clear text "out" from SSL.
   void Destroy();
 
   // Call Done() on outstanding WriteWrap request.
   void InvokeQueued(int status, const char* error_str = nullptr);
 
-  // Drive the SSL state machine by attempting to SSL_read() and SSL_write() to
-  // it. Transparent handshakes mean SSL_read() might trigger I/O on the
+  // Drive the SSL state machine by attempting to Thin_SSL_read() and Thin_SSL_write() to
+  // it. Transparent handshakes mean Thin_SSL_read() might trigger I/O on the
   // underlying stream even if there is no clear text to read or write.
   void Cycle();
 
@@ -224,10 +224,10 @@ class TLSWrap : public AsyncWrap,
   static void WritesIssuedByPrevListenerDone(
       const v8::FunctionCallbackInfo<v8::Value>& args);
 
-#ifdef SSL_set_max_send_fragment
+#ifdef Thin_SSL_set_max_send_fragment
   static void SetMaxSendFragment(
       const v8::FunctionCallbackInfo<v8::Value>& args);
-#endif  // SSL_set_max_send_fragment
+#endif  // Thin_SSL_set_max_send_fragment
 
 #ifndef OPENSSL_NO_PSK
   static void EnablePskCallback(
@@ -256,9 +256,9 @@ class TLSWrap : public AsyncWrap,
   BaseObjectPtr<SecureContext> sc_;
 
   // BIO buffers hold encrypted data.
-  BIO* enc_in_ = nullptr;   // StreamListener fills this for SSL_read().
-  BIO* enc_out_ = nullptr;  // SSL_write()/handshake fills this for EncOut().
-  // Waiting for ClearIn() to pass to SSL_write().
+  BIO* enc_in_ = nullptr;   // StreamListener fills this for Thin_SSL_read().
+  BIO* enc_out_ = nullptr;  // Thin_SSL_write()/handshake fills this for EncOut().
+  // Waiting for ClearIn() to pass to Thin_SSL_write().
   std::unique_ptr<v8::BackingStore> pending_cleartext_input_;
   size_t write_size_ = 0;
   BaseObjectPtr<AsyncWrap> current_write_;
@@ -284,7 +284,7 @@ class TLSWrap : public AsyncWrap,
 
   int cycle_depth_ = 0;
 
-  // SSL_set_cert_cb
+  // Thin_SSL_set_cert_cb
   CertCb cert_cb_ = nullptr;
   void* cert_cb_arg_ = nullptr;
 
diff --git a/src/crypto/crypto_util.cc b/src/crypto/crypto_util.cc
index 49b0175c21..3fa7875dea 100644
--- a/src/crypto/crypto_util.cc
+++ b/src/crypto/crypto_util.cc
@@ -13,11 +13,11 @@
 
 #include "math.h"
 
-#if OPENSSL_VERSION_MAJOR >= 3
-#include "openssl/provider.h"
-#endif
+// #if OPENSSL_VERSION_MAJOR >= 3
+// #include "openssl/provider.h"
+// #endif
 
-#include <openssl/rand.h>
+// #include <openssl/rand.h>
 
 namespace node {
 
@@ -50,7 +50,7 @@ int VerifyCallback(int preverify_ok, X509_STORE_CTX* ctx) {
   //   VerifyCallback always returns 1, the TLS/SSL handshake will not be
   //   terminated with respect to verification failures and the connection will
   //   be established. The calling process can however retrieve the error code
-  //   of the last verification error using SSL_get_verify_result(3) or by
+  //   of the last verification error using Thin_SSL_get_verify_result(3) or by
   //   maintaining its own error storage managed by VerifyCallback.
   //
   // Since we cannot perform I/O quickly enough with X509_STORE_CTX_ APIs in
@@ -63,22 +63,22 @@ int VerifyCallback(int preverify_ok, X509_STORE_CTX* ctx) {
 MUST_USE_RESULT CSPRNGResult CSPRNG(void* buffer, size_t length) {
   unsigned char* buf = static_cast<unsigned char*>(buffer);
   do {
-    if (1 == RAND_status()) {
+    if (1 == Thin_RAND_status()) {
 #if OPENSSL_VERSION_MAJOR >= 3
-      if (1 == RAND_bytes_ex(nullptr, buf, length, 0)) return {true};
+      if (1 == Thin_RAND_bytes_ex(nullptr, buf, length, 0)) return {true};
 #else
-      while (length > INT_MAX && 1 == RAND_bytes(buf, INT_MAX)) {
+      while (length > INT_MAX && 1 == Thin_RAND_bytes(buf, INT_MAX)) {
         buf += INT_MAX;
         length -= INT_MAX;
       }
-      if (length <= INT_MAX && 1 == RAND_bytes(buf, static_cast<int>(length)))
+      if (length <= INT_MAX && 1 == Thin_RAND_bytes(buf, static_cast<int>(length)))
         return {true};
 #endif
     }
 #if OPENSSL_VERSION_MAJOR >= 3
-    const auto code = ERR_peek_last_error();
-    // A misconfigured OpenSSL 3 installation may report 1 from RAND_poll()
-    // and RAND_status() but fail in RAND_bytes() if it cannot look up
+    const auto code = Thin_ERR_peek_last_error();
+    // A misconfigured OpenSSL 3 installation may report 1 from Thin_RAND_poll()
+    // and Thin_RAND_status() but fail in Thin_RAND_bytes() if it cannot look up
     // a matching algorithm for the CSPRNG.
     if (ERR_GET_LIB(code) == ERR_LIB_RAND) {
       const auto reason = ERR_GET_REASON(code);
@@ -89,7 +89,7 @@ MUST_USE_RESULT CSPRNGResult CSPRNG(void* buffer, size_t length) {
       }
     }
 #endif
-  } while (1 == RAND_poll());
+  } while (1 == Thin_RAND_poll());
 
   return {false};
 }
@@ -122,15 +122,15 @@ bool ProcessFipsOptions() {
   if (per_process::cli_options->enable_fips_crypto ||
       per_process::cli_options->force_fips_crypto) {
 #if OPENSSL_VERSION_MAJOR >= 3
-    OSSL_PROVIDER* fips_provider = OSSL_PROVIDER_load(nullptr, "fips");
+    OSSL_PROVIDER* fips_provider = Thin_OSSL_PROVIDER_load(nullptr, "fips");
     if (fips_provider == nullptr)
       return false;
-    OSSL_PROVIDER_unload(fips_provider);
+    Thin_OSSL_PROVIDER_unload(fips_provider);
 
-    return EVP_default_properties_enable_fips(nullptr, 1) &&
-           EVP_default_properties_is_fips_enabled(nullptr);
+    return Thin_EVP_default_properties_enable_fips(nullptr, 1) &&
+           Thin_EVP_default_properties_is_fips_enabled(nullptr);
 #else
-    if (FIPS_mode() == 0) return FIPS_mode_set(1);
+    if (Thin_FIPS_mode() == 0) return Thin_FIPS_mode_set(1);
 
 #endif
   }
@@ -155,34 +155,33 @@ static Mutex fips_mutex;
 void InitCryptoOnce() {
   Mutex::ScopedLock lock(per_process::cli_options_mutex);
   Mutex::ScopedLock fips_lock(fips_mutex);
-#ifndef OPENSSL_IS_BORINGSSL
-  OPENSSL_INIT_SETTINGS* settings = OPENSSL_INIT_new();
+  OPENSSL_INIT_SETTINGS* settings = Thin_OPENSSL_INIT_new();
 
 #if OPENSSL_VERSION_MAJOR < 3
   // --openssl-config=...
   if (!per_process::cli_options->openssl_config.empty()) {
     const char* conf = per_process::cli_options->openssl_config.c_str();
-    OPENSSL_INIT_set_config_filename(settings, conf);
+    Thin_OPENSSL_INIT_set_config_filename(settings, conf);
   }
 #endif
 
 #if OPENSSL_VERSION_MAJOR >= 3
   // --openssl-legacy-provider
   if (per_process::cli_options->openssl_legacy_provider) {
-    OSSL_PROVIDER* legacy_provider = OSSL_PROVIDER_load(nullptr, "legacy");
+    OSSL_PROVIDER* legacy_provider = Thin_OSSL_PROVIDER_load(nullptr, "legacy");
     if (legacy_provider == nullptr) {
       fprintf(stderr, "Unable to load legacy provider.\n");
     }
   }
 #endif
 
-  OPENSSL_init_ssl(0, settings);
-  OPENSSL_INIT_free(settings);
+  Thin_OPENSSL_init_ssl(0, settings);
+  Thin_OPENSSL_INIT_free(settings);
   settings = nullptr;
 
 #ifndef _WIN32
   if (per_process::cli_options->secure_heap != 0) {
-    switch (CRYPTO_secure_malloc_init(
+    switch (Thin_CRYPTO_secure_malloc_init(
                 per_process::cli_options->secure_heap,
                 static_cast<int>(per_process::cli_options->secure_heap_min))) {
       case 0:
@@ -199,15 +198,14 @@ void InitCryptoOnce() {
   }
 #endif
 
-#endif  // OPENSSL_IS_BORINGSSL
 
   // Turn off compression. Saves memory and protects against CRIME attacks.
   // No-op with OPENSSL_NO_COMP builds of OpenSSL.
-  sk_SSL_COMP_zero(SSL_COMP_get_compression_methods());
+  Thin_sk_SSL_COMP_zero(Thin_SSL_COMP_get_compression_methods());
 
 #ifndef OPENSSL_NO_ENGINE
-  ERR_load_ENGINE_strings();
-  ENGINE_load_builtin_engines();
+  Thin_ERR_load_ENGINE_strings();
+  Thin_ENGINE_load_builtin_engines();
 #endif  // !OPENSSL_NO_ENGINE
 }
 
@@ -216,10 +214,10 @@ void GetFipsCrypto(const FunctionCallbackInfo<Value>& args) {
   Mutex::ScopedLock fips_lock(fips_mutex);
 
 #if OPENSSL_VERSION_MAJOR >= 3
-  args.GetReturnValue().Set(EVP_default_properties_is_fips_enabled(nullptr) ?
+  args.GetReturnValue().Set(Thin_EVP_default_properties_is_fips_enabled(nullptr) ?
       1 : 0);
 #else
-  args.GetReturnValue().Set(FIPS_mode() ? 1 : 0);
+  args.GetReturnValue().Set(Thin_FIPS_mode() ? 1 : 0);
 #endif
 }
 
@@ -233,18 +231,18 @@ void SetFipsCrypto(const FunctionCallbackInfo<Value>& args) {
   bool enable = args[0]->BooleanValue(env->isolate());
 
 #if OPENSSL_VERSION_MAJOR >= 3
-  if (enable == EVP_default_properties_is_fips_enabled(nullptr))
+  if (enable == Thin_EVP_default_properties_is_fips_enabled(nullptr))
 #else
-  if (static_cast<int>(enable) == FIPS_mode())
+  if (static_cast<int>(enable) == Thin_FIPS_mode())
 #endif
     return;  // No action needed.
 
 #if OPENSSL_VERSION_MAJOR >= 3
-  if (!EVP_default_properties_enable_fips(nullptr, enable)) {
+  if (!Thin_EVP_default_properties_enable_fips(nullptr, enable)) {
 #else
-  if (!FIPS_mode_set(enable)) {
+  if (!Thin_FIPS_mode_set(enable)) {
 #endif
-    unsigned long err = ERR_get_error();  // NOLINT(runtime/int)
+    unsigned long err = Thin_ERR_get_error();  // NOLINT(runtime/int)
     return ThrowCryptoError(env, err);
   }
 }
@@ -255,11 +253,11 @@ void TestFipsCrypto(const v8::FunctionCallbackInfo<v8::Value>& args) {
 
 #if OPENSSL_VERSION_MAJOR >= 3
   OSSL_PROVIDER* fips_provider = nullptr;
-  if (OSSL_PROVIDER_available(nullptr, "fips")) {
-    fips_provider = OSSL_PROVIDER_load(nullptr, "fips");
+  if (Thin_OSSL_PROVIDER_available(nullptr, "fips")) {
+    fips_provider = Thin_OSSL_PROVIDER_load(nullptr, "fips");
   }
   const auto enabled = fips_provider == nullptr ? 0 :
-      OSSL_PROVIDER_self_test(fips_provider) ? 1 : 0;
+      Thin_OSSL_PROVIDER_self_test(fips_provider) ? 1 : 0;
 #else
 #ifdef OPENSSL_FIPS
   const auto enabled = FIPS_selftest() ? 1 : 0;
@@ -273,9 +271,9 @@ void TestFipsCrypto(const v8::FunctionCallbackInfo<v8::Value>& args) {
 
 void CryptoErrorStore::Capture() {
   errors_.clear();
-  while (const uint32_t err = ERR_get_error()) {
+  while (const uint32_t err = Thin_ERR_get_error()) {
     char buf[256];
-    ERR_error_string_n(err, buf, sizeof(buf));
+    Thin_ERR_error_string_n(err, buf, sizeof(buf));
     errors_.emplace_back(buf);
   }
   std::reverse(std::begin(errors_), std::end(errors_));
@@ -334,12 +332,12 @@ ByteSource::ByteSource(ByteSource&& other) noexcept
 }
 
 ByteSource::~ByteSource() {
-  OPENSSL_clear_free(allocated_data_, size_);
+  Thin_OPENSSL_clear_free(allocated_data_, size_);
 }
 
 ByteSource& ByteSource::operator=(ByteSource&& other) noexcept {
   if (&other != this) {
-    OPENSSL_clear_free(allocated_data_, size_);
+    Thin_OPENSSL_clear_free(allocated_data_, size_);
     data_ = other.data_;
     allocated_data_ = other.allocated_data_;
     other.allocated_data_ = nullptr;
@@ -362,7 +360,7 @@ std::unique_ptr<BackingStore> ByteSource::ReleaseToBackingStore(Environment* env
   void* v8_data = allocator->Allocate(size());
   CHECK(v8_data);
   memcpy(v8_data, allocated_data_, size());
-  OPENSSL_clear_free(allocated_data_, size());
+  Thin_OPENSSL_clear_free(allocated_data_, size());
   std::unique_ptr<BackingStore> ptr = ArrayBuffer::NewBackingStore(
       v8_data,
       size(),
@@ -381,7 +379,7 @@ std::unique_ptr<BackingStore> ByteSource::ReleaseToBackingStore(Environment* env
       allocated_data_,
       size(),
       [](void* data, size_t length, void* deleter_data) {
-        OPENSSL_clear_free(deleter_data, length);
+        Thin_OPENSSL_clear_free(deleter_data, length);
       }, allocated_data_);
   CHECK(ptr);
   allocated_data_ = nullptr;
@@ -404,7 +402,7 @@ MaybeLocal<Uint8Array> ByteSource::ToBuffer(Environment* env) {
 ByteSource ByteSource::FromBIO(const BIOPointer& bio) {
   CHECK(bio);
   BUF_MEM* bptr;
-  BIO_get_mem_ptr(bio.get(), &bptr);
+  Thin_BIO_get_mem_ptr(bio.get(), &bptr);
   ByteSource::Builder out(bptr->length);
   memcpy(out.data<void>(), bptr->data, bptr->length);
   return std::move(out).release();
@@ -487,9 +485,9 @@ Maybe<bool> Decorate(Environment* env, Local<Object> obj,
               unsigned long err) {  // NOLINT(runtime/int)
   if (err == 0) return Just(true);  // No decoration necessary.
 
-  const char* ls = ERR_lib_error_string(err);
-  const char* fs = ERR_func_error_string(err);
-  const char* rs = ERR_reason_error_string(err);
+  const char* ls = Thin_ERR_lib_error_string(err);
+  const char* fs = Thin_ERR_func_error_string(err);
+  const char* rs = Thin_ERR_reason_error_string(err);
 
   Isolate* isolate = env->isolate();
   Local<Context> context = isolate->GetCurrentContext();
@@ -543,15 +541,24 @@ Maybe<bool> Decorate(Environment* env, Local<Object> obj,
     V(BIO)                                                                    \
     V(PKCS7)                                                                  \
     V(X509V3)                                                                 \
+    V(PKCS12)                                                                 \
     V(RAND)                                                                   \
+    V(DSO)                                                                    \
     V(ENGINE)                                                                 \
     V(OCSP)                                                                   \
     V(UI)                                                                     \
     V(COMP)                                                                   \
     V(ECDSA)                                                                  \
     V(ECDH)                                                                   \
+    V(OSSL_STORE)                                                             \
+    V(FIPS)                                                                   \
+    V(CMS)                                                                    \
+    V(TS)                                                                     \
     V(HMAC)                                                                   \
-    V(HKDF)                                                                    \
+    V(CT)                                                                     \
+    V(ASYNC)                                                                  \
+    V(KDF)                                                                    \
+    V(SM2)                                                                    \
     V(USER)                                                                   \
 
 #define V(name) case ERR_LIB_##name: lib = #name "_"; break;
@@ -587,7 +594,7 @@ void ThrowCryptoError(Environment* env,
                       const char* message) {
   char message_buffer[128] = {0};
   if (err != 0 || message == nullptr) {
-    ERR_error_string_n(err, message_buffer, sizeof(message_buffer));
+    Thin_ERR_error_string_n(err, message_buffer, sizeof(message_buffer));
     message = message_buffer;
   }
   HandleScope scope(env->isolate());
@@ -610,13 +617,13 @@ void ThrowCryptoError(Environment* env,
 EnginePointer LoadEngineById(const char* id, CryptoErrorStore* errors) {
   MarkPopErrorOnReturn mark_pop_error_on_return;
 
-  EnginePointer engine(ENGINE_by_id(id));
+  EnginePointer engine(Thin_ENGINE_by_id(id));
   if (!engine) {
     // Engine not found, try loading dynamically.
-    engine = EnginePointer(ENGINE_by_id("dynamic"));
+    engine = EnginePointer(Thin_ENGINE_by_id("dynamic"));
     if (engine) {
-      if (!ENGINE_ctrl_cmd_string(engine.get(), "SO_PATH", id, 0) ||
-          !ENGINE_ctrl_cmd_string(engine.get(), "LOAD", nullptr, 0)) {
+      if (!Thin_ENGINE_ctrl_cmd_string(engine.get(), "SO_PATH", id, 0) ||
+          !Thin_ENGINE_ctrl_cmd_string(engine.get(), "LOAD", nullptr, 0)) {
         engine.reset();
       }
     }
@@ -638,7 +645,7 @@ bool SetEngine(const char* id, uint32_t flags, CryptoErrorStore* errors) {
   if (!engine)
     return false;
 
-  if (!ENGINE_set_default(engine.get(), flags)) {
+  if (!Thin_ENGINE_set_default(engine.get(), flags)) {
     if (errors != nullptr)
       errors->Capture();
     return false;
@@ -672,7 +679,7 @@ MaybeLocal<Value> EncodeBignum(
     int size,
     Local<Value>* error) {
   std::vector<uint8_t> buf(size);
-  CHECK_EQ(BN_bn2binpad(bn, buf.data(), size), size);
+  CHECK_EQ(Thin_BN_bn2binpad(bn, buf.data(), size), size);
   return StringBytes::Encode(
       env->isolate(),
       reinterpret_cast<const char*>(buf.data()),
@@ -691,7 +698,7 @@ Maybe<bool> SetEncodedValue(
   Local<Value> error;
   CHECK_NOT_NULL(bn);
   if (size == 0)
-    size = BN_num_bytes(bn);
+    size = Thin_BN_num_bytes(bn);
   if (!EncodeBignum(env, bn, size, &error).ToLocal(&value)) {
     if (!error.IsEmpty())
       env->isolate()->ThrowException(error);
@@ -703,12 +710,12 @@ Maybe<bool> SetEncodedValue(
 bool SetRsaOaepLabel(const EVPKeyCtxPointer& ctx, const ByteSource& label) {
   if (label.size() != 0) {
     // OpenSSL takes ownership of the label, so we need to create a copy.
-    void* label_copy = OPENSSL_memdup(label.data(), label.size());
+    void* label_copy = Thin_OPENSSL_memdup(label.data(), label.size());
     CHECK_NOT_NULL(label_copy);
-    int ret = EVP_PKEY_CTX_set0_rsa_oaep_label(
+    int ret = Thin_EVP_PKEY_CTX_set0_rsa_oaep_label(
         ctx.get(), static_cast<unsigned char*>(label_copy), label.size());
     if (ret <= 0) {
-      OPENSSL_free(label_copy);
+      Thin_OPENSSL_free(label_copy);
       return false;
     }
   }
@@ -723,10 +730,10 @@ CryptoJobMode GetCryptoJobMode(v8::Local<v8::Value> args) {
 }
 
 namespace {
-// SecureBuffer uses OPENSSL_secure_malloc to allocate a Uint8Array.
+// SecureBuffer uses Thin_OPENSSL_secure_malloc to allocate a Uint8Array.
 // Without --secure-heap, OpenSSL's secure heap is disabled,
 // in which case this has the same semantics as
-// using OPENSSL_malloc. However, if the secure heap is
+// using Thin_OPENSSL_malloc. However, if the secure heap is
 // initialized, SecureBuffer will automatically use it.
 #if defined(V8_ENABLE_SANDBOX)
 // When V8 sandboxed pointers are enabled, the secure heap cannot be used as
@@ -742,7 +749,7 @@ void SecureBuffer(const FunctionCallbackInfo<Value>& args) {
   CHECK(args[0]->IsUint32());
   Environment* env = Environment::GetCurrent(args);
   uint32_t len = args[0].As<Uint32>()->Value();
-  void* data = OPENSSL_malloc(len);
+  void* data = Thin_OPENSSL_secure_zalloc(len);
   if (data == nullptr) {
     // There's no memory available for the allocation.
     // Return nothing.
@@ -753,7 +760,7 @@ void SecureBuffer(const FunctionCallbackInfo<Value>& args) {
           data,
           len,
           [](void* data, size_t len, void* deleter_data) {
-            OPENSSL_clear_free(data, len);
+            Thin_OPENSSL_secure_clear_free(data, len);
           },
           data);
   Local<ArrayBuffer> buffer = ArrayBuffer::New(env->isolate(), store);
@@ -762,12 +769,10 @@ void SecureBuffer(const FunctionCallbackInfo<Value>& args) {
 #endif  // defined(V8_ENABLE_SANDBOX)
 
 void SecureHeapUsed(const FunctionCallbackInfo<Value>& args) {
-#ifndef OPENSSL_IS_BORINGSSL
   Environment* env = Environment::GetCurrent(args);
-  if (CRYPTO_secure_malloc_initialized())
+  if (Thin_CRYPTO_secure_malloc_initialized())
     args.GetReturnValue().Set(
-        BigInt::New(env->isolate(), CRYPTO_secure_used()));
-#endif
+        BigInt::New(env->isolate(), Thin_CRYPTO_secure_used()));
 }
 }  // namespace
 
diff --git a/src/crypto/crypto_util.h b/src/crypto/crypto_util.h
index 8c06e81de3..f8d6124659 100644
--- a/src/crypto/crypto_util.h
+++ b/src/crypto/crypto_util.h
@@ -11,23 +11,24 @@
 #include "string_bytes.h"
 #include "util.h"
 #include "v8.h"
-
-#include <openssl/dsa.h>
-#include <openssl/ec.h>
-#include <openssl/err.h>
-#include <openssl/evp.h>
-#include <openssl/hmac.h>
-#include <openssl/kdf.h>
-#include <openssl/rsa.h>
-#include <openssl/ssl.h>
-#ifndef OPENSSL_NO_ENGINE
-#  include <openssl/engine.h>
-#endif  // !OPENSSL_NO_ENGINE
-// The FIPS-related functions are only available
-// when the OpenSSL itself was compiled with FIPS support.
-#if defined(OPENSSL_FIPS) && OPENSSL_VERSION_MAJOR < 3
-#  include <openssl/fips.h>
-#endif  // OPENSSL_FIPS
+#include "crypto_wrapper.h"
+
+// #include <openssl/dsa.h>
+// #include <openssl/ec.h>
+// #include <openssl/err.h>
+// #include <openssl/evp.h>
+// #include <openssl/hmac.h>
+// #include <openssl/kdf.h>
+// #include <openssl/rsa.h>
+// #include <openssl/ssl.h>
+// #ifndef OPENSSL_NO_ENGINE
+// #  include <openssl/engine.h>
+// #endif  // !OPENSSL_NO_ENGINE
+// // The FIPS-related functions are only available
+// // when the OpenSSL itself was compiled with FIPS support.
+// #if defined(OPENSSL_FIPS) && OPENSSL_VERSION_MAJOR < 3
+// #  include <openssl/fips.h>
+// #endif  // OPENSSL_FIPS
 
 #include <algorithm>
 #include <climits>
@@ -54,30 +55,30 @@ constexpr size_t kSizeOf_EVP_PKEY_CTX = 80;
 constexpr size_t kSizeOf_HMAC_CTX = 32;
 
 // Define smart pointers for the most commonly used OpenSSL types:
-using X509Pointer = DeleteFnPtr<X509, X509_free>;
-using BIOPointer = DeleteFnPtr<BIO, BIO_free_all>;
-using SSLCtxPointer = DeleteFnPtr<SSL_CTX, SSL_CTX_free>;
-using SSLSessionPointer = DeleteFnPtr<SSL_SESSION, SSL_SESSION_free>;
-using SSLPointer = DeleteFnPtr<SSL, SSL_free>;
-using PKCS8Pointer = DeleteFnPtr<PKCS8_PRIV_KEY_INFO, PKCS8_PRIV_KEY_INFO_free>;
-using EVPKeyPointer = DeleteFnPtr<EVP_PKEY, EVP_PKEY_free>;
-using EVPKeyCtxPointer = DeleteFnPtr<EVP_PKEY_CTX, EVP_PKEY_CTX_free>;
-using EVPMDCtxPointer = DeleteFnPtr<EVP_MD_CTX, EVP_MD_CTX_free>;
-using RSAPointer = DeleteFnPtr<RSA, RSA_free>;
-using ECPointer = DeleteFnPtr<EC_KEY, EC_KEY_free>;
-using BignumPointer = DeleteFnPtr<BIGNUM, BN_clear_free>;
-using BignumCtxPointer = DeleteFnPtr<BN_CTX, BN_CTX_free>;
-using NetscapeSPKIPointer = DeleteFnPtr<NETSCAPE_SPKI, NETSCAPE_SPKI_free>;
-using ECGroupPointer = DeleteFnPtr<EC_GROUP, EC_GROUP_free>;
-using ECPointPointer = DeleteFnPtr<EC_POINT, EC_POINT_free>;
-using ECKeyPointer = DeleteFnPtr<EC_KEY, EC_KEY_free>;
-using DHPointer = DeleteFnPtr<DH, DH_free>;
-using ECDSASigPointer = DeleteFnPtr<ECDSA_SIG, ECDSA_SIG_free>;
-using HMACCtxPointer = DeleteFnPtr<HMAC_CTX, HMAC_CTX_free>;
-using CipherCtxPointer = DeleteFnPtr<EVP_CIPHER_CTX, EVP_CIPHER_CTX_free>;
-using RsaPointer = DeleteFnPtr<RSA, RSA_free>;
-using DsaPointer = DeleteFnPtr<DSA, DSA_free>;
-using DsaSigPointer = DeleteFnPtr<DSA_SIG, DSA_SIG_free>;
+using X509Pointer = DeleteFnPtr<X509, Thin_X509_free>;
+using BIOPointer = DeleteFnPtr<BIO, Thin_BIO_free_all>;
+using SSLCtxPointer = DeleteFnPtr<SSL_CTX, Thin_SSL_CTX_free>;
+using SSLSessionPointer = DeleteFnPtr<SSL_SESSION, Thin_SSL_SESSION_free>;
+using SSLPointer = DeleteFnPtr<SSL, Thin_SSL_free>;
+using PKCS8Pointer = DeleteFnPtr<PKCS8_PRIV_KEY_INFO, Thin_PKCS8_PRIV_KEY_INFO_free>;
+using EVPKeyPointer = DeleteFnPtr<EVP_PKEY, Thin_EVP_PKEY_free>;
+using EVPKeyCtxPointer = DeleteFnPtr<EVP_PKEY_CTX, Thin_EVP_PKEY_CTX_free>;
+using EVPMDCtxPointer = DeleteFnPtr<EVP_MD_CTX, Thin_EVP_MD_CTX_free>;
+using RSAPointer = DeleteFnPtr<RSA, Thin_RSA_free>;
+using ECPointer = DeleteFnPtr<EC_KEY, Thin_EC_KEY_free>;
+using BignumPointer = DeleteFnPtr<BIGNUM, Thin_BN_clear_free>;
+using BignumCtxPointer = DeleteFnPtr<BN_CTX, Thin_BN_CTX_free>;
+using NetscapeSPKIPointer = DeleteFnPtr<NETSCAPE_SPKI, Thin_NETSCAPE_SPKI_free>;
+using ECGroupPointer = DeleteFnPtr<EC_GROUP, Thin_EC_GROUP_free>;
+using ECPointPointer = DeleteFnPtr<EC_POINT, Thin_EC_POINT_free>;
+using ECKeyPointer = DeleteFnPtr<EC_KEY, Thin_EC_KEY_free>;
+using DHPointer = DeleteFnPtr<DH, Thin_DH_free>;
+using ECDSASigPointer = DeleteFnPtr<ECDSA_SIG, Thin_ECDSA_SIG_free>;
+using HMACCtxPointer = DeleteFnPtr<HMAC_CTX, Thin_HMAC_CTX_free>;
+using CipherCtxPointer = DeleteFnPtr<EVP_CIPHER_CTX, Thin_EVP_CIPHER_CTX_free>;
+using RsaPointer = DeleteFnPtr<RSA, Thin_RSA_free>;
+using DsaPointer = DeleteFnPtr<DSA, Thin_DSA_free>;
+using DsaSigPointer = DeleteFnPtr<DSA_SIG, Thin_DSA_SIG_free>;
 
 // Our custom implementation of the certificate verify callback
 // used when establishing a TLS handshake. Because we cannot perform
@@ -100,16 +101,16 @@ extern void UseExtraCaCerts(const std::string& file);
 // Forcibly clear OpenSSL's error stack on return. This stops stale errors
 // from popping up later in the lifecycle of crypto operations where they
 // would cause spurious failures. It's a rather blunt method, though.
-// ERR_clear_error() isn't necessarily cheap either.
+// Thin_ERR_clear_error() isn't necessarily cheap either.
 struct ClearErrorOnReturn {
-  ~ClearErrorOnReturn() { ERR_clear_error(); }
+  ~ClearErrorOnReturn() { Thin_ERR_clear_error(); }
 };
 
 // Pop errors from OpenSSL's error stack that were added
 // between when this was constructed and destructed.
 struct MarkPopErrorOnReturn {
-  MarkPopErrorOnReturn() { ERR_set_mark(); }
-  ~MarkPopErrorOnReturn() { ERR_pop_to_mark(); }
+  MarkPopErrorOnReturn() { Thin_ERR_set_mark(); }
+  ~MarkPopErrorOnReturn() { Thin_ERR_pop_to_mark(); }
 };
 
 struct CSPRNGResult {
@@ -202,7 +203,7 @@ void CryptoErrorStore::Insert(const NodeCryptoError error, Args&&... args) {
 
 template <typename T>
 T* MallocOpenSSL(size_t count) {
-  void* mem = OPENSSL_malloc(MultiplyWithOverflowCheck(count, sizeof(T)));
+  void* mem = Thin_OPENSSL_malloc(MultiplyWithOverflowCheck(count, sizeof(T)));
   CHECK_IMPLIES(mem == nullptr, count == 0);
   return static_cast<T*>(mem);
 }
@@ -222,7 +223,7 @@ class ByteSource {
     Builder(const Builder&) = delete;
     Builder& operator=(const Builder&) = delete;
 
-    ~Builder() { OPENSSL_clear_free(data_, size_); }
+    ~Builder() { Thin_OPENSSL_clear_free(data_, size_); }
 
     // Returns the underlying non-const pointer.
     template <typename T>
@@ -239,7 +240,7 @@ class ByteSource {
       if (resize) {
         CHECK_LE(*resize, size_);
         if (*resize == 0) {
-          OPENSSL_clear_free(data_, size_);
+          Thin_OPENSSL_clear_free(data_, size_);
           data_ = nullptr;
         }
         size_ = *resize;
@@ -274,7 +275,7 @@ class ByteSource {
   operator bool() const { return data_ != nullptr; }
 
   BignumPointer ToBN() const {
-    return BignumPointer(BN_bin2bn(data<unsigned char>(), size(), nullptr));
+    return BignumPointer(Thin_BN_bin2bn(data<unsigned char>(), size(), nullptr));
   }
 
   // Creates a v8::BackingStore that takes over responsibility for
@@ -579,10 +580,10 @@ struct EnginePointer {
   inline void reset(ENGINE* engine_ = nullptr, bool finish_on_exit_ = false) {
     if (engine != nullptr) {
       if (finish_on_exit) {
-        // This also does the equivalent of ENGINE_free.
-        CHECK_EQ(ENGINE_finish(engine), 1);
+        // This also does the equivalent of Thin_ENGINE_free.
+        CHECK_EQ(Thin_ENGINE_finish(engine), 1);
       } else {
-        CHECK_EQ(ENGINE_free(engine), 1);
+        CHECK_EQ(Thin_ENGINE_free(engine), 1);
       }
     }
     engine = engine_;
diff --git a/src/crypto/crypto_x509.cc b/src/crypto/crypto_x509.cc
index 84f2528a28..8279819b72 100644
--- a/src/crypto/crypto_x509.cc
+++ b/src/crypto/crypto_x509.cc
@@ -40,14 +40,14 @@ ManagedX509& ManagedX509::operator=(const ManagedX509& that) {
   cert_.reset(that.get());
 
   if (cert_)
-    X509_up_ref(cert_.get());
+    Thin_X509_up_ref(cert_.get());
 
   return *this;
 }
 
 void ManagedX509::MemoryInfo(MemoryTracker* tracker) const {
   // This is an approximation based on the der encoding size.
-  int size = i2d_X509(cert_.get(), nullptr);
+  int size = Thin_i2d_X509(cert_.get(), nullptr);
   tracker->TrackFieldWithSize("cert", size);
 }
 
@@ -79,9 +79,9 @@ Local<FunctionTemplate> X509Certificate::GetConstructorTemplate(
     SetProtoMethod(isolate, tmpl, "issuer", Issuer);
     SetProtoMethod(isolate, tmpl, "validTo", ValidTo);
     SetProtoMethod(isolate, tmpl, "validFrom", ValidFrom);
-    SetProtoMethod(isolate, tmpl, "fingerprint", Fingerprint<EVP_sha1>);
-    SetProtoMethod(isolate, tmpl, "fingerprint256", Fingerprint<EVP_sha256>);
-    SetProtoMethod(isolate, tmpl, "fingerprint512", Fingerprint<EVP_sha512>);
+    SetProtoMethod(isolate, tmpl, "fingerprint", Fingerprint<Thin_EVP_sha1>);
+    SetProtoMethod(isolate, tmpl, "fingerprint256", Fingerprint<Thin_EVP_sha256>);
+    SetProtoMethod(isolate, tmpl, "fingerprint512", Fingerprint<Thin_EVP_sha512>);
     SetProtoMethod(isolate, tmpl, "keyUsage", KeyUsage);
     SetProtoMethod(isolate, tmpl, "serialNumber", SerialNumber);
     SetProtoMethod(isolate, tmpl, "pem", Pem);
@@ -134,11 +134,11 @@ MaybeLocal<Object> X509Certificate::GetCert(
     Environment* env,
     const SSLPointer& ssl) {
   ClearErrorOnReturn clear_error_on_return;
-  X509* cert = SSL_get_certificate(ssl.get());
+  X509* cert = Thin_SSL_get_certificate(ssl.get());
   if (cert == nullptr)
     return MaybeLocal<Object>();
 
-  X509Pointer ptr(X509_dup(cert));
+  X509Pointer ptr(Thin_X509_dup(cert));
   return New(env, std::move(ptr));
 }
 
@@ -152,19 +152,19 @@ MaybeLocal<Object> X509Certificate::GetPeerCert(
   bool is_server =
       static_cast<int>(flag) & static_cast<int>(GetPeerCertificateFlag::SERVER);
 
-  X509Pointer cert(is_server ? SSL_get_peer_certificate(ssl.get()) : nullptr);
-  STACK_OF(X509)* ssl_certs = SSL_get_peer_cert_chain(ssl.get());
-  if (!cert && (ssl_certs == nullptr || sk_X509_num(ssl_certs) == 0))
+  X509Pointer cert(is_server ? Thin_SSL_get_peer_certificate(ssl.get()) : nullptr);
+  STACK_OF(X509)* ssl_certs = Thin_SSL_get_peer_cert_chain(ssl.get());
+  if (!cert && (ssl_certs == nullptr || Thin_sk_X509_num(ssl_certs) == 0))
     return MaybeLocal<Object>();
 
   std::vector<Local<Value>> certs;
 
   if (!cert) {
-    cert.reset(sk_X509_value(ssl_certs, 0));
-    sk_X509_delete(ssl_certs, 0);
+    cert.reset(Thin_sk_X509_value(ssl_certs, 0));
+    Thin_sk_X509_delete(ssl_certs, 0);
   }
 
-  return sk_X509_num(ssl_certs)
+  return Thin_sk_X509_num(ssl_certs)
       ? New(env, std::move(cert), ssl_certs)
       : New(env, std::move(cert));
 }
@@ -180,19 +180,19 @@ void X509Certificate::Parse(const FunctionCallbackInfo<Value>& args) {
   ClearErrorOnReturn clear_error_on_return;
   BIOPointer bio(LoadBIO(env, args[0]));
   if (!bio)
-    return ThrowCryptoError(env, ERR_get_error());
+    return ThrowCryptoError(env, Thin_ERR_get_error());
 
   Local<Object> cert;
 
-  X509Pointer pem(PEM_read_bio_X509_AUX(
+  X509Pointer pem(Thin_PEM_read_bio_X509_AUX(
       bio.get(), nullptr, NoPasswordCallback, nullptr));
   if (!pem) {
     // Try as DER, but return the original PEM failure if it isn't DER.
     MarkPopErrorOnReturn mark_here;
 
-    X509Pointer der(d2i_X509(nullptr, &data, data_len));
+    X509Pointer der(Thin_d2i_X509(nullptr, &data, data_len));
     if (!der)
-      return ThrowCryptoError(env, ERR_get_error());
+      return ThrowCryptoError(env, Thin_ERR_get_error());
 
     if (!X509Certificate::New(env, std::move(der)).ToLocal(&cert))
       return;
@@ -209,7 +209,7 @@ static void ReturnPropertyThroughBIO(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   X509Certificate* cert;
   ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
-  BIOPointer bio(BIO_new(BIO_s_mem()));
+  BIOPointer bio(Thin_BIO_new(Thin_BIO_s_mem()));
   CHECK(bio);
   Local<Value> ret;
   if (Property(env, cert->get(), bio).ToLocal(&ret))
@@ -266,11 +266,11 @@ void X509Certificate::PublicKey(const FunctionCallbackInfo<Value>& args) {
   X509Certificate* cert;
   ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
 
-  // TODO(tniessen): consider checking X509_get_pubkey() when the
+  // TODO(tniessen): consider checking Thin_X509_get_pubkey() when the
   // X509Certificate object is being created.
   ClearErrorOnReturn clear_error_on_return;
-  EVPKeyPointer pkey(X509_get_pubkey(cert->get()));
-  if (!pkey) return ThrowCryptoError(env, ERR_get_error());
+  EVPKeyPointer pkey(Thin_X509_get_pubkey(cert->get()));
+  if (!pkey) return ThrowCryptoError(env, Thin_ERR_get_error());
   ManagedEVPPKey epkey(std::move(pkey));
   std::shared_ptr<KeyObjectData> key_data =
       KeyObjectData::CreateAsymmetric(kKeyTypePublic, epkey);
@@ -284,9 +284,9 @@ void X509Certificate::Pem(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   X509Certificate* cert;
   ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
-  BIOPointer bio(BIO_new(BIO_s_mem()));
+  BIOPointer bio(Thin_BIO_new(Thin_BIO_s_mem()));
   CHECK(bio);
-  if (PEM_write_bio_X509(bio.get(), cert->get()))
+  if (Thin_PEM_write_bio_X509(bio.get(), cert->get()))
     args.GetReturnValue().Set(ToV8Value(env, bio));
 }
 
@@ -294,7 +294,7 @@ void X509Certificate::CheckCA(const FunctionCallbackInfo<Value>& args) {
   X509Certificate* cert;
   ClearErrorOnReturn clear_error_on_return;
   ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
-  args.GetReturnValue().Set(X509_check_ca(cert->get()) == 1);
+  args.GetReturnValue().Set(Thin_X509_check_ca(cert->get()) == 1);
 }
 
 void X509Certificate::CheckHost(const FunctionCallbackInfo<Value>& args) {
@@ -309,7 +309,7 @@ void X509Certificate::CheckHost(const FunctionCallbackInfo<Value>& args) {
   uint32_t flags = args[1].As<Uint32>()->Value();
   char* peername;
 
-  switch (X509_check_host(
+  switch (Thin_X509_check_host(
               cert->get(),
               *name,
               name.length(),
@@ -319,7 +319,7 @@ void X509Certificate::CheckHost(const FunctionCallbackInfo<Value>& args) {
       Local<Value> ret = args[0];
       if (peername != nullptr) {
         ret = OneByteString(env->isolate(), peername);
-        OPENSSL_free(peername);
+        Thin_OPENSSL_free(peername);
       }
       return args.GetReturnValue().Set(ret);
     }
@@ -343,7 +343,7 @@ void X509Certificate::CheckEmail(const FunctionCallbackInfo<Value>& args) {
   Utf8Value name(env->isolate(), args[0]);
   uint32_t flags = args[1].As<Uint32>()->Value();
 
-  switch (X509_check_email(
+  switch (Thin_X509_check_email(
               cert->get(),
               *name,
               name.length(),
@@ -370,7 +370,7 @@ void X509Certificate::CheckIP(const FunctionCallbackInfo<Value>& args) {
   Utf8Value name(env->isolate(), args[0]);
   uint32_t flags = args[1].As<Uint32>()->Value();
 
-  switch (X509_check_ip_asc(cert->get(), *name, flags)) {
+  switch (Thin_X509_check_ip_asc(cert->get(), *name, flags)) {
     case 1:  // Match!
       return args.GetReturnValue().Set(args[0]);
     case 0:  // No Match!
@@ -396,7 +396,7 @@ void X509Certificate::CheckIssued(const FunctionCallbackInfo<Value>& args) {
   ClearErrorOnReturn clear_error_on_return;
 
   args.GetReturnValue().Set(
-    X509_check_issued(issuer->get(), cert->get()) == X509_V_OK);
+    Thin_X509_check_issued(issuer->get(), cert->get()) == X509_V_OK);
 }
 
 void X509Certificate::CheckPrivateKey(const FunctionCallbackInfo<Value>& args) {
@@ -411,7 +411,7 @@ void X509Certificate::CheckPrivateKey(const FunctionCallbackInfo<Value>& args) {
   ClearErrorOnReturn clear_error_on_return;
 
   args.GetReturnValue().Set(
-      X509_check_private_key(
+      Thin_X509_check_private_key(
           cert->get(),
           key->Data()->GetAsymmetricKey().get()) == 1);
 }
@@ -428,7 +428,7 @@ void X509Certificate::Verify(const FunctionCallbackInfo<Value>& args) {
   ClearErrorOnReturn clear_error_on_return;
 
   args.GetReturnValue().Set(
-      X509_verify(
+      Thin_X509_verify(
           cert->get(),
           key->Data()->GetAsymmetricKey().get()) > 0);
 }
@@ -459,10 +459,10 @@ X509Certificate::X509Certificate(
       cert_(std::move(cert)) {
   MakeWeak();
 
-  if (issuer_chain != nullptr && sk_X509_num(issuer_chain)) {
-    X509Pointer cert(X509_dup(sk_X509_value(issuer_chain, 0)));
-    sk_X509_delete(issuer_chain, 0);
-    Local<Object> obj = sk_X509_num(issuer_chain)
+  if (issuer_chain != nullptr && Thin_sk_X509_num(issuer_chain)) {
+    X509Pointer cert(Thin_X509_dup(Thin_sk_X509_value(issuer_chain, 0)));
+    Thin_sk_X509_delete(issuer_chain, 0);
+    Local<Object> obj = Thin_sk_X509_num(issuer_chain)
         ? X509Certificate::New(env, std::move(cert), issuer_chain)
             .ToLocalChecked()
         : X509Certificate::New(env, std::move(cert))
@@ -524,9 +524,9 @@ void X509Certificate::RegisterExternalReferences(
   registry->Register(Issuer);
   registry->Register(ValidTo);
   registry->Register(ValidFrom);
-  registry->Register(Fingerprint<EVP_sha1>);
-  registry->Register(Fingerprint<EVP_sha256>);
-  registry->Register(Fingerprint<EVP_sha512>);
+  registry->Register(Fingerprint<Thin_EVP_sha1>);
+  registry->Register(Fingerprint<Thin_EVP_sha256>);
+  registry->Register(Fingerprint<Thin_EVP_sha512>);
   registry->Register(KeyUsage);
   registry->Register(SerialNumber);
   registry->Register(Pem);
diff --git a/src/env.h b/src/env.h
index 910c69b6d1..145e054a89 100644
--- a/src/env.h
+++ b/src/env.h
@@ -49,8 +49,8 @@
 #include "uv.h"
 #include "v8.h"
 
-#if HAVE_OPENSSL && OPENSSL_VERSION_MAJOR >= 3
-#include <openssl/evp.h>
+#if HAVE_OPENSSL // && OPENSSL_VERSION_MAJOR >= 3
+// #include <openssl/evp.h>
 #endif
 
 #include <array>
@@ -66,6 +66,8 @@
 #include <unordered_set>
 #include <vector>
 
+// extern void Thin_EVP_MD_free(EVP_MD *md);
+
 namespace v8 {
 class CppHeap;
 }
@@ -1036,11 +1038,11 @@ class Environment : public MemoryRetainer {
     kExitInfoFieldCount
   };
 
-#if HAVE_OPENSSL// && !defined(OPENSSL_IS_BORINGSSL)
+#if HAVE_OPENSSL
 #if OPENSSL_VERSION_MAJOR >= 3
   // We declare another alias here to avoid having to include crypto_util.h
-  using EVPMDPointer = DeleteFnPtr<EVP_MD, EVP_MD_free>;
-  std::vector<EVPMDPointer> evp_md_cache;
+  // using EVPMDPointer = DeleteFnPtr<EVP_MD, Thin_EVP_MD_free>;
+  // std::vector<EVPMDPointer> evp_md_cache;
 #endif  // OPENSSL_VERSION_MAJOR >= 3
   std::unordered_map<std::string, size_t> alias_to_md_id_map;
   std::vector<std::string> supported_hash_algorithms;
diff --git a/src/node.cc b/src/node.cc
index 7478ef81eb..722ff19b4c 100644
--- a/src/node.cc
+++ b/src/node.cc
@@ -1081,10 +1081,9 @@ InitializeOncePerProcessInternal(const std::vector<std::string>& args,
 
   if (!(flags & ProcessInitializationFlags::kNoInitOpenSSL)) {
 #if HAVE_OPENSSL
-#ifndef OPENSSL_IS_BORINGSSL
     auto GetOpenSSLErrorString = []() -> std::string {
       std::string ret;
-      ERR_print_errors_cb(
+      Thin_ERR_print_errors_cb(
           [](const char* str, size_t len, void* opaque) {
             std::string* ret = static_cast<std::string*>(opaque);
             ret->append(str, len);
@@ -1098,7 +1097,7 @@ InitializeOncePerProcessInternal(const std::vector<std::string>& args,
     // In the case of FIPS builds we should make sure
     // the random source is properly initialized first.
 #if OPENSSL_VERSION_MAJOR >= 3
-    // Call OPENSSL_init_crypto to initialize OPENSSL_INIT_LOAD_CONFIG to
+    // Call Thin_OPENSSL_init_crypto to initialize OPENSSL_INIT_LOAD_CONFIG to
     // avoid the default behavior where errors raised during the parsing of the
     // OpenSSL configuration file are not propagated and cannot be detected.
     //
@@ -1109,7 +1108,7 @@ InitializeOncePerProcessInternal(const std::vector<std::string>& args,
     //
     // For Node.js this will mean that CSPRNG() will be called by V8 as
     // part of its initialization process, and CSPRNG() will in turn call
-    // call RAND_status which will now always return 0, leading to an endless
+    // call Thin_RAND_status which will now always return 0, leading to an endless
     // loop and the node process will appear to hang/freeze.
 
     // Passing NULL as the config file will allow the default openssl.cnf file
@@ -1134,35 +1133,35 @@ InitializeOncePerProcessInternal(const std::vector<std::string>& args,
       conf_file = per_process::cli_options->openssl_config.c_str();
     }
 
-    OPENSSL_INIT_SETTINGS* settings = OPENSSL_INIT_new();
-    OPENSSL_INIT_set_config_filename(settings, conf_file);
-    OPENSSL_INIT_set_config_appname(settings, conf_section_name);
-    OPENSSL_INIT_set_config_file_flags(settings,
+    OPENSSL_INIT_SETTINGS* settings = Thin_OPENSSL_INIT_new();
+    Thin_OPENSSL_INIT_set_config_filename(settings, conf_file);
+    Thin_OPENSSL_INIT_set_config_appname(settings, conf_section_name);
+    Thin_OPENSSL_INIT_set_config_file_flags(settings,
                                        CONF_MFLAGS_IGNORE_MISSING_FILE);
 
-    OPENSSL_init_crypto(OPENSSL_INIT_LOAD_CONFIG, settings);
-    OPENSSL_INIT_free(settings);
+    Thin_OPENSSL_init_crypto(OPENSSL_INIT_LOAD_CONFIG, settings);
+    Thin_OPENSSL_INIT_free(settings);
 
-    if (ERR_peek_error() != 0) {
+    if (Thin_ERR_peek_error() != 0) {
       // XXX: ERR_GET_REASON does not return something that is
       // useful as an exit code at all.
       result->exit_code_ =
-          static_cast<ExitCode>(ERR_GET_REASON(ERR_peek_error()));
+          static_cast<ExitCode>(ERR_GET_REASON(Thin_ERR_peek_error()));
       result->early_return_ = true;
       result->errors_.emplace_back("OpenSSL configuration error:\n" +
                                    GetOpenSSLErrorString());
       return result;
     }
 #else  // OPENSSL_VERSION_MAJOR < 3
-    if (FIPS_mode()) {
-      OPENSSL_init();
+    if (Thin_FIPS_mode()) {
+      Thin_OPENSSL_init();
     }
 #endif
     if (!crypto::ProcessFipsOptions()) {
       // XXX: ERR_GET_REASON does not return something that is
       // useful as an exit code at all.
       result->exit_code_ =
-          static_cast<ExitCode>(ERR_GET_REASON(ERR_peek_error()));
+          static_cast<ExitCode>(ERR_GET_REASON(Thin_ERR_peek_error()));
       result->early_return_ = true;
       result->errors_.emplace_back(
           "OpenSSL error when trying to enable FIPS:\n" +
@@ -1181,7 +1180,7 @@ InitializeOncePerProcessInternal(const std::vector<std::string>& args,
       CHECK(crypto::CSPRNG(buffer, length).is_ok());
       return true;
     });
-#endif  // !defined(OPENSSL_IS_BORINGSSL)
+
     {
       std::string extra_ca_certs;
       if (credentials::SafeGetenv("NODE_EXTRA_CA_CERTS", &extra_ca_certs))
diff --git a/src/node_metadata.cc b/src/node_metadata.cc
index 72a75ee0bf..944b4b44f4 100644
--- a/src/node_metadata.cc
+++ b/src/node_metadata.cc
@@ -21,7 +21,7 @@
 #include <zlib.h>
 #endif  // NODE_BUNDLED_ZLIB
 
-#if HAVE_OPENSSL && !defined(OPENSSL_IS_BORINGSSL)
+#if HAVE_OPENSSL // && !defined(OPENSSL_IS_BORINGSSL)
 #include <openssl/opensslv.h>
 #if NODE_OPENSSL_HAS_QUIC
 #include <openssl/quic.h>
diff --git a/src/node_metadata.h b/src/node_metadata.h
index 9de49c6828..cf051585e7 100644
--- a/src/node_metadata.h
+++ b/src/node_metadata.h
@@ -6,7 +6,7 @@
 #include <string>
 #include "node_version.h"
 
-#if 0
+#if HAVE_OPENSSL
 #include <openssl/crypto.h>
 #if NODE_OPENSSL_HAS_QUIC
 #include <openssl/quic.h>
diff --git a/src/node_options.cc b/src/node_options.cc
index ee8e6f342b..8f9f799923 100644
--- a/src/node_options.cc
+++ b/src/node_options.cc
@@ -6,7 +6,7 @@
 #include "node_external_reference.h"
 #include "node_internals.h"
 #include "node_sea.h"
-#if HAVE_OPENSSL && !defined(OPENSSL_IS_BORINGSSL)
+#if HAVE_OPENSSL
 #include "openssl/opensslv.h"
 #endif
 
diff --git a/src/node_options.h b/src/node_options.h
index e1985f2188..0a2f5512f6 100644
--- a/src/node_options.h
+++ b/src/node_options.h
@@ -11,7 +11,7 @@
 #include "node_mutex.h"
 #include "util.h"
 
-#if 0
+#if HAVE_OPENSSL
 #include "openssl/opensslv.h"
 #endif
 
-- 
2.34.1

