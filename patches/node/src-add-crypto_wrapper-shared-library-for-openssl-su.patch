From bb5b230b3ee59ad6977e28486a28c6802f99fe9e Mon Sep 17 00:00:00 2001
From: Lin Cheng <lin_cheng@dell.com>
Date: Mon, 4 Sep 2023 11:27:37 +0000
Subject: [PATCH] src: add crypto wrapper shared library for openssl support

---
 BUILD.gn                        |   52 +-
 src/crypto/crypto_aes.cc        |   64 +-
 src/crypto/crypto_bio.cc        |   46 +-
 src/crypto/crypto_cipher.cc     |  198 ++--
 src/crypto/crypto_cipher.h      |    2 +-
 src/crypto/crypto_clienthello.h |    2 +-
 src/crypto/crypto_common.cc     |  360 +++---
 src/crypto/crypto_common.h      |    4 +-
 src/crypto/crypto_context.cc    |  308 +++---
 src/crypto/crypto_dh.cc         |  144 +--
 src/crypto/crypto_dsa.cc        |   24 +-
 src/crypto/crypto_ec.cc         |  214 ++--
 src/crypto/crypto_hash.cc       |   60 +-
 src/crypto/crypto_hkdf.cc       |   22 +-
 src/crypto/crypto_hmac.cc       |   24 +-
 src/crypto/crypto_keygen.cc     |    6 +-
 src/crypto/crypto_keygen.h      |    2 +-
 src/crypto/crypto_keys.cc       |  128 +--
 src/crypto/crypto_pbkdf2.cc     |    4 +-
 src/crypto/crypto_random.cc     |   26 +-
 src/crypto/crypto_rsa.cc        |  102 +-
 src/crypto/crypto_scrypt.cc     |    4 +-
 src/crypto/crypto_sig.cc        |  124 +--
 src/crypto/crypto_spkac.cc      |   18 +-
 src/crypto/crypto_timing.cc     |    2 +-
 src/crypto/crypto_tls.cc        |  232 ++--
 src/crypto/crypto_tls.h         |   20 +-
 src/crypto/crypto_util.cc       |  110 +-
 src/crypto/crypto_util.h        |   72 +-
 src/crypto/crypto_wrapper.cc    | 1827 +++++++++++++++++++++++++++++++
 src/crypto/crypto_wrapper.h     | 1141 +++++++++++++++++++
 src/crypto/crypto_x509.cc       |   80 +-
 src/node.cc                     |   28 +-
 33 files changed, 4233 insertions(+), 1217 deletions(-)
 create mode 100644 src/crypto/crypto_wrapper.cc
 create mode 100644 src/crypto/crypto_wrapper.h

diff --git a/BUILD.gn b/BUILD.gn
index a3e4599c21..8c2ee453d2 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -192,7 +192,7 @@ config("node_internal_config") {
   if (node_use_openssl) {
     defines += [
       "NODE_OPENSSL_SYSTEM_CERT_PATH=\"$node_openssl_system_ca_path\"",
-      "EVP_CTRL_CCM_SET_TAG=EVP_CTRL_GCM_SET_TAG",
+      #"EVP_CTRL_CCM_SET_TAG=EVP_CTRL_GCM_SET_TAG",
     ]
   }
 }
@@ -205,10 +205,53 @@ executable("overlapped-checker") {
     sources += [ "test/overlapped-checker/main_unix.c" ]
   }
 }
+shared_library("crypto_wrapper") {
+  defines = []
+  public_deps = [
+    "//electron:electron_js2c",
+  ]
+
+  configs += [ ":node_internal_config" ]
+  public_configs = [ ":node_lib_config" ]
+  include_dirs = [ "src", "deps/openssl/openssl/include" ]
+  libs = []
+  frameworks = []
+  cflags_c = []
+  sources = []
 
+  cflags_cc = [
+    "-Wno-deprecated-declarations",
+    "-Wno-implicit-fallthrough",
+    "-Wno-return-type",
+    "-Wno-sometimes-uninitialized",
+    "-Wno-string-plus-int",
+    "-Wno-unused-function",
+    "-Wno-unused-label",
+    "-Wno-unused-private-field",
+    "-Wno-unused-variable",
+    "-Wno-shadow",
+    "-Wno-unreachable-code",
+  ]
+
+  if (node_use_openssl) {
+    #deps = [ "//third_party/boringssl" ]
+    #libs += [ "ssl", "crypto" ]
+    libs += ["deps/openssl/openssl/libcrypto.so.3", "deps/openssl/openssl/libssl.so.3"]
+    sources += [
+      "src/crypto/crypto_wrapper.cc",
+      "src/crypto/crypto_wrapper.h",
+    ]
+    cflags_cc += [ "-Wno-sign-compare" ]
+  }
+
+  if (is_linux) {
+    defines += []
+  }
+}
 component("node_lib") {
   deps = [
     ":node_js2c",
+    ":crypto_wrapper",
     "deps/googletest:gtest",
     "deps/ada",
     "deps/base64",
@@ -238,7 +281,10 @@ component("node_lib") {
   public_configs = [ ":node_lib_config" ]
   include_dirs = [
     "src",
-    "deps/postject"
+    "deps/postject",
+    "deps/openssl/openssl/include",
+    "deps/ngtcp2/ngtcp2/lib/includes",
+    "deps/ngtcp2/nghttp3/lib/includes"
   ]
   libs = []
   if (use_system_llhttp) {
@@ -301,7 +347,7 @@ component("node_lib") {
   }
 
   if (node_use_openssl) {
-    deps += [ "//third_party/boringssl" ]
+    #deps += [ "//third_party/boringssl" ]
     sources += [
       "src/crypto/crypto_aes.cc",
       "src/crypto/crypto_aes.h",
diff --git a/src/crypto/crypto_aes.cc b/src/crypto/crypto_aes.cc
index c1c5bf762a..ba4344e802 100644
--- a/src/crypto/crypto_aes.cc
+++ b/src/crypto/crypto_aes.cc
@@ -41,16 +41,16 @@ WebCryptoCipherStatus AES_Cipher(
   CHECK_NOT_NULL(key_data);
   CHECK_EQ(key_data->GetKeyType(), kKeyTypeSecret);
 
-  const int mode = EVP_CIPHER_mode(params.cipher);
+  const int mode = Thin_EVP_CIPHER_mode(params.cipher);
 
-  CipherCtxPointer ctx(EVP_CIPHER_CTX_new());
-  EVP_CIPHER_CTX_init(ctx.get());
+  CipherCtxPointer ctx(Thin_EVP_CIPHER_CTX_new());
+  Thin_EVP_CIPHER_CTX_init(ctx.get());
   if (mode == EVP_CIPH_WRAP_MODE)
-    EVP_CIPHER_CTX_set_flags(ctx.get(), EVP_CIPHER_CTX_FLAG_WRAP_ALLOW);
+    Thin_EVP_CIPHER_CTX_set_flags(ctx.get(), EVP_CIPHER_CTX_FLAG_WRAP_ALLOW);
 
   const bool encrypt = cipher_mode == kWebCryptoCipherEncrypt;
 
-  if (!EVP_CipherInit_ex(
+  if (!Thin_EVP_CipherInit_ex(
           ctx.get(),
           params.cipher,
           nullptr,
@@ -61,7 +61,7 @@ WebCryptoCipherStatus AES_Cipher(
     return WebCryptoCipherStatus::FAILED;
   }
 
-  if (mode == EVP_CIPH_GCM_MODE && !EVP_CIPHER_CTX_ctrl(
+  if (mode == EVP_CIPH_GCM_MODE && !Thin_EVP_CIPHER_CTX_ctrl(
         ctx.get(),
         EVP_CTRL_AEAD_SET_IVLEN,
         params.iv.size(),
@@ -69,10 +69,10 @@ WebCryptoCipherStatus AES_Cipher(
     return WebCryptoCipherStatus::FAILED;
   }
 
-  if (!EVP_CIPHER_CTX_set_key_length(
+  if (!Thin_EVP_CIPHER_CTX_set_key_length(
           ctx.get(),
           key_data->GetSymmetricKeySize()) ||
-      !EVP_CipherInit_ex(
+      !Thin_EVP_CipherInit_ex(
           ctx.get(),
           nullptr,
           nullptr,
@@ -89,7 +89,7 @@ WebCryptoCipherStatus AES_Cipher(
       case kWebCryptoCipherDecrypt:
         // If in decrypt mode, the auth tag must be set in the params.tag.
         CHECK(params.tag);
-        if (!EVP_CIPHER_CTX_ctrl(ctx.get(),
+        if (!Thin_EVP_CIPHER_CTX_ctrl(ctx.get(),
                                  EVP_CTRL_AEAD_SET_TAG,
                                  params.tag.size(),
                                  const_cast<char*>(params.tag.data<char>()))) {
@@ -110,12 +110,12 @@ WebCryptoCipherStatus AES_Cipher(
   }
 
   size_t total = 0;
-  int buf_len = in.size() + EVP_CIPHER_CTX_block_size(ctx.get()) + tag_len;
+  int buf_len = in.size() + Thin_EVP_CIPHER_CTX_block_size(ctx.get()) + tag_len;
   int out_len;
 
   if (mode == EVP_CIPH_GCM_MODE &&
       params.additional_data.size() &&
-      !EVP_CipherUpdate(
+      !Thin_EVP_CipherUpdate(
             ctx.get(),
             nullptr,
             &out_len,
@@ -136,7 +136,7 @@ WebCryptoCipherStatus AES_Cipher(
   // Refs: https://github.com/nodejs/node/pull/38913#issuecomment-866505244
   if (in.size() == 0) {
     out_len = 0;
-  } else if (!EVP_CipherUpdate(ctx.get(),
+  } else if (!Thin_EVP_CipherUpdate(ctx.get(),
                                buf.data<unsigned char>(),
                                &out_len,
                                in.data<unsigned char>(),
@@ -146,8 +146,8 @@ WebCryptoCipherStatus AES_Cipher(
 
   total += out_len;
   CHECK_LE(out_len, buf_len);
-  out_len = EVP_CIPHER_CTX_block_size(ctx.get());
-  if (!EVP_CipherFinal_ex(
+  out_len = Thin_EVP_CIPHER_CTX_block_size(ctx.get());
+  if (!Thin_EVP_CipherFinal_ex(
           ctx.get(), buf.data<unsigned char>() + total, &out_len)) {
     return WebCryptoCipherStatus::FAILED;
   }
@@ -156,7 +156,7 @@ WebCryptoCipherStatus AES_Cipher(
   // If using AES_GCM, grab the generated auth tag and append
   // it to the end of the ciphertext.
   if (cipher_mode == kWebCryptoCipherEncrypt && mode == EVP_CIPH_GCM_MODE) {
-    if (!EVP_CIPHER_CTX_ctrl(ctx.get(),
+    if (!Thin_EVP_CIPHER_CTX_ctrl(ctx.get(),
                              EVP_CTRL_AEAD_GET_TAG,
                              tag_len,
                              buf.data<unsigned char>() + total))
@@ -185,7 +185,7 @@ BignumPointer GetCounter(const AESCipherConfig& params) {
 
   if (remainder == 0) {
     unsigned int byte_length = params.length / CHAR_BIT;
-    return BignumPointer(BN_bin2bn(
+    return BignumPointer(Thin_BN_bin2bn(
         data + params.iv.size() - byte_length,
         byte_length,
         nullptr));
@@ -199,7 +199,7 @@ BignumPointer GetCounter(const AESCipherConfig& params) {
       data + params.iv.size());
   counter[0] &= ~(0xFF << remainder);
 
-  return BignumPointer(BN_bin2bn(counter.data(), counter.size(), nullptr));
+  return BignumPointer(Thin_BN_bin2bn(counter.data(), counter.size(), nullptr));
 }
 
 std::vector<unsigned char> BlockWithZeroedCounter(
@@ -227,10 +227,10 @@ WebCryptoCipherStatus AES_CTR_Cipher2(
     const ByteSource& in,
     unsigned const char* counter,
     unsigned char* out) {
-  CipherCtxPointer ctx(EVP_CIPHER_CTX_new());
+  CipherCtxPointer ctx(Thin_EVP_CIPHER_CTX_new());
   const bool encrypt = cipher_mode == kWebCryptoCipherEncrypt;
 
-  if (!EVP_CipherInit_ex(
+  if (!Thin_EVP_CipherInit_ex(
           ctx.get(),
           params.cipher,
           nullptr,
@@ -243,7 +243,7 @@ WebCryptoCipherStatus AES_CTR_Cipher2(
 
   int out_len = 0;
   int final_len = 0;
-  if (!EVP_CipherUpdate(
+  if (!Thin_EVP_CipherUpdate(
           ctx.get(),
           out,
           &out_len,
@@ -252,7 +252,7 @@ WebCryptoCipherStatus AES_CTR_Cipher2(
     return WebCryptoCipherStatus::FAILED;
   }
 
-  if (!EVP_CipherFinal_ex(ctx.get(), out + out_len, &final_len))
+  if (!Thin_EVP_CipherFinal_ex(ctx.get(), out + out_len, &final_len))
     return WebCryptoCipherStatus::FAILED;
 
   out_len += final_len;
@@ -269,24 +269,24 @@ WebCryptoCipherStatus AES_CTR_Cipher(
     const AESCipherConfig& params,
     const ByteSource& in,
     ByteSource* out) {
-  BignumPointer num_counters(BN_new());
-  if (!BN_lshift(num_counters.get(), BN_value_one(), params.length))
+  BignumPointer num_counters(Thin_BN_new());
+  if (!Thin_BN_lshift(num_counters.get(), Thin_BN_value_one(), params.length))
     return WebCryptoCipherStatus::FAILED;
 
   BignumPointer current_counter = GetCounter(params);
 
-  BignumPointer num_output(BN_new());
+  BignumPointer num_output(Thin_BN_new());
 
-  if (!BN_set_word(num_output.get(), CeilDiv(in.size(), kAesBlockSize)))
+  if (!Thin_BN_set_word(num_output.get(), CeilDiv(in.size(), kAesBlockSize)))
     return WebCryptoCipherStatus::FAILED;
 
   // Just like in chromium's implementation, if the counter will
   // be incremented more than there are counter values, we fail.
-  if (BN_cmp(num_output.get(), num_counters.get()) > 0)
+  if (Thin_BN_cmp(num_output.get(), num_counters.get()) > 0)
     return WebCryptoCipherStatus::FAILED;
 
-  BignumPointer remaining_until_reset(BN_new());
-  if (!BN_sub(remaining_until_reset.get(),
+  BignumPointer remaining_until_reset(Thin_BN_new());
+  if (!Thin_BN_sub(remaining_until_reset.get(),
               num_counters.get(),
               current_counter.get())) {
     return WebCryptoCipherStatus::FAILED;
@@ -298,7 +298,7 @@ WebCryptoCipherStatus AES_CTR_Cipher(
   // Also just like in chromium's implementation, if we can process
   // the input without wrapping the counter, we'll do it as a single
   // call here. If we can't, we'll fallback to the a two-step approach
-  if (BN_cmp(remaining_until_reset.get(), num_output.get()) >= 0) {
+  if (Thin_BN_cmp(remaining_until_reset.get(), num_output.get()) >= 0) {
     auto status = AES_CTR_Cipher2(key_data,
                                   cipher_mode,
                                   params,
@@ -309,7 +309,7 @@ WebCryptoCipherStatus AES_CTR_Cipher(
     return status;
   }
 
-  BN_ULONG blocks_part1 = BN_get_word(remaining_until_reset.get());
+  BN_ULONG blocks_part1 = Thin_BN_get_word(remaining_until_reset.get());
   BN_ULONG input_size_part1 = blocks_part1 * kAesBlockSize;
 
   // Encrypt the first part...
@@ -555,14 +555,14 @@ Maybe<bool> AESCipherTraits::AdditionalConfig(
       UNREACHABLE();
   }
 
-  params->cipher = EVP_get_cipherbynid(cipher_nid);
+  params->cipher = Thin_EVP_get_cipherbynid(cipher_nid);
   if (params->cipher == nullptr) {
     THROW_ERR_CRYPTO_UNKNOWN_CIPHER(env);
     return Nothing<bool>();
   }
 
   if (params->iv.size() <
-      static_cast<size_t>(EVP_CIPHER_iv_length(params->cipher))) {
+      static_cast<size_t>(Thin_EVP_CIPHER_iv_length(params->cipher))) {
     THROW_ERR_CRYPTO_INVALID_IV(env);
     return Nothing<bool>();
   }
diff --git a/src/crypto/crypto_bio.cc b/src/crypto/crypto_bio.cc
index 47045365ce..35d9358399 100644
--- a/src/crypto/crypto_bio.cc
+++ b/src/crypto/crypto_bio.cc
@@ -33,7 +33,7 @@ namespace node {
 namespace crypto {
 
 BIOPointer NodeBIO::New(Environment* env) {
-  BIOPointer bio(BIO_new(GetMethod()));
+  BIOPointer bio(Thin_BIO_new(GetMethod()));
   if (bio && env != nullptr)
     NodeBIO::FromBIO(bio.get())->env_ = env;
   return bio;
@@ -45,8 +45,8 @@ BIOPointer NodeBIO::NewFixed(const char* data, size_t len, Environment* env) {
 
   if (!bio ||
       len > INT_MAX ||
-      BIO_write(bio.get(), data, len) != static_cast<int>(len) ||
-      BIO_set_mem_eof_return(bio.get(), 0) != 1) {
+      Thin_BIO_write(bio.get(), data, len) != static_cast<int>(len) ||
+      Thin_BIO_set_mem_eof_return(bio.get(), 0) != 1) {
     return BIOPointer();
   }
 
@@ -55,8 +55,8 @@ BIOPointer NodeBIO::NewFixed(const char* data, size_t len, Environment* env) {
 
 
 int NodeBIO::New(BIO* bio) {
-  BIO_set_data(bio, new NodeBIO());
-  BIO_set_init(bio, 1);
+  Thin_BIO_set_data(bio, new NodeBIO());
+  Thin_BIO_set_init(bio, 1);
 
   return 1;
 }
@@ -66,10 +66,10 @@ int NodeBIO::Free(BIO* bio) {
   if (bio == nullptr)
     return 0;
 
-  if (BIO_get_shutdown(bio)) {
-    if (BIO_get_init(bio) && BIO_get_data(bio) != nullptr) {
+  if (Thin_BIO_get_shutdown(bio)) {
+    if (Thin_BIO_get_init(bio) && Thin_BIO_get_data(bio) != nullptr) {
       delete FromBIO(bio);
-      BIO_set_data(bio, nullptr);
+      Thin_BIO_set_data(bio, nullptr);
     }
   }
 
@@ -78,7 +78,7 @@ int NodeBIO::Free(BIO* bio) {
 
 
 int NodeBIO::Read(BIO* bio, char* out, int len) {
-  BIO_clear_retry_flags(bio);
+  Thin_BIO_clear_retry_flags(bio);
 
   NodeBIO* nbio = FromBIO(bio);
   int bytes = nbio->Read(out, len);
@@ -86,7 +86,7 @@ int NodeBIO::Read(BIO* bio, char* out, int len) {
   if (bytes == 0) {
     bytes = nbio->eof_return();
     if (bytes != 0) {
-      BIO_set_retry_read(bio);
+      Thin_BIO_set_retry_read(bio);
     }
   }
 
@@ -128,7 +128,7 @@ size_t NodeBIO::PeekMultiple(char** out, size_t* size, size_t* count) {
 
 
 int NodeBIO::Write(BIO* bio, const char* data, int len) {
-  BIO_clear_retry_flags(bio);
+  Thin_BIO_clear_retry_flags(bio);
 
   FromBIO(bio)->Write(data, len);
 
@@ -194,10 +194,10 @@ long NodeBIO::Ctrl(BIO* bio, int cmd, long num,  // NOLINT(runtime/int)
     case BIO_C_GET_BUF_MEM_PTR:
       UNREACHABLE("Can't use GET_BUF_MEM_PTR with NodeBIO");
     case BIO_CTRL_GET_CLOSE:
-      ret = BIO_get_shutdown(bio);
+      ret = Thin_BIO_get_shutdown(bio);
       break;
     case BIO_CTRL_SET_CLOSE:
-      BIO_set_shutdown(bio, num);
+      Thin_BIO_set_shutdown(bio, num);
       break;
     case BIO_CTRL_WPENDING:
       ret = 0;
@@ -222,14 +222,14 @@ long NodeBIO::Ctrl(BIO* bio, int cmd, long num,  // NOLINT(runtime/int)
 const BIO_METHOD* NodeBIO::GetMethod() {
   // Static initialization ensures that this is safe to use concurrently.
   static const BIO_METHOD* method = [&]() {
-    BIO_METHOD* method = BIO_meth_new(BIO_TYPE_MEM, "node.js SSL buffer");
-    BIO_meth_set_write(method, Write);
-    BIO_meth_set_read(method, Read);
-    BIO_meth_set_puts(method, Puts);
-    BIO_meth_set_gets(method, Gets);
-    BIO_meth_set_ctrl(method, Ctrl);
-    BIO_meth_set_create(method, New);
-    BIO_meth_set_destroy(method, Free);
+    BIO_METHOD* method = Thin_BIO_meth_new(BIO_TYPE_MEM, "node.js SSL buffer");
+    Thin_BIO_meth_set_write(method, Write);
+    Thin_BIO_meth_set_read(method, Read);
+    Thin_BIO_meth_set_puts(method, Puts);
+    Thin_BIO_meth_set_gets(method, Gets);
+    Thin_BIO_meth_set_ctrl(method, Ctrl);
+    Thin_BIO_meth_set_create(method, New);
+    Thin_BIO_meth_set_destroy(method, Free);
     return method;
   }();
 
@@ -491,8 +491,8 @@ NodeBIO::~NodeBIO() {
 
 
 NodeBIO* NodeBIO::FromBIO(BIO* bio) {
-  CHECK_NOT_NULL(BIO_get_data(bio));
-  return static_cast<NodeBIO*>(BIO_get_data(bio));
+  CHECK_NOT_NULL(Thin_BIO_get_data(bio));
+  return static_cast<NodeBIO*>(Thin_BIO_get_data(bio));
 }
 
 
diff --git a/src/crypto/crypto_cipher.cc b/src/crypto/crypto_cipher.cc
index 2685f5ea0b..cc7e54fa1c 100644
--- a/src/crypto/crypto_cipher.cc
+++ b/src/crypto/crypto_cipher.cc
@@ -27,7 +27,7 @@ using v8::Value;
 namespace crypto {
 namespace {
 bool IsSupportedAuthenticatedMode(const EVP_CIPHER* cipher) {
-  switch (EVP_CIPHER_mode(cipher)) {
+  switch (Thin_EVP_CIPHER_mode(cipher)) {
   case EVP_CIPH_CCM_MODE:
   case EVP_CIPH_GCM_MODE:
 #ifndef OPENSSL_NO_OCB
@@ -35,14 +35,14 @@ bool IsSupportedAuthenticatedMode(const EVP_CIPHER* cipher) {
 #endif
     return true;
   case EVP_CIPH_STREAM_CIPHER:
-    return EVP_CIPHER_nid(cipher) == NID_chacha20_poly1305;
+    return Thin_EVP_CIPHER_nid(cipher) == NID_chacha20_poly1305;
   default:
     return false;
   }
 }
 
 bool IsSupportedAuthenticatedMode(const EVP_CIPHER_CTX* ctx) {
-  const EVP_CIPHER* cipher = EVP_CIPHER_CTX_cipher(ctx);
+  const EVP_CIPHER* cipher = Thin_EVP_CIPHER_CTX_cipher(ctx);
   return IsSupportedAuthenticatedMode(cipher);
 }
 
@@ -61,19 +61,19 @@ void GetCipherInfo(const FunctionCallbackInfo<Value>& args) {
   const EVP_CIPHER* cipher;
   if (args[1]->IsString()) {
     Utf8Value name(env->isolate(), args[1]);
-    cipher = EVP_get_cipherbyname(*name);
+    cipher = Thin_EVP_get_cipherbyname(*name);
   } else {
     int nid = args[1].As<Int32>()->Value();
-    cipher = EVP_get_cipherbynid(nid);
+    cipher = Thin_EVP_get_cipherbynid(nid);
   }
 
   if (cipher == nullptr)
     return;
 
-  int mode = EVP_CIPHER_mode(cipher);
-  int iv_length = EVP_CIPHER_iv_length(cipher);
-  int key_length = EVP_CIPHER_key_length(cipher);
-  int block_length = EVP_CIPHER_block_size(cipher);
+  int mode = Thin_EVP_CIPHER_mode(cipher);
+  int iv_length = Thin_EVP_CIPHER_iv_length(cipher);
+  int key_length = Thin_EVP_CIPHER_key_length(cipher);
+  int block_length = Thin_EVP_CIPHER_block_size(cipher);
   const char* mode_label = nullptr;
   switch (mode) {
     case EVP_CIPH_CBC_MODE: mode_label = "cbc"; break;
@@ -98,13 +98,13 @@ void GetCipherInfo(const FunctionCallbackInfo<Value>& args) {
     // Test and input IV or key length to determine if it's acceptable.
     // If it is, then the getCipherInfo will succeed with the given
     // values.
-    CipherCtxPointer ctx(EVP_CIPHER_CTX_new());
-    if (!EVP_CipherInit_ex(ctx.get(), cipher, nullptr, nullptr, nullptr, 1))
+    CipherCtxPointer ctx(Thin_EVP_CIPHER_CTX_new());
+    if (!Thin_EVP_CipherInit_ex(ctx.get(), cipher, nullptr, nullptr, nullptr, 1))
       return;
 
     if (args[2]->IsInt32()) {
       int check_len = args[2].As<Int32>()->Value();
-      if (!EVP_CIPHER_CTX_set_key_length(ctx.get(), check_len))
+      if (!Thin_EVP_CIPHER_CTX_set_key_length(ctx.get(), check_len))
         return;
       key_length = check_len;
     }
@@ -123,7 +123,7 @@ void GetCipherInfo(const FunctionCallbackInfo<Value>& args) {
         case EVP_CIPH_GCM_MODE:
           // Fall through
         case EVP_CIPH_OCB_MODE:
-          if (!EVP_CIPHER_CTX_ctrl(
+          if (!Thin_EVP_CIPHER_CTX_ctrl(
                   ctx.get(),
                   EVP_CTRL_AEAD_SET_IVLEN,
                   check_len,
@@ -147,21 +147,21 @@ void GetCipherInfo(const FunctionCallbackInfo<Value>& args) {
     return;
   }
 
-  // OBJ_nid2sn(EVP_CIPHER_nid(cipher)) is used here instead of
+  // Thin_OBJ_nid2sn(Thin_EVP_CIPHER_nid(cipher)) is used here instead of
   // EVP_CIPHER_name(cipher) for compatibility with BoringSSL.
   if (info->Set(
           env->context(),
           env->name_string(),
           OneByteString(
             env->isolate(),
-            OBJ_nid2sn(EVP_CIPHER_nid(cipher)))).IsNothing()) {
+            Thin_OBJ_nid2sn(Thin_EVP_CIPHER_nid(cipher)))).IsNothing()) {
     return;
   }
 
   if (info->Set(
           env->context(),
           FIXED_ONE_BYTE_STRING(env->isolate(), "nid"),
-          Int32::New(env->isolate(), EVP_CIPHER_nid(cipher))).IsNothing()) {
+          Int32::New(env->isolate(), Thin_EVP_CIPHER_nid(cipher))).IsNothing()) {
     return;
   }
 
@@ -197,17 +197,17 @@ void GetCipherInfo(const FunctionCallbackInfo<Value>& args) {
 void CipherBase::GetSSLCiphers(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
 
-  SSLCtxPointer ctx(SSL_CTX_new(TLS_method()));
+  SSLCtxPointer ctx(Thin_SSL_CTX_new(Thin_TLS_method()));
   if (!ctx) {
-    return ThrowCryptoError(env, ERR_get_error(), "SSL_CTX_new");
+    return ThrowCryptoError(env, Thin_ERR_get_error(), "Thin_SSL_CTX_new");
   }
 
-  SSLPointer ssl(SSL_new(ctx.get()));
+  SSLPointer ssl(Thin_SSL_new(ctx.get()));
   if (!ssl) {
-    return ThrowCryptoError(env, ERR_get_error(), "SSL_new");
+    return ThrowCryptoError(env, Thin_ERR_get_error(), "Thin_SSL_new");
   }
 
-  STACK_OF(SSL_CIPHER)* ciphers = SSL_get_ciphers(ssl.get());
+  STACK_OF(SSL_CIPHER)* ciphers = Thin_SSL_get_ciphers(ssl.get());
 
   // TLSv1.3 ciphers aren't listed by EVP. There are only 5, we could just
   // document them, but since there are only 5, easier to just add them manually
@@ -221,12 +221,12 @@ void CipherBase::GetSSLCiphers(const FunctionCallbackInfo<Value>& args) {
     "tls_aes_128_ccm_sha256"
   };
 
-  const int n = sk_SSL_CIPHER_num(ciphers);
+  const int n = Thin_sk_SSL_CIPHER_num(ciphers);
   std::vector<Local<Value>> arr(n + arraysize(TLS13_CIPHERS));
 
   for (int i = 0; i < n; ++i) {
-    const SSL_CIPHER* cipher = sk_SSL_CIPHER_value(ciphers, i);
-    arr[i] = OneByteString(env->isolate(), SSL_CIPHER_get_name(cipher));
+    const SSL_CIPHER* cipher = Thin_sk_SSL_CIPHER_value(ciphers, i);
+    arr[i] = OneByteString(env->isolate(), Thin_SSL_CIPHER_get_name(cipher));
   }
 
   for (unsigned i = 0; i < arraysize(TLS13_CIPHERS); ++i) {
@@ -241,13 +241,13 @@ void CipherBase::GetCiphers(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   MarkPopErrorOnReturn mark_pop_error_on_return;
   CipherPushContext ctx(env);
-  EVP_CIPHER_do_all_sorted(
+  Thin_EVP_CIPHER_do_all_sorted(
 #if OPENSSL_VERSION_MAJOR >= 3
     array_push_back<EVP_CIPHER,
-                    EVP_CIPHER_fetch,
-                    EVP_CIPHER_free,
-                    EVP_get_cipherbyname,
-                    EVP_CIPHER_get0_name>,
+                    Thin_EVP_CIPHER_fetch,
+                    Thin_EVP_CIPHER_free,
+                    Thin_EVP_get_cipherbyname,
+                    Thin_EVP_CIPHER_get0_name>,
 #else
     array_push_back<EVP_CIPHER>,
 #endif
@@ -298,26 +298,26 @@ void CipherBase::Initialize(Environment* env, Local<Object> target) {
             target,
             "publicEncrypt",
             PublicKeyCipher::Cipher<PublicKeyCipher::kPublic,
-                                    EVP_PKEY_encrypt_init,
-                                    EVP_PKEY_encrypt>);
+                                    Thin_EVP_PKEY_encrypt_init,
+                                    Thin_EVP_PKEY_encrypt>);
   SetMethod(context,
             target,
             "privateDecrypt",
             PublicKeyCipher::Cipher<PublicKeyCipher::kPrivate,
-                                    EVP_PKEY_decrypt_init,
-                                    EVP_PKEY_decrypt>);
+                                    Thin_EVP_PKEY_decrypt_init,
+                                    Thin_EVP_PKEY_decrypt>);
   SetMethod(context,
             target,
             "privateEncrypt",
             PublicKeyCipher::Cipher<PublicKeyCipher::kPrivate,
-                                    EVP_PKEY_sign_init,
-                                    EVP_PKEY_sign>);
+                                    Thin_EVP_PKEY_sign_init,
+                                    Thin_EVP_PKEY_sign>);
   SetMethod(context,
             target,
             "publicDecrypt",
             PublicKeyCipher::Cipher<PublicKeyCipher::kPublic,
-                                    EVP_PKEY_verify_recover_init,
-                                    EVP_PKEY_verify_recover>);
+                                    Thin_EVP_PKEY_verify_recover_init,
+                                    Thin_EVP_PKEY_verify_recover>);
 
   SetMethodNoSideEffect(context, target, "getCipherInfo", GetCipherInfo);
 
@@ -342,17 +342,17 @@ void CipherBase::RegisterExternalReferences(
   registry->Register(GetCiphers);
 
   registry->Register(PublicKeyCipher::Cipher<PublicKeyCipher::kPublic,
-                                             EVP_PKEY_encrypt_init,
-                                             EVP_PKEY_encrypt>);
+                                             Thin_EVP_PKEY_encrypt_init,
+                                             Thin_EVP_PKEY_encrypt>);
   registry->Register(PublicKeyCipher::Cipher<PublicKeyCipher::kPrivate,
-                                             EVP_PKEY_decrypt_init,
-                                             EVP_PKEY_decrypt>);
+                                             Thin_EVP_PKEY_decrypt_init,
+                                             Thin_EVP_PKEY_decrypt>);
   registry->Register(PublicKeyCipher::Cipher<PublicKeyCipher::kPrivate,
-                                             EVP_PKEY_sign_init,
-                                             EVP_PKEY_sign>);
+                                             Thin_EVP_PKEY_sign_init,
+                                             Thin_EVP_PKEY_sign>);
   registry->Register(PublicKeyCipher::Cipher<PublicKeyCipher::kPublic,
-                                             EVP_PKEY_verify_recover_init,
-                                             EVP_PKEY_verify_recover>);
+                                             Thin_EVP_PKEY_verify_recover_init,
+                                             Thin_EVP_PKEY_verify_recover>);
 
   registry->Register(GetCipherInfo);
 }
@@ -371,16 +371,16 @@ void CipherBase::CommonInit(const char* cipher_type,
                             int iv_len,
                             unsigned int auth_tag_len) {
   CHECK(!ctx_);
-  ctx_.reset(EVP_CIPHER_CTX_new());
+  ctx_.reset(Thin_EVP_CIPHER_CTX_new());
 
-  const int mode = EVP_CIPHER_mode(cipher);
+  const int mode = Thin_EVP_CIPHER_mode(cipher);
   if (mode == EVP_CIPH_WRAP_MODE)
-    EVP_CIPHER_CTX_set_flags(ctx_.get(), EVP_CIPHER_CTX_FLAG_WRAP_ALLOW);
+    Thin_EVP_CIPHER_CTX_set_flags(ctx_.get(), EVP_CIPHER_CTX_FLAG_WRAP_ALLOW);
 
   const bool encrypt = (kind_ == kCipher);
-  if (1 != EVP_CipherInit_ex(ctx_.get(), cipher, nullptr,
+  if (1 != Thin_EVP_CipherInit_ex(ctx_.get(), cipher, nullptr,
                              nullptr, nullptr, encrypt)) {
-    return ThrowCryptoError(env(), ERR_get_error(),
+    return ThrowCryptoError(env(), Thin_ERR_get_error(),
                             "Failed to initialize cipher");
   }
 
@@ -390,13 +390,13 @@ void CipherBase::CommonInit(const char* cipher_type,
       return;
   }
 
-  if (!EVP_CIPHER_CTX_set_key_length(ctx_.get(), key_len)) {
+  if (!Thin_EVP_CIPHER_CTX_set_key_length(ctx_.get(), key_len)) {
     ctx_.reset();
     return THROW_ERR_CRYPTO_INVALID_KEYLEN(env());
   }
 
-  if (1 != EVP_CipherInit_ex(ctx_.get(), nullptr, nullptr, key, iv, encrypt)) {
-    return ThrowCryptoError(env(), ERR_get_error(),
+  if (1 != Thin_EVP_CipherInit_ex(ctx_.get(), nullptr, nullptr, key, iv, encrypt)) {
+    return ThrowCryptoError(env(), Thin_ERR_get_error(),
                             "Failed to initialize cipher");
   }
 }
@@ -407,23 +407,23 @@ void CipherBase::Init(const char* cipher_type,
   HandleScope scope(env()->isolate());
   MarkPopErrorOnReturn mark_pop_error_on_return;
 #if OPENSSL_VERSION_MAJOR >= 3
-  if (EVP_default_properties_is_fips_enabled(nullptr)) {
+  if (Thin_EVP_default_properties_is_fips_enabled(nullptr)) {
 #else
-  if (FIPS_mode()) {
+  if (Thin_FIPS_mode()) {
 #endif
     return THROW_ERR_CRYPTO_UNSUPPORTED_OPERATION(env(),
         "crypto.createCipher() is not supported in FIPS mode.");
   }
 
-  const EVP_CIPHER* const cipher = EVP_get_cipherbyname(cipher_type);
+  const EVP_CIPHER* const cipher = Thin_EVP_get_cipherbyname(cipher_type);
   if (cipher == nullptr)
     return THROW_ERR_CRYPTO_UNKNOWN_CIPHER(env());
 
   unsigned char key[EVP_MAX_KEY_LENGTH];
   unsigned char iv[EVP_MAX_IV_LENGTH];
 
-  int key_len = EVP_BytesToKey(cipher,
-                               EVP_md5(),
+  int key_len = Thin_EVP_BytesToKey(cipher,
+                               Thin_EVP_md5(),
                                nullptr,
                                key_buf.data(),
                                key_buf.size(),
@@ -432,7 +432,7 @@ void CipherBase::Init(const char* cipher_type,
                                iv);
   CHECK_NE(key_len, 0);
 
-  const int mode = EVP_CIPHER_mode(cipher);
+  const int mode = Thin_EVP_CIPHER_mode(cipher);
   if (kind_ == kCipher && (mode == EVP_CIPH_CTR_MODE ||
                            mode == EVP_CIPH_GCM_MODE ||
                            mode == EVP_CIPH_CCM_MODE)) {
@@ -444,7 +444,7 @@ void CipherBase::Init(const char* cipher_type,
   }
 
   CommonInit(cipher_type, cipher, key, key_len, iv,
-             EVP_CIPHER_iv_length(cipher), auth_tag_len);
+             Thin_EVP_CIPHER_iv_length(cipher), auth_tag_len);
 }
 
 void CipherBase::Init(const FunctionCallbackInfo<Value>& args) {
@@ -479,11 +479,11 @@ void CipherBase::InitIv(const char* cipher_type,
   HandleScope scope(env()->isolate());
   MarkPopErrorOnReturn mark_pop_error_on_return;
 
-  const EVP_CIPHER* const cipher = EVP_get_cipherbyname(cipher_type);
+  const EVP_CIPHER* const cipher = Thin_EVP_get_cipherbyname(cipher_type);
   if (cipher == nullptr)
     return THROW_ERR_CRYPTO_UNKNOWN_CIPHER(env());
 
-  const int expected_iv_len = EVP_CIPHER_iv_length(cipher);
+  const int expected_iv_len = Thin_EVP_CIPHER_iv_length(cipher);
   const bool is_authenticated_mode = IsSupportedAuthenticatedMode(cipher);
   const bool has_iv = iv_buf.size() > 0;
 
@@ -500,7 +500,7 @@ void CipherBase::InitIv(const char* cipher_type,
     return THROW_ERR_CRYPTO_INVALID_IV(env());
   }
 
-  if (EVP_CIPHER_nid(cipher) == NID_chacha20_poly1305) {
+  if (Thin_EVP_CIPHER_nid(cipher) == NID_chacha20_poly1305) {
     CHECK(has_iv);
     // Check for invalid IV lengths, since OpenSSL does not under some
     // conditions:
@@ -562,7 +562,7 @@ bool CipherBase::InitAuthenticated(
   CHECK(IsAuthenticatedMode());
   MarkPopErrorOnReturn mark_pop_error_on_return;
 
-  if (!EVP_CIPHER_CTX_ctrl(ctx_.get(),
+  if (!Thin_EVP_CIPHER_CTX_ctrl(ctx_.get(),
                            EVP_CTRL_AEAD_SET_IVLEN,
                            iv_len,
                            nullptr)) {
@@ -570,7 +570,7 @@ bool CipherBase::InitAuthenticated(
     return false;
   }
 
-  const int mode = EVP_CIPHER_CTX_mode(ctx_.get());
+  const int mode = Thin_EVP_CIPHER_CTX_mode(ctx_.get());
   if (mode == EVP_CIPH_GCM_MODE) {
     if (auth_tag_len != kNoAuthTagLength) {
       if (!IsValidGCMTagLength(auth_tag_len)) {
@@ -590,7 +590,7 @@ bool CipherBase::InitAuthenticated(
       // length defaults to 16 bytes when encrypting. Unlike GCM, the
       // authentication tag length also defaults to 16 bytes when decrypting,
       // whereas GCM would accept any valid authentication tag length.
-      if (EVP_CIPHER_CTX_nid(ctx_.get()) == NID_chacha20_poly1305) {
+      if (Thin_EVP_CIPHER_CTX_nid(ctx_.get()) == NID_chacha20_poly1305) {
         auth_tag_len = 16;
       } else {
         THROW_ERR_CRYPTO_INVALID_AUTH_TAG(
@@ -603,9 +603,9 @@ bool CipherBase::InitAuthenticated(
 
 #if OPENSSL_VERSION_MAJOR >= 3
     if (mode == EVP_CIPH_CCM_MODE && kind_ == kDecipher &&
-        EVP_default_properties_is_fips_enabled(nullptr)) {
+        Thin_EVP_default_properties_is_fips_enabled(nullptr)) {
 #else
-    if (mode == EVP_CIPH_CCM_MODE && kind_ == kDecipher && FIPS_mode()) {
+    if (mode == EVP_CIPH_CCM_MODE && kind_ == kDecipher && Thin_FIPS_mode()) {
 #endif
       THROW_ERR_CRYPTO_UNSUPPORTED_OPERATION(env(),
           "CCM encryption not supported in FIPS mode");
@@ -613,7 +613,7 @@ bool CipherBase::InitAuthenticated(
     }
 
     // Tell OpenSSL about the desired length.
-    if (!EVP_CIPHER_CTX_ctrl(ctx_.get(), EVP_CTRL_AEAD_SET_TAG, auth_tag_len,
+    if (!Thin_EVP_CIPHER_CTX_ctrl(ctx_.get(), EVP_CTRL_AEAD_SET_TAG, auth_tag_len,
                              nullptr)) {
       THROW_ERR_CRYPTO_INVALID_AUTH_TAG(
           env(), "Invalid authentication tag length: %u", auth_tag_len);
@@ -637,7 +637,7 @@ bool CipherBase::InitAuthenticated(
 
 bool CipherBase::CheckCCMMessageLength(int message_len) {
   CHECK(ctx_);
-  CHECK(EVP_CIPHER_CTX_mode(ctx_.get()) == EVP_CIPH_CCM_MODE);
+  CHECK(Thin_EVP_CIPHER_CTX_mode(ctx_.get()) == EVP_CIPH_CCM_MODE);
 
   if (message_len > max_message_size_) {
     THROW_ERR_CRYPTO_INVALID_MESSAGELEN(env());
@@ -688,7 +688,7 @@ void CipherBase::SetAuthTag(const FunctionCallbackInfo<Value>& args) {
 
   unsigned int tag_len = auth_tag.size();
 
-  const int mode = EVP_CIPHER_CTX_mode(cipher->ctx_.get());
+  const int mode = Thin_EVP_CIPHER_CTX_mode(cipher->ctx_.get());
   bool is_valid;
   if (mode == EVP_CIPH_GCM_MODE) {
     // Restrict GCM tag lengths according to NIST 800-38d, page 9.
@@ -720,7 +720,7 @@ void CipherBase::SetAuthTag(const FunctionCallbackInfo<Value>& args) {
 
 bool CipherBase::MaybePassAuthTagToOpenSSL() {
   if (auth_tag_state_ == kAuthTagKnown) {
-    if (!EVP_CIPHER_CTX_ctrl(ctx_.get(),
+    if (!Thin_EVP_CIPHER_CTX_ctrl(ctx_.get(),
                              EVP_CTRL_AEAD_SET_TAG,
                              auth_tag_len_,
                              reinterpret_cast<unsigned char*>(auth_tag_))) {
@@ -739,7 +739,7 @@ bool CipherBase::SetAAD(
   MarkPopErrorOnReturn mark_pop_error_on_return;
 
   int outlen;
-  const int mode = EVP_CIPHER_CTX_mode(ctx_.get());
+  const int mode = Thin_EVP_CIPHER_CTX_mode(ctx_.get());
 
   // When in CCM mode, we need to set the authentication tag and the plaintext
   // length in advance.
@@ -759,11 +759,11 @@ bool CipherBase::SetAAD(
     }
 
     // Specify the plaintext length.
-    if (!EVP_CipherUpdate(ctx_.get(), nullptr, &outlen, nullptr, plaintext_len))
+    if (!Thin_EVP_CipherUpdate(ctx_.get(), nullptr, &outlen, nullptr, plaintext_len))
       return false;
   }
 
-  return 1 == EVP_CipherUpdate(ctx_.get(),
+  return 1 == Thin_EVP_CipherUpdate(ctx_.get(),
                                nullptr,
                                &outlen,
                                data.data(),
@@ -793,7 +793,7 @@ CipherBase::UpdateResult CipherBase::Update(
     return kErrorState;
   MarkPopErrorOnReturn mark_pop_error_on_return;
 
-  const int mode = EVP_CIPHER_CTX_mode(ctx_.get());
+  const int mode = Thin_EVP_CIPHER_CTX_mode(ctx_.get());
 
   if (mode == EVP_CIPH_CCM_MODE && !CheckCCMMessageLength(len))
     return kErrorMessageSize;
@@ -803,15 +803,15 @@ CipherBase::UpdateResult CipherBase::Update(
   if (kind_ == kDecipher && IsAuthenticatedMode())
     CHECK(MaybePassAuthTagToOpenSSL());
 
-  const int block_size = EVP_CIPHER_CTX_block_size(ctx_.get());
+  const int block_size = Thin_EVP_CIPHER_CTX_block_size(ctx_.get());
   CHECK_GT(block_size, 0);
   if (len + block_size > INT_MAX) return kErrorState;
   int buf_len = len + block_size;
 
   // For key wrapping algorithms, get output size by calling
-  // EVP_CipherUpdate() with null output.
+  // Thin_EVP_CipherUpdate() with null output.
   if (kind_ == kCipher && mode == EVP_CIPH_WRAP_MODE &&
-      EVP_CipherUpdate(ctx_.get(),
+      Thin_EVP_CipherUpdate(ctx_.get(),
                        nullptr,
                        &buf_len,
                        reinterpret_cast<const unsigned char*>(data),
@@ -824,7 +824,7 @@ CipherBase::UpdateResult CipherBase::Update(
     *out = ArrayBuffer::NewBackingStore(env()->isolate(), buf_len);
   }
 
-  int r = EVP_CipherUpdate(ctx_.get(),
+  int r = Thin_EVP_CipherUpdate(ctx_.get(),
                            static_cast<unsigned char*>((*out)->Data()),
                            &buf_len,
                            reinterpret_cast<const unsigned char*>(data),
@@ -836,7 +836,7 @@ CipherBase::UpdateResult CipherBase::Update(
   else
     *out = BackingStore::Reallocate(env()->isolate(), std::move(*out), buf_len);
 
-  // When in CCM mode, EVP_CipherUpdate will fail if the authentication tag is
+  // When in CCM mode, Thin_EVP_CipherUpdate will fail if the authentication tag is
   // invalid. In that case, remember the error and throw in final().
   if (!r && kind_ == kDecipher && mode == EVP_CIPH_CCM_MODE) {
     pending_auth_failed_ = true;
@@ -859,7 +859,7 @@ void CipherBase::Update(const FunctionCallbackInfo<Value>& args) {
 
     if (r != kSuccess) {
       if (r == kErrorState) {
-        ThrowCryptoError(env, ERR_get_error(),
+        ThrowCryptoError(env, Thin_ERR_get_error(),
                          "Trying to add data in unsupported state");
       }
       return;
@@ -875,7 +875,7 @@ bool CipherBase::SetAutoPadding(bool auto_padding) {
   if (!ctx_)
     return false;
   MarkPopErrorOnReturn mark_pop_error_on_return;
-  return EVP_CIPHER_CTX_set_padding(ctx_.get(), auto_padding);
+  return Thin_EVP_CIPHER_CTX_set_padding(ctx_.get(), auto_padding);
 }
 
 void CipherBase::SetAutoPadding(const FunctionCallbackInfo<Value>& args) {
@@ -890,12 +890,12 @@ bool CipherBase::Final(std::unique_ptr<BackingStore>* out) {
   if (!ctx_)
     return false;
 
-  const int mode = EVP_CIPHER_CTX_mode(ctx_.get());
+  const int mode = Thin_EVP_CIPHER_CTX_mode(ctx_.get());
 
   {
     NoArrayBufferZeroFillScope no_zero_fill_scope(env()->isolate_data());
     *out = ArrayBuffer::NewBackingStore(env()->isolate(),
-        static_cast<size_t>(EVP_CIPHER_CTX_block_size(ctx_.get())));
+        static_cast<size_t>(Thin_EVP_CIPHER_CTX_block_size(ctx_.get())));
   }
 
   if (kind_ == kDecipher && IsSupportedAuthenticatedMode(ctx_.get()))
@@ -903,21 +903,21 @@ bool CipherBase::Final(std::unique_ptr<BackingStore>* out) {
 
   // OpenSSL v1.x doesn't verify the presence of the auth tag so do
   // it ourselves, see https://github.com/nodejs/node/issues/45874.
-  if (OPENSSL_VERSION_NUMBER < 0x30000000L && kind_ == kDecipher &&
-      NID_chacha20_poly1305 == EVP_CIPHER_CTX_nid(ctx_.get()) &&
-      auth_tag_state_ != kAuthTagPassedToOpenSSL) {
-    return false;
-  }
+  // if (OPENSSL_VERSION_NUMBER < 0x30000000L && kind_ == kDecipher &&
+  //     NID_chacha20_poly1305 == Thin_EVP_CIPHER_CTX_nid(ctx_.get()) &&
+  //     auth_tag_state_ != kAuthTagPassedToOpenSSL) {
+  //   return false;
+  // }
 
   // In CCM mode, final() only checks whether authentication failed in update().
-  // EVP_CipherFinal_ex must not be called and will fail.
+  // Thin_EVP_CipherFinal_ex must not be called and will fail.
   bool ok;
   if (kind_ == kDecipher && mode == EVP_CIPH_CCM_MODE) {
     ok = !pending_auth_failed_;
     *out = ArrayBuffer::NewBackingStore(env()->isolate(), 0);
   } else {
     int out_len = (*out)->ByteLength();
-    ok = EVP_CipherFinal_ex(ctx_.get(),
+    ok = Thin_EVP_CipherFinal_ex(ctx_.get(),
                             static_cast<unsigned char*>((*out)->Data()),
                             &out_len) == 1;
 
@@ -937,7 +937,7 @@ bool CipherBase::Final(std::unique_ptr<BackingStore>* out) {
         CHECK(mode == EVP_CIPH_GCM_MODE);
         auth_tag_len_ = sizeof(auth_tag_);
       }
-      ok = (1 == EVP_CIPHER_CTX_ctrl(ctx_.get(), EVP_CTRL_AEAD_GET_TAG,
+      ok = (1 == Thin_EVP_CIPHER_CTX_ctrl(ctx_.get(), EVP_CTRL_AEAD_GET_TAG,
                      auth_tag_len_,
                      reinterpret_cast<unsigned char*>(auth_tag_)));
     }
@@ -967,7 +967,7 @@ void CipherBase::Final(const FunctionCallbackInfo<Value>& args) {
                           ? "Unsupported state or unable to authenticate data"
                           : "Unsupported state";
 
-    return ThrowCryptoError(env, ERR_get_error(), msg);
+    return ThrowCryptoError(env, Thin_ERR_get_error(), msg);
   }
 
   Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(out));
@@ -986,16 +986,16 @@ bool PublicKeyCipher::Cipher(
     const ArrayBufferOrViewContents<unsigned char>& oaep_label,
     const ArrayBufferOrViewContents<unsigned char>& data,
     std::unique_ptr<BackingStore>* out) {
-  EVPKeyCtxPointer ctx(EVP_PKEY_CTX_new(pkey.get(), nullptr));
+  EVPKeyCtxPointer ctx(Thin_EVP_PKEY_CTX_new(pkey.get(), nullptr));
   if (!ctx)
     return false;
   if (EVP_PKEY_cipher_init(ctx.get()) <= 0)
     return false;
-  if (EVP_PKEY_CTX_set_rsa_padding(ctx.get(), padding) <= 0)
+  if (Thin_EVP_PKEY_CTX_set_rsa_padding(ctx.get(), padding) <= 0)
     return false;
 
   if (digest != nullptr) {
-    if (EVP_PKEY_CTX_set_rsa_oaep_md(ctx.get(), digest) <= 0)
+    if (Thin_EVP_PKEY_CTX_set_rsa_oaep_md(ctx.get(), digest) <= 0)
       return false;
   }
 
@@ -1057,7 +1057,7 @@ void PublicKeyCipher::Cipher(const FunctionCallbackInfo<Value>& args) {
   const EVP_MD* digest = nullptr;
   if (args[offset + 2]->IsString()) {
     const Utf8Value oaep_str(env->isolate(), args[offset + 2]);
-    digest = EVP_get_digestbyname(*oaep_str);
+    digest = Thin_EVP_get_digestbyname(*oaep_str);
     if (digest == nullptr)
       return THROW_ERR_OSSL_EVP_INVALID_DIGEST(env);
   }
@@ -1070,7 +1070,7 @@ void PublicKeyCipher::Cipher(const FunctionCallbackInfo<Value>& args) {
   std::unique_ptr<BackingStore> out;
   if (!Cipher<operation, EVP_PKEY_cipher_init, EVP_PKEY_cipher>(
           env, pkey, padding, digest, oaep_label, buf, &out)) {
-    return ThrowCryptoError(env, ERR_get_error());
+    return ThrowCryptoError(env, Thin_ERR_get_error());
   }
 
   Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(out));
diff --git a/src/crypto/crypto_cipher.h b/src/crypto/crypto_cipher.h
index e725a2f30d..c559b7a650 100644
--- a/src/crypto/crypto_cipher.h
+++ b/src/crypto/crypto_cipher.h
@@ -85,7 +85,7 @@ class CipherBase : public BaseObject {
   CipherBase(Environment* env, v8::Local<v8::Object> wrap, CipherKind kind);
 
  private:
-  DeleteFnPtr<EVP_CIPHER_CTX, EVP_CIPHER_CTX_free> ctx_;
+  DeleteFnPtr<EVP_CIPHER_CTX, Thin_EVP_CIPHER_CTX_free> ctx_;
   const CipherKind kind_;
   AuthTagState auth_tag_state_;
   unsigned int auth_tag_len_;
diff --git a/src/crypto/crypto_clienthello.h b/src/crypto/crypto_clienthello.h
index 3af08bc647..64283b160b 100644
--- a/src/crypto/crypto_clienthello.h
+++ b/src/crypto/crypto_clienthello.h
@@ -30,7 +30,7 @@
 namespace node {
 namespace crypto {
 // Parse the client hello so we can do async session resumption. OpenSSL's
-// session resumption uses synchronous callbacks, see SSL_CTX_sess_set_get_cb
+// session resumption uses synchronous callbacks, see Thin_SSL_CTX_sess_set_get_cb
 // and get_session_cb.
 //
 // TLS1.3 handshakes masquerade as TLS1.2 session resumption, and to do this,
diff --git a/src/crypto/crypto_common.cc b/src/crypto/crypto_common.cc
index 41e607e929..a8bc0959bc 100644
--- a/src/crypto/crypto_common.cc
+++ b/src/crypto/crypto_common.cc
@@ -52,14 +52,14 @@ static constexpr int kX509NameFlagsRFC2253WithinUtf8JSON =
     ~ASN1_STRFLGS_ESC_CTRL;
 
 X509Pointer SSL_CTX_get_issuer(SSL_CTX* ctx, X509* cert) {
-  X509_STORE* store = SSL_CTX_get_cert_store(ctx);
-  DeleteFnPtr<X509_STORE_CTX, X509_STORE_CTX_free> store_ctx(
-      X509_STORE_CTX_new());
+  X509_STORE* store = Thin_SSL_CTX_get_cert_store(ctx);
+  DeleteFnPtr<X509_STORE_CTX, Thin_X509_STORE_CTX_free> store_ctx(
+      Thin_X509_STORE_CTX_new());
   X509Pointer result;
   X509* issuer;
   if (store_ctx.get() != nullptr &&
-      X509_STORE_CTX_init(store_ctx.get(), store, nullptr, nullptr) == 1 &&
-      X509_STORE_CTX_get1_issuer(&issuer, store_ctx.get(), cert) == 1) {
+      Thin_X509_STORE_CTX_init(store_ctx.get(), store, nullptr, nullptr) == 1 &&
+      Thin_X509_STORE_CTX_get1_issuer(&issuer, store_ctx.get(), cert) == 1) {
     result.reset(issuer);
   }
   return result;
@@ -70,13 +70,13 @@ void LogSecret(
     const char* name,
     const unsigned char* secret,
     size_t secretlen) {
-  auto keylog_cb = SSL_CTX_get_keylog_callback(SSL_get_SSL_CTX(ssl.get()));
+  auto keylog_cb = Thin_SSL_CTX_get_keylog_callback(Thin_SSL_get_SSL_CTX(ssl.get()));
   // All supported versions of TLS/SSL fix the client random to the same size.
   constexpr size_t kTlsClientRandomSize = SSL3_RANDOM_SIZE;
   unsigned char crandom[kTlsClientRandomSize];
 
   if (keylog_cb == nullptr ||
-      SSL_get_client_random(ssl.get(), crandom, kTlsClientRandomSize) !=
+      Thin_SSL_get_client_random(ssl.get(), crandom, kTlsClientRandomSize) !=
           kTlsClientRandomSize) {
     return;
   }
@@ -94,7 +94,7 @@ MaybeLocal<Value> GetSSLOCSPResponse(
     SSL* ssl,
     Local<Value> default_value) {
   const unsigned char* resp;
-  int len = SSL_get_tlsext_status_ocsp_resp(ssl, &resp);
+  int len = Thin_SSL_get_tlsext_status_ocsp_resp(ssl, &resp);
   if (resp == nullptr)
     return default_value;
 
@@ -111,29 +111,29 @@ MaybeLocal<Value> GetSSLOCSPResponse(
 bool SetTLSSession(
     const SSLPointer& ssl,
     const SSLSessionPointer& session) {
-  return session != nullptr && SSL_set_session(ssl.get(), session.get()) == 1;
+  return session != nullptr && Thin_SSL_set_session(ssl.get(), session.get()) == 1;
 }
 
 SSLSessionPointer GetTLSSession(const unsigned char* buf, size_t length) {
-  return SSLSessionPointer(d2i_SSL_SESSION(nullptr, &buf, length));
+  return SSLSessionPointer(Thin_d2i_SSL_SESSION(nullptr, &buf, length));
 }
 
 long VerifyPeerCertificate(  // NOLINT(runtime/int)
     const SSLPointer& ssl,
     long def) {  // NOLINT(runtime/int)
   long err = def;  // NOLINT(runtime/int)
-  if (X509* peer_cert = SSL_get_peer_certificate(ssl.get())) {
-    X509_free(peer_cert);
-    err = SSL_get_verify_result(ssl.get());
+  if (X509* peer_cert = Thin_SSL_get_peer_certificate(ssl.get())) {
+    Thin_X509_free(peer_cert);
+    err = Thin_SSL_get_verify_result(ssl.get());
   } else {
-    const SSL_CIPHER* curr_cipher = SSL_get_current_cipher(ssl.get());
-    const SSL_SESSION* sess = SSL_get_session(ssl.get());
+    const SSL_CIPHER* curr_cipher = Thin_SSL_get_current_cipher(ssl.get());
+    const SSL_SESSION* sess = Thin_SSL_get_session(ssl.get());
     // Allow no-cert for PSK authentication in TLS1.2 and lower.
     // In TLS1.3 check that session was reused because TLS1.3 PSK
     // looks like session resumption.
-    if (SSL_CIPHER_get_auth_nid(curr_cipher) == NID_auth_psk ||
-        (SSL_SESSION_get_protocol_version(sess) == TLS1_3_VERSION &&
-         SSL_session_reused(ssl.get()))) {
+    if (Thin_SSL_CIPHER_get_auth_nid(curr_cipher) == NID_auth_psk ||
+        (Thin_SSL_SESSION_get_protocol_version(sess) == TLS1_3_VERSION &&
+         Thin_SSL_session_reused(ssl.get()))) {
       return X509_V_OK;
     }
   }
@@ -143,14 +143,14 @@ long VerifyPeerCertificate(  // NOLINT(runtime/int)
 bool UseSNIContext(
     const SSLPointer& ssl, BaseObjectPtr<SecureContext> context) {
   SSL_CTX* ctx = context->ctx().get();
-  X509* x509 = SSL_CTX_get0_certificate(ctx);
-  EVP_PKEY* pkey = SSL_CTX_get0_privatekey(ctx);
+  X509* x509 = Thin_SSL_CTX_get0_certificate(ctx);
+  EVP_PKEY* pkey = Thin_SSL_CTX_get0_privatekey(ctx);
   STACK_OF(X509)* chain;
 
-  int err = SSL_CTX_get0_chain_certs(ctx, &chain);
-  if (err == 1) err = SSL_use_certificate(ssl.get(), x509);
-  if (err == 1) err = SSL_use_PrivateKey(ssl.get(), pkey);
-  if (err == 1 && chain != nullptr) err = SSL_set1_chain(ssl.get(), chain);
+  int err = Thin_SSL_CTX_get0_chain_certs(ctx, &chain);
+  if (err == 1) err = Thin_SSL_use_certificate(ssl.get(), x509);
+  if (err == 1) err = Thin_SSL_use_PrivateKey(ssl.get(), pkey);
+  if (err == 1 && chain != nullptr) err = Thin_SSL_set1_chain(ssl.get(), chain);
   return err == 1;
 }
 
@@ -159,7 +159,7 @@ const char* GetClientHelloALPN(const SSLPointer& ssl) {
   size_t len;
   size_t rem;
 
-  if (!SSL_client_hello_get0_ext(
+  if (!Thin_SSL_client_hello_get0_ext(
           ssl.get(),
           TLSEXT_TYPE_application_layer_protocol_negotiation,
           &buf,
@@ -178,7 +178,7 @@ const char* GetClientHelloServerName(const SSLPointer& ssl) {
   size_t len;
   size_t rem;
 
-  if (!SSL_client_hello_get0_ext(
+  if (!Thin_SSL_client_hello_get0_ext(
           ssl.get(),
           TLSEXT_TYPE_server_name,
           &buf,
@@ -202,11 +202,11 @@ const char* GetClientHelloServerName(const SSLPointer& ssl) {
 }
 
 const char* GetServerName(SSL* ssl) {
-  return SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name);
+  return Thin_SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name);
 }
 
 bool SetGroups(SecureContext* sc, const char* groups) {
-  return SSL_CTX_set1_groups_list(sc->ctx().get(), groups) == 1;
+  return Thin_SSL_CTX_set1_groups_list(sc->ctx().get(), groups) == 1;
 }
 
 const char* X509ErrorCode(long err) {  // NOLINT(runtime/int)
@@ -251,7 +251,7 @@ const char* X509ErrorCode(long err) {  // NOLINT(runtime/int)
 MaybeLocal<Value> GetValidationErrorReason(Environment* env, int err) {
   if (err == 0)
     return Undefined(env->isolate());
-  const char* reason = X509_verify_cert_error_string(err);
+  const char* reason = Thin_X509_verify_cert_error_string(err);
   return OneByteString(env->isolate(), reason);
 }
 
@@ -263,7 +263,7 @@ MaybeLocal<Value> GetValidationErrorCode(Environment* env, int err) {
 
 MaybeLocal<Value> GetCert(Environment* env, const SSLPointer& ssl) {
   ClearErrorOnReturn clear_error_on_return;
-  X509* cert = SSL_get_certificate(ssl.get());
+  X509* cert = Thin_SSL_get_certificate(ssl.get());
   if (cert == nullptr)
     return Undefined(env->isolate());
 
@@ -273,14 +273,14 @@ MaybeLocal<Value> GetCert(Environment* env, const SSLPointer& ssl) {
 
 Local<Value> ToV8Value(Environment* env, const BIOPointer& bio) {
   BUF_MEM* mem;
-  BIO_get_mem_ptr(bio.get(), &mem);
+  Thin_BIO_get_mem_ptr(bio.get(), &mem);
   MaybeLocal<String> ret =
       String::NewFromUtf8(
           env->isolate(),
           mem->data,
           NewStringType::kNormal,
           mem->length);
-  CHECK_EQ(BIO_reset(bio.get()), 1);
+  CHECK_EQ(Thin_BIO_reset(bio.get()), 1);
   return ret.FromMaybe(Local<Value>());
 }
 
@@ -310,19 +310,19 @@ MaybeLocal<Value> GetCipherValue(Environment* env, const SSL_CIPHER* cipher) {
   return OneByteString(env->isolate(), getstr(cipher));
 }
 
-constexpr auto GetCipherName = GetCipherValue<SSL_CIPHER_get_name>;
-constexpr auto GetCipherStandardName = GetCipherValue<SSL_CIPHER_standard_name>;
-constexpr auto GetCipherVersion = GetCipherValue<SSL_CIPHER_get_version>;
+constexpr auto GetCipherName = GetCipherValue<Thin_SSL_CIPHER_get_name>;
+constexpr auto GetCipherStandardName = GetCipherValue<Thin_SSL_CIPHER_standard_name>;
+constexpr auto GetCipherVersion = GetCipherValue<Thin_SSL_CIPHER_get_version>;
 
 StackOfX509 CloneSSLCerts(X509Pointer&& cert,
                           const STACK_OF(X509)* const ssl_certs) {
-  StackOfX509 peer_certs(sk_X509_new(nullptr));
+  StackOfX509 peer_certs(Thin_sk_X509_new(nullptr));
   if (!peer_certs) return StackOfX509();
-  if (cert && !sk_X509_push(peer_certs.get(), cert.release()))
+  if (cert && !Thin_sk_X509_push(peer_certs.get(), cert.release()))
     return StackOfX509();
-  for (int i = 0; i < sk_X509_num(ssl_certs); i++) {
-    X509Pointer cert(X509_dup(sk_X509_value(ssl_certs, i)));
-    if (!cert || !sk_X509_push(peer_certs.get(), cert.get()))
+  for (int i = 0; i < Thin_sk_X509_num(ssl_certs); i++) {
+    X509Pointer cert(Thin_X509_dup(Thin_sk_X509_value(ssl_certs, i)));
+    if (!cert || !Thin_sk_X509_push(peer_certs.get(), cert.get()))
       return StackOfX509();
     // `cert` is now managed by the stack.
     cert.release();
@@ -336,12 +336,12 @@ MaybeLocal<Object> AddIssuerChainToObject(
     StackOfX509&& peer_certs,
     Environment* const env) {
   Local<Context> context = env->isolate()->GetCurrentContext();
-  cert->reset(sk_X509_delete(peer_certs.get(), 0));
+  cert->reset(Thin_sk_X509_delete(peer_certs.get(), 0));
   for (;;) {
     int i;
-    for (i = 0; i < sk_X509_num(peer_certs.get()); i++) {
-      X509* ca = sk_X509_value(peer_certs.get(), i);
-      if (X509_check_issued(ca, cert->get()) != X509_V_OK)
+    for (i = 0; i < Thin_sk_X509_num(peer_certs.get()); i++) {
+      X509* ca = Thin_sk_X509_value(peer_certs.get(), i);
+      if (Thin_X509_check_issued(ca, cert->get()) != X509_V_OK)
         continue;
 
       Local<Object> ca_info;
@@ -355,12 +355,12 @@ MaybeLocal<Object> AddIssuerChainToObject(
 
       // NOTE: Intentionally freeing cert that is not used anymore.
       // Delete cert and continue aggregating issuers.
-      cert->reset(sk_X509_delete(peer_certs.get(), i));
+      cert->reset(Thin_sk_X509_delete(peer_certs.get(), i));
       break;
     }
 
     // Issuer not found, break out of the loop.
-    if (i == sk_X509_num(peer_certs.get()))
+    if (i == Thin_sk_X509_num(peer_certs.get()))
       break;
   }
   return MaybeLocal<Object>(object);
@@ -372,9 +372,9 @@ MaybeLocal<Object> GetLastIssuedCert(
     Local<Object> issuer_chain,
     Environment* const env) {
   Local<Context> context = env->isolate()->GetCurrentContext();
-  while (X509_check_issued(cert->get(), cert->get()) != X509_V_OK) {
+  while (Thin_X509_check_issued(cert->get(), cert->get()) != X509_V_OK) {
     X509Pointer ca;
-    if (!(ca = SSL_CTX_get_issuer(SSL_get_SSL_CTX(ssl.get()), cert->get())))
+    if (!(ca = SSL_CTX_get_issuer(Thin_SSL_get_SSL_CTX(ssl.get()), cert->get())))
       break;
 
     Local<Object> ca_info;
@@ -387,7 +387,7 @@ MaybeLocal<Object> GetLastIssuedCert(
     issuer_chain = ca_info;
 
     // For self-signed certificates whose keyUsage field does not include
-    // keyCertSign, X509_check_issued() will return false. Avoid going into an
+    // keyCertSign, Thin_X509_check_issued() will return false. Avoid going into an
     // infinite loop by checking if SSL_CTX_get_issuer() returned the same
     // certificate.
     if (cert->get() == ca.get()) break;
@@ -427,7 +427,7 @@ MaybeLocal<Value> GetECPubKey(
     Environment* env,
     const EC_GROUP* group,
     const ECPointer& ec) {
-  const EC_POINT* pubkey = EC_KEY_get0_public_key(ec.get());
+  const EC_POINT* pubkey = Thin_EC_KEY_get0_public_key(ec.get());
   if (pubkey == nullptr)
     return Undefined(env->isolate());
 
@@ -435,7 +435,7 @@ MaybeLocal<Value> GetECPubKey(
       env,
       group,
       pubkey,
-      EC_KEY_get_conv_form(ec.get()),
+      Thin_EC_KEY_get_conv_form(ec.get()),
       nullptr).FromMaybe(Local<Object>());
 }
 
@@ -446,7 +446,7 @@ MaybeLocal<Value> GetECGroup(
   if (group == nullptr)
     return Undefined(env->isolate());
 
-  int bits = EC_GROUP_order_bits(group);
+  int bits = Thin_EC_GROUP_order_bits(group);
   if (bits <= 0)
     return Undefined(env->isolate());
 
@@ -454,7 +454,7 @@ MaybeLocal<Value> GetECGroup(
 }
 
 MaybeLocal<Object> GetPubKey(Environment* env, const RSAPointer& rsa) {
-  int size = i2d_RSA_PUBKEY(rsa.get(), nullptr);
+  int size = Thin_i2d_RSA_PUBKEY(rsa.get(), nullptr);
   CHECK_GE(size, 0);
 
   std::unique_ptr<BackingStore> bs;
@@ -464,7 +464,7 @@ MaybeLocal<Object> GetPubKey(Environment* env, const RSAPointer& rsa) {
   }
 
   unsigned char* serialized = reinterpret_cast<unsigned char*>(bs->Data());
-  CHECK_GE(i2d_RSA_PUBKEY(rsa.get(), &serialized), 0);
+  CHECK_GE(Thin_i2d_RSA_PUBKEY(rsa.get(), &serialized), 0);
 
   Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
   return Buffer::New(env, ab, 0, ab->ByteLength()).FromMaybe(Local<Object>());
@@ -474,26 +474,26 @@ MaybeLocal<Value> GetExponentString(
     Environment* env,
     const BIOPointer& bio,
     const BIGNUM* e) {
-  uint64_t exponent_word = static_cast<uint64_t>(BN_get_word(e));
-  BIO_printf(bio.get(), "0x%" PRIx64, exponent_word);
+  uint64_t exponent_word = static_cast<uint64_t>(Thin_BN_get_word(e));
+  Thin_BIO_printf(bio.get(), "0x%" PRIx64, exponent_word);
   return ToV8Value(env, bio);
 }
 
 Local<Value> GetBits(Environment* env, const BIGNUM* n) {
-  return Integer::New(env->isolate(), BN_num_bits(n));
+  return Integer::New(env->isolate(), Thin_BN_num_bits(n));
 }
 
 MaybeLocal<Value> GetModulusString(
     Environment* env,
     const BIOPointer& bio,
     const BIGNUM* n) {
-  BN_print(bio.get(), n);
+  Thin_BN_print(bio.get(), n);
   return ToV8Value(env, bio);
 }
 }  // namespace
 
 MaybeLocal<Object> GetRawDERCertificate(Environment* env, X509* cert) {
-  int size = i2d_X509(cert, nullptr);
+  int size = Thin_i2d_X509(cert, nullptr);
 
   std::unique_ptr<BackingStore> bs;
   {
@@ -502,17 +502,17 @@ MaybeLocal<Object> GetRawDERCertificate(Environment* env, X509* cert) {
   }
 
   unsigned char* serialized = reinterpret_cast<unsigned char*>(bs->Data());
-  CHECK_GE(i2d_X509(cert, &serialized), 0);
+  CHECK_GE(Thin_i2d_X509(cert, &serialized), 0);
 
   Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
   return Buffer::New(env, ab, 0, ab->ByteLength()).FromMaybe(Local<Object>());
 }
 
 MaybeLocal<Value> GetSerialNumber(Environment* env, X509* cert) {
-  if (ASN1_INTEGER* serial_number = X509_get_serialNumber(cert)) {
-    BignumPointer bn(ASN1_INTEGER_to_BN(serial_number, nullptr));
+  if (ASN1_INTEGER* serial_number = Thin_X509_get_serialNumber(cert)) {
+    BignumPointer bn(Thin_ASN1_INTEGER_to_BN(serial_number, nullptr));
     if (bn) {
-      char* data = BN_bn2hex(bn.get());
+      char* data = Thin_BN_bn2hex(bn.get());
       ByteSource buf = ByteSource::Allocated(data, strlen(data));
       if (buf) return OneByteString(env->isolate(), buf.data<unsigned char>());
     }
@@ -523,17 +523,17 @@ MaybeLocal<Value> GetSerialNumber(Environment* env, X509* cert) {
 
 MaybeLocal<Value> GetKeyUsage(Environment* env, X509* cert) {
   StackOfASN1 eku(static_cast<STACK_OF(ASN1_OBJECT)*>(
-      X509_get_ext_d2i(cert, NID_ext_key_usage, nullptr, nullptr)));
+      Thin_X509_get_ext_d2i(cert, NID_ext_key_usage, nullptr, nullptr)));
   if (eku) {
-    const int count = sk_ASN1_OBJECT_num(eku.get());
+    const int count = Thin_sk_ASN1_OBJECT_num(eku.get());
     MaybeStackBuffer<Local<Value>, 16> ext_key_usage(count);
     char buf[256];
 
     int j = 0;
     for (int i = 0; i < count; i++) {
-      if (OBJ_obj2txt(buf,
+      if (Thin_OBJ_obj2txt(buf,
                       sizeof(buf),
-                      sk_ASN1_OBJECT_value(eku.get(), i), 1) >= 0) {
+                      Thin_sk_ASN1_OBJECT_value(eku.get(), i), 1) >= 0) {
         ext_key_usage[j++] = OneByteString(env->isolate(), buf);
       }
     }
@@ -546,12 +546,12 @@ MaybeLocal<Value> GetKeyUsage(Environment* env, X509* cert) {
 
 MaybeLocal<Value> GetCurrentCipherName(Environment* env,
                                        const SSLPointer& ssl) {
-  return GetCipherName(env, SSL_get_current_cipher(ssl.get()));
+  return GetCipherName(env, Thin_SSL_get_current_cipher(ssl.get()));
 }
 
 MaybeLocal<Value> GetCurrentCipherVersion(Environment* env,
                                           const SSLPointer& ssl) {
-  return GetCipherVersion(env, SSL_get_current_cipher(ssl.get()));
+  return GetCipherVersion(env, Thin_SSL_get_current_cipher(ssl.get()));
 }
 
 MaybeLocal<Value> GetFingerprintDigest(
@@ -562,7 +562,7 @@ MaybeLocal<Value> GetFingerprintDigest(
   unsigned int md_size;
   char fingerprint[EVP_MAX_MD_SIZE * 3];
 
-  if (X509_digest(cert, method, md, &md_size)) {
+  if (Thin_X509_digest(cert, method, md, &md_size)) {
     AddFingerprintDigest(md, md_size, fingerprint);
     return OneByteString(env->isolate(), fingerprint);
   }
@@ -573,7 +573,7 @@ MaybeLocal<Value> GetValidTo(
     Environment* env,
     X509* cert,
     const BIOPointer& bio) {
-  ASN1_TIME_print(bio.get(), X509_get0_notAfter(cert));
+  Thin_ASN1_TIME_print(bio.get(), Thin_X509_get0_notAfter(cert));
   return ToV8Value(env, bio);
 }
 
@@ -581,7 +581,7 @@ MaybeLocal<Value> GetValidFrom(
     Environment* env,
     X509* cert,
     const BIOPointer& bio) {
-  ASN1_TIME_print(bio.get(), X509_get0_notBefore(cert));
+  Thin_ASN1_TIME_print(bio.get(), Thin_X509_get0_notBefore(cert));
   return ToV8Value(env, bio);
 }
 
@@ -630,23 +630,23 @@ static inline void PrintAltName(const BIOPointer& out, const char* name,
     // For backward-compatibility, append "safe" names without any
     // modifications.
     if (safe_prefix != nullptr) {
-      BIO_printf(out.get(), "%s:", safe_prefix);
+      Thin_BIO_printf(out.get(), "%s:", safe_prefix);
     }
-    BIO_write(out.get(), name, length);
+    Thin_BIO_write(out.get(), name, length);
   } else {
     // If a name is not "safe", we cannot embed it without special
     // encoding. This does not usually happen, but we don't want to hide
     // it from the user either. We use JSON compatible escaping here.
-    BIO_write(out.get(), "\"", 1);
+    Thin_BIO_write(out.get(), "\"", 1);
     if (safe_prefix != nullptr) {
-      BIO_printf(out.get(), "%s:", safe_prefix);
+      Thin_BIO_printf(out.get(), "%s:", safe_prefix);
     }
     for (size_t j = 0; j < length; j++) {
       char c = static_cast<char>(name[j]);
       if (c == '\\') {
-        BIO_write(out.get(), "\\\\", 2);
+        Thin_BIO_write(out.get(), "\\\\", 2);
       } else if (c == '"') {
-        BIO_write(out.get(), "\\\"", 2);
+        Thin_BIO_write(out.get(), "\\\"", 2);
       } else if ((c >= ' ' && c != ',' && c <= '~') || (utf8 && (c & 0x80))) {
         // Note that the above condition explicitly excludes commas, which means
         // that those are encoded as Unicode escape sequences in the "else"
@@ -654,16 +654,16 @@ static inline void PrintAltName(const BIOPointer& out, const char* name,
         // it correctly either way. We only do this to account for third-party
         // code that might be splitting the string at commas (as Node.js itself
         // used to do).
-        BIO_write(out.get(), &c, 1);
+        Thin_BIO_write(out.get(), &c, 1);
       } else {
         // Control character or non-ASCII character. We treat everything as
         // Latin-1, which corresponds to the first 255 Unicode code points.
         const char hex[] = "0123456789abcdef";
         char u[] = { '\\', 'u', '0', '0', hex[(c & 0xf0) >> 4], hex[c & 0x0f] };
-        BIO_write(out.get(), u, sizeof(u));
+        Thin_BIO_write(out.get(), u, sizeof(u));
       }
     }
-    BIO_write(out.get(), "\"", 1);
+    Thin_BIO_write(out.get(), "\"", 1);
   }
 }
 
@@ -681,45 +681,45 @@ static inline void PrintUtf8AltName(const BIOPointer& out,
                true, safe_prefix);
 }
 
-// This function emulates the behavior of i2v_GENERAL_NAME in a safer and less
+// This function emulates the behavior of Thin_i2v_GENERAL_NAME in a safer and less
 // ambiguous way. "othername:" entries use the GENERAL_NAME_print format.
 static bool PrintGeneralName(const BIOPointer& out, const GENERAL_NAME* gen) {
   if (gen->type == GEN_DNS) {
     ASN1_IA5STRING* name = gen->d.dNSName;
-    BIO_write(out.get(), "DNS:", 4);
+    Thin_BIO_write(out.get(), "DNS:", 4);
     // Note that the preferred name syntax (see RFCs 5280 and 1034) with
     // wildcards is a subset of what we consider "safe", so spec-compliant DNS
     // names will never need to be escaped.
     PrintLatin1AltName(out, name);
   } else if (gen->type == GEN_EMAIL) {
     ASN1_IA5STRING* name = gen->d.rfc822Name;
-    BIO_write(out.get(), "email:", 6);
+    Thin_BIO_write(out.get(), "email:", 6);
     PrintLatin1AltName(out, name);
   } else if (gen->type == GEN_URI) {
     ASN1_IA5STRING* name = gen->d.uniformResourceIdentifier;
-    BIO_write(out.get(), "URI:", 4);
+    Thin_BIO_write(out.get(), "URI:", 4);
     // The set of "safe" names was designed to include just about any URI,
     // with a few exceptions, most notably URIs that contains commas (see
     // RFC 2396). In other words, most legitimate URIs will not require
     // escaping.
     PrintLatin1AltName(out, name);
   } else if (gen->type == GEN_DIRNAME) {
-    // Earlier versions of Node.js used X509_NAME_oneline to print the X509_NAME
+    // Earlier versions of Node.js used Thin_X509_NAME_oneline to print the X509_NAME
     // object. The format was non standard and should be avoided. The use of
-    // X509_NAME_oneline is discouraged by OpenSSL but was required for backward
-    // compatibility. Conveniently, X509_NAME_oneline produced ASCII and the
+    // Thin_X509_NAME_oneline is discouraged by OpenSSL but was required for backward
+    // compatibility. Conveniently, Thin_X509_NAME_oneline produced ASCII and the
     // output was unlikely to contains commas or other characters that would
     // require escaping. However, it SHOULD NOT produce ASCII output since an
     // RFC5280 AttributeValue may be a UTF8String.
-    // Newer versions of Node.js have since switched to X509_NAME_print_ex to
+    // Newer versions of Node.js have since switched to Thin_X509_NAME_print_ex to
     // produce a better format at the cost of backward compatibility. The new
     // format may contain Unicode characters and it is likely to contain commas,
     // which require escaping. Fortunately, the recently safeguarded function
     // PrintAltName handles all of that safely.
-    BIO_printf(out.get(), "DirName:");
-    BIOPointer tmp(BIO_new(BIO_s_mem()));
+    Thin_BIO_printf(out.get(), "DirName:");
+    BIOPointer tmp(Thin_BIO_new(Thin_BIO_s_mem()));
     CHECK(tmp);
-    if (X509_NAME_print_ex(tmp.get(),
+    if (Thin_X509_NAME_print_ex(tmp.get(),
                            gen->d.dirn,
                            0,
                            kX509NameFlagsRFC2253WithinUtf8JSON) < 0) {
@@ -731,40 +731,40 @@ static bool PrintGeneralName(const BIOPointer& out, const GENERAL_NAME* gen) {
     CHECK_IMPLIES(n_bytes != 0, oline != nullptr);
     PrintAltName(out, oline, static_cast<size_t>(n_bytes), true, nullptr);
   } else if (gen->type == GEN_IPADD) {
-    BIO_printf(out.get(), "IP Address:");
+    Thin_BIO_printf(out.get(), "IP Address:");
     const ASN1_OCTET_STRING* ip = gen->d.ip;
     const unsigned char* b = ip->data;
     if (ip->length == 4) {
-      BIO_printf(out.get(), "%d.%d.%d.%d", b[0], b[1], b[2], b[3]);
+      Thin_BIO_printf(out.get(), "%d.%d.%d.%d", b[0], b[1], b[2], b[3]);
     } else if (ip->length == 16) {
       for (unsigned int j = 0; j < 8; j++) {
         uint16_t pair = (b[2 * j] << 8) | b[2 * j + 1];
-        BIO_printf(out.get(), (j == 0) ? "%X" : ":%X", pair);
+        Thin_BIO_printf(out.get(), (j == 0) ? "%X" : ":%X", pair);
       }
     } else {
 #if OPENSSL_VERSION_MAJOR >= 3
-      BIO_printf(out.get(), "<invalid length=%d>", ip->length);
+      Thin_BIO_printf(out.get(), "<invalid length=%d>", ip->length);
 #else
-      BIO_printf(out.get(), "<invalid>");
+      Thin_BIO_printf(out.get(), "<invalid>");
 #endif
     }
   } else if (gen->type == GEN_RID) {
     // Unlike OpenSSL's default implementation, never print the OID as text and
     // instead always print its numeric representation.
     char oline[256];
-    OBJ_obj2txt(oline, sizeof(oline), gen->d.rid, true);
-    BIO_printf(out.get(), "Registered ID:%s", oline);
+    Thin_OBJ_obj2txt(oline, sizeof(oline), gen->d.rid, true);
+    Thin_BIO_printf(out.get(), "Registered ID:%s", oline);
   } else if (gen->type == GEN_OTHERNAME) {
     // The format that is used here is based on OpenSSL's implementation of
     // GENERAL_NAME_print (as of OpenSSL 3.0.1). Earlier versions of Node.js
-    // instead produced the same format as i2v_GENERAL_NAME, which was somewhat
+    // instead produced the same format as Thin_i2v_GENERAL_NAME, which was somewhat
     // awkward, especially when passed to translatePeerCertificate.
     bool unicode = true;
     const char* prefix = nullptr;
     // OpenSSL 1.1.1 does not support othername in GENERAL_NAME_print and may
     // not define these NIDs.
 #if OPENSSL_VERSION_MAJOR >= 3
-    int nid = OBJ_obj2nid(gen->d.otherName->type_id);
+    int nid = Thin_OBJ_obj2nid(gen->d.otherName->type_id);
     switch (nid) {
       case NID_id_on_SmtpUTF8Mailbox:
         prefix = "SmtpUTF8Mailbox";
@@ -788,9 +788,9 @@ static bool PrintGeneralName(const BIOPointer& out, const GENERAL_NAME* gen) {
     if (prefix == nullptr ||
         (unicode && val_type != V_ASN1_UTF8STRING) ||
         (!unicode && val_type != V_ASN1_IA5STRING)) {
-      BIO_printf(out.get(), "othername:<unsupported>");
+      Thin_BIO_printf(out.get(), "othername:<unsupported>");
     } else {
-      BIO_printf(out.get(), "othername:");
+      Thin_BIO_printf(out.get(), "othername:");
       if (unicode) {
         PrintUtf8AltName(out, gen->d.otherName->value->value.utf8string,
                          prefix);
@@ -801,12 +801,12 @@ static bool PrintGeneralName(const BIOPointer& out, const GENERAL_NAME* gen) {
     }
   } else if (gen->type == GEN_X400) {
     // TODO(tniessen): this is what OpenSSL does, implement properly instead
-    BIO_printf(out.get(), "X400Name:<unsupported>");
+    Thin_BIO_printf(out.get(), "X400Name:<unsupported>");
   } else if (gen->type == GEN_EDIPARTY) {
     // TODO(tniessen): this is what OpenSSL does, implement properly instead
-    BIO_printf(out.get(), "EdiPartyName:<unsupported>");
+    Thin_BIO_printf(out.get(), "EdiPartyName:<unsupported>");
   } else {
-    // This is safe because X509V3_EXT_d2i would have returned nullptr in this
+    // This is safe because Thin_X509V3_EXT_d2i would have returned nullptr in this
     // case already.
     UNREACHABLE();
   }
@@ -815,58 +815,58 @@ static bool PrintGeneralName(const BIOPointer& out, const GENERAL_NAME* gen) {
 }
 
 bool SafeX509SubjectAltNamePrint(const BIOPointer& out, X509_EXTENSION* ext) {
-  const X509V3_EXT_METHOD* method = X509V3_EXT_get(ext);
-  CHECK(method == X509V3_EXT_get_nid(NID_subject_alt_name));
+  const X509V3_EXT_METHOD* method = Thin_X509V3_EXT_get(ext);
+  CHECK(method == Thin_X509V3_EXT_get_nid(NID_subject_alt_name));
 
-  GENERAL_NAMES* names = static_cast<GENERAL_NAMES*>(X509V3_EXT_d2i(ext));
+  GENERAL_NAMES* names = static_cast<GENERAL_NAMES*>(Thin_X509V3_EXT_d2i(ext));
   if (names == nullptr)
     return false;
 
   bool ok = true;
 
-  for (int i = 0; i < sk_GENERAL_NAME_num(names); i++) {
-    GENERAL_NAME* gen = sk_GENERAL_NAME_value(names, i);
+  for (int i = 0; i < Thin_sk_GENERAL_NAME_num(names); i++) {
+    GENERAL_NAME* gen = Thin_sk_GENERAL_NAME_value(names, i);
 
     if (i != 0)
-      BIO_write(out.get(), ", ", 2);
+      Thin_BIO_write(out.get(), ", ", 2);
 
     if (!(ok = PrintGeneralName(out, gen))) {
       break;
     }
   }
-  sk_GENERAL_NAME_pop_free(names, GENERAL_NAME_free);
+  Thin_sk_GENERAL_NAME_pop_free(names, Thin_GENERAL_NAME_free);
 
   return ok;
 }
 
 bool SafeX509InfoAccessPrint(const BIOPointer& out, X509_EXTENSION* ext) {
-  const X509V3_EXT_METHOD* method = X509V3_EXT_get(ext);
-  CHECK(method == X509V3_EXT_get_nid(NID_info_access));
+  const X509V3_EXT_METHOD* method = Thin_X509V3_EXT_get(ext);
+  CHECK(method == Thin_X509V3_EXT_get_nid(NID_info_access));
 
   AUTHORITY_INFO_ACCESS* descs =
-      static_cast<AUTHORITY_INFO_ACCESS*>(X509V3_EXT_d2i(ext));
+      static_cast<AUTHORITY_INFO_ACCESS*>(Thin_X509V3_EXT_d2i(ext));
   if (descs == nullptr)
     return false;
 
   bool ok = true;
 
-  for (int i = 0; i < sk_ACCESS_DESCRIPTION_num(descs); i++) {
-    ACCESS_DESCRIPTION* desc = sk_ACCESS_DESCRIPTION_value(descs, i);
+  for (int i = 0; i < Thin_sk_ACCESS_DESCRIPTION_num(descs); i++) {
+    ACCESS_DESCRIPTION* desc = Thin_sk_ACCESS_DESCRIPTION_value(descs, i);
 
     if (i != 0)
-      BIO_write(out.get(), "\n", 1);
+      Thin_BIO_write(out.get(), "\n", 1);
 
     char objtmp[80];
-    i2t_ASN1_OBJECT(objtmp, sizeof(objtmp), desc->method);
-    BIO_printf(out.get(), "%s - ", objtmp);
+    Thin_i2t_ASN1_OBJECT(objtmp, sizeof(objtmp), desc->method);
+    Thin_BIO_printf(out.get(), "%s - ", objtmp);
     if (!(ok = PrintGeneralName(out, desc->location))) {
       break;
     }
   }
-  sk_ACCESS_DESCRIPTION_pop_free(descs, ACCESS_DESCRIPTION_free);
+  Thin_sk_ACCESS_DESCRIPTION_pop_free(descs, Thin_ACCESS_DESCRIPTION_free);
 
 #if OPENSSL_VERSION_MAJOR < 3
-  BIO_write(out.get(), "\n", 1);
+  Thin_BIO_write(out.get(), "\n", 1);
 #endif
 
   return ok;
@@ -876,15 +876,15 @@ v8::MaybeLocal<v8::Value> GetSubjectAltNameString(
     Environment* env,
     const BIOPointer& bio,
     X509* cert) {
-  int index = X509_get_ext_by_NID(cert, NID_subject_alt_name, -1);
+  int index = Thin_X509_get_ext_by_NID(cert, NID_subject_alt_name, -1);
   if (index < 0)
     return Undefined(env->isolate());
 
-  X509_EXTENSION* ext = X509_get_ext(cert, index);
+  X509_EXTENSION* ext = Thin_X509_get_ext(cert, index);
   CHECK_NOT_NULL(ext);
 
   if (!SafeX509SubjectAltNamePrint(bio, ext)) {
-    CHECK_EQ(BIO_reset(bio.get()), 1);
+    CHECK_EQ(Thin_BIO_reset(bio.get()), 1);
     return v8::Null(env->isolate());
   }
 
@@ -895,15 +895,15 @@ v8::MaybeLocal<v8::Value> GetInfoAccessString(
     Environment* env,
     const BIOPointer& bio,
     X509* cert) {
-  int index = X509_get_ext_by_NID(cert, NID_info_access, -1);
+  int index = Thin_X509_get_ext_by_NID(cert, NID_info_access, -1);
   if (index < 0)
     return Undefined(env->isolate());
 
-  X509_EXTENSION* ext = X509_get_ext(cert, index);
+  X509_EXTENSION* ext = Thin_X509_get_ext(cert, index);
   CHECK_NOT_NULL(ext);
 
   if (!SafeX509InfoAccessPrint(bio, ext)) {
-    CHECK_EQ(BIO_reset(bio.get()), 1);
+    CHECK_EQ(Thin_BIO_reset(bio.get()), 1);
     return v8::Null(env->isolate());
   }
 
@@ -914,13 +914,13 @@ MaybeLocal<Value> GetIssuerString(
     Environment* env,
     const BIOPointer& bio,
     X509* cert) {
-  X509_NAME* issuer_name = X509_get_issuer_name(cert);
-  if (X509_NAME_print_ex(
+  X509_NAME* issuer_name = Thin_X509_get_issuer_name(cert);
+  if (Thin_X509_NAME_print_ex(
           bio.get(),
           issuer_name,
           0,
           kX509NameFlagsMultiline) <= 0) {
-    CHECK_EQ(BIO_reset(bio.get()), 1);
+    CHECK_EQ(Thin_BIO_reset(bio.get()), 1);
     return Undefined(env->isolate());
   }
 
@@ -931,12 +931,12 @@ MaybeLocal<Value> GetSubject(
     Environment* env,
     const BIOPointer& bio,
     X509* cert) {
-  if (X509_NAME_print_ex(
+  if (Thin_X509_NAME_print_ex(
           bio.get(),
-          X509_get_subject_name(cert),
+          Thin_X509_get_subject_name(cert),
           0,
           kX509NameFlagsMultiline) <= 0) {
-    CHECK_EQ(BIO_reset(bio.get()), 1);
+    CHECK_EQ(Thin_BIO_reset(bio.get()), 1);
     return Undefined(env->isolate());
   }
 
@@ -958,7 +958,7 @@ static MaybeLocal<Value> GetX509NameObject(Environment* env, X509* cert) {
   }
 
   for (int i = 0; i < cnt; i++) {
-    X509_NAME_ENTRY* entry = X509_NAME_get_entry(name, i);
+    X509_NAME_ENTRY* entry = Thin_X509_NAME_get_entry(name, i);
     CHECK_NOT_NULL(entry);
 
     // We intentionally ignore the value of X509_NAME_ENTRY_set because the
@@ -966,18 +966,18 @@ static MaybeLocal<Value> GetX509NameObject(Environment* env, X509* cert) {
     // anyway, and multi-value RDNs are rare, i.e., the vast majority of
     // Relative Distinguished Names contains a single type-value pair only.
     const ASN1_OBJECT* type = X509_NAME_ENTRY_get_object(entry);
-    const ASN1_STRING* value = X509_NAME_ENTRY_get_data(entry);
+    const ASN1_STRING* value = Thin_X509_NAME_ENTRY_get_data(entry);
 
     // If OpenSSL knows the type, use the short name of the type as the key, and
     // the numeric representation of the type's OID otherwise.
-    int type_nid = OBJ_obj2nid(type);
+    int type_nid = Thin_OBJ_obj2nid(type);
     char type_buf[80];
     const char* type_str;
     if (type_nid != NID_undef) {
-      type_str = OBJ_nid2sn(type_nid);
+      type_str = Thin_OBJ_nid2sn(type_nid);
       CHECK_NOT_NULL(type_str);
     } else {
-      OBJ_obj2txt(type_buf, sizeof(type_buf), type, true);
+      Thin_OBJ_obj2txt(type_buf, sizeof(type_buf), type, true);
       type_str = type_buf;
     }
 
@@ -986,17 +986,17 @@ static MaybeLocal<Value> GetX509NameObject(Environment* env, X509* cert) {
       return MaybeLocal<Value>();
     }
 
-    // The previous implementation used X509_NAME_print_ex, which escapes some
+    // The previous implementation used Thin_X509_NAME_print_ex, which escapes some
     // characters in the value. The old implementation did not decode/unescape
     // values correctly though, leading to ambiguous and incorrect
     // representations. The new implementation only converts to Unicode and does
     // not escape anything.
     unsigned char* value_str;
-    int value_str_size = ASN1_STRING_to_UTF8(&value_str, value);
+    int value_str_size = Thin_ASN1_STRING_to_UTF8(&value_str, value);
     if (value_str_size < 0) {
       return Undefined(env->isolate());
     }
-    auto free_value_str = OnScopeLeave([&]() { OPENSSL_free(value_str); });
+    auto free_value_str = OnScopeLeave([&]() { Thin_OPENSSL_free(value_str); });
 
     Local<String> v8_value;
     if (!String::NewFromUtf8(env->isolate(),
@@ -1041,7 +1041,7 @@ static MaybeLocal<Value> GetX509NameObject(Environment* env, X509* cert) {
 template <MaybeLocal<Value> (*Get)(Environment* env, const SSL_CIPHER* cipher)>
 MaybeLocal<Value> GetCurrentCipherValue(Environment* env,
                                         const SSLPointer& ssl) {
-  return Get(env, SSL_get_current_cipher(ssl.get()));
+  return Get(env, Thin_SSL_get_current_cipher(ssl.get()));
 }
 
 MaybeLocal<Array> GetClientHelloCiphers(
@@ -1049,12 +1049,12 @@ MaybeLocal<Array> GetClientHelloCiphers(
     const SSLPointer& ssl) {
   EscapableHandleScope scope(env->isolate());
   const unsigned char* buf;
-  size_t len = SSL_client_hello_get0_ciphers(ssl.get(), &buf);
+  size_t len = Thin_SSL_client_hello_get0_ciphers(ssl.get(), &buf);
   size_t count = len / 2;
   MaybeStackBuffer<Local<Value>, 16> ciphers(count);
   int j = 0;
   for (size_t n = 0; n < len; n += 2) {
-    const SSL_CIPHER* cipher = SSL_CIPHER_find(ssl.get(), buf);
+    const SSL_CIPHER* cipher = Thin_SSL_CIPHER_find(ssl.get(), buf);
     buf += 2;
     Local<Object> obj = Object::New(env->isolate());
     if (!Set(env->context(),
@@ -1079,7 +1079,7 @@ MaybeLocal<Array> GetClientHelloCiphers(
 
 
 MaybeLocal<Object> GetCipherInfo(Environment* env, const SSLPointer& ssl) {
-  if (SSL_get_current_cipher(ssl.get()) == nullptr)
+  if (Thin_SSL_get_current_cipher(ssl.get()) == nullptr)
     return MaybeLocal<Object>();
   EscapableHandleScope scope(env->isolate());
   Local<Object> info = Object::New(env->isolate());
@@ -1103,19 +1103,19 @@ MaybeLocal<Object> GetCipherInfo(Environment* env, const SSLPointer& ssl) {
 }
 
 MaybeLocal<Object> GetEphemeralKey(Environment* env, const SSLPointer& ssl) {
-  CHECK_EQ(SSL_is_server(ssl.get()), 0);
+  CHECK_EQ(Thin_SSL_is_server(ssl.get()), 0);
   EVP_PKEY* raw_key;
 
   EscapableHandleScope scope(env->isolate());
   Local<Object> info = Object::New(env->isolate());
-  if (!SSL_get_server_tmp_key(ssl.get(), &raw_key))
+  if (!Thin_SSL_get_server_tmp_key(ssl.get(), &raw_key))
     return scope.Escape(info);
 
   Local<Context> context = env->context();
   crypto::EVPKeyPointer key(raw_key);
 
-  int kid = EVP_PKEY_id(key.get());
-  int bits = EVP_PKEY_bits(key.get());
+  int kid = Thin_EVP_PKEY_id(key.get());
+  int bits = Thin_EVP_PKEY_bits(key.get());
   switch (kid) {
     case EVP_PKEY_DH:
       if (!Set<String>(context, info, env->type_string(), env->dh_string()) ||
@@ -1132,11 +1132,11 @@ MaybeLocal<Object> GetEphemeralKey(Environment* env, const SSLPointer& ssl) {
       {
         const char* curve_name;
         if (kid == EVP_PKEY_EC) {
-          ECKeyPointer ec(EVP_PKEY_get1_EC_KEY(key.get()));
-          int nid = EC_GROUP_get_curve_name(EC_KEY_get0_group(ec.get()));
-          curve_name = OBJ_nid2sn(nid);
+          ECKeyPointer ec(Thin_EVP_PKEY_get1_EC_KEY(key.get()));
+          int nid = Thin_EC_GROUP_get_curve_name(Thin_EC_KEY_get0_group(ec.get()));
+          curve_name = Thin_OBJ_nid2sn(nid);
         } else {
-          curve_name = OBJ_nid2sn(kid);
+          curve_name = Thin_OBJ_nid2sn(kid);
         }
         if (!Set<String>(context,
                          info,
@@ -1164,7 +1164,7 @@ MaybeLocal<Object> ECPointToBuffer(Environment* env,
                                    const EC_POINT* point,
                                    point_conversion_form_t form,
                                    const char** error) {
-  size_t len = EC_POINT_point2oct(group, point, form, nullptr, 0, nullptr);
+  size_t len = Thin_EC_POINT_point2oct(group, point, form, nullptr, 0, nullptr);
   if (len == 0) {
     if (error != nullptr) *error = "Failed to get public key length";
     return MaybeLocal<Object>();
@@ -1176,7 +1176,7 @@ MaybeLocal<Object> ECPointToBuffer(Environment* env,
     bs = ArrayBuffer::NewBackingStore(env->isolate(), len);
   }
 
-  len = EC_POINT_point2oct(group,
+  len = Thin_EC_POINT_point2oct(group,
                            point,
                            form,
                            reinterpret_cast<unsigned char*>(bs->Data()),
@@ -1202,15 +1202,15 @@ MaybeLocal<Value> GetPeerCert(
 
   // NOTE: This is because of the odd OpenSSL behavior. On client `cert_chain`
   // contains the `peer_certificate`, but on server it doesn't.
-  X509Pointer cert(is_server ? SSL_get_peer_certificate(ssl.get()) : nullptr);
-  STACK_OF(X509)* ssl_certs = SSL_get_peer_cert_chain(ssl.get());
-  if (!cert && (ssl_certs == nullptr || sk_X509_num(ssl_certs) == 0))
+  X509Pointer cert(is_server ? Thin_SSL_get_peer_certificate(ssl.get()) : nullptr);
+  STACK_OF(X509)* ssl_certs = Thin_SSL_get_peer_cert_chain(ssl.get());
+  if (!cert && (ssl_certs == nullptr || Thin_sk_X509_num(ssl_certs) == 0))
     return Undefined(env->isolate());
 
   // Short result requested.
   if (abbreviated) {
     maybe_cert =
-        X509ToObject(env, cert ? cert.get() : sk_X509_value(ssl_certs, 0));
+        X509ToObject(env, cert ? cert.get() : Thin_sk_X509_value(ssl_certs, 0));
     return maybe_cert.ToLocal(&result) ? result : MaybeLocal<Value>();
   }
 
@@ -1219,7 +1219,7 @@ MaybeLocal<Value> GetPeerCert(
     return Undefined(env->isolate());
 
   // First and main certificate.
-  X509Pointer first_cert(sk_X509_value(peer_certs.get(), 0));
+  X509Pointer first_cert(Thin_sk_X509_value(peer_certs.get(), 0));
   CHECK(first_cert);
   maybe_cert = X509ToObject(env, first_cert.release());
   if (!maybe_cert.ToLocal(&result))
@@ -1249,7 +1249,7 @@ MaybeLocal<Value> GetPeerCert(
     return MaybeLocal<Value>();
 
   // Last certificate should be self-signed.
-  if (X509_check_issued(cert.get(), cert.get()) == X509_V_OK &&
+  if (Thin_X509_check_issued(cert.get(), cert.get()) == X509_V_OK &&
       !Set<Object>(env->context(),
            issuer_chain,
            env->issuercert_string(),
@@ -1267,19 +1267,19 @@ MaybeLocal<Object> X509ToObject(
   Local<Context> context = env->context();
   Local<Object> info = Object::New(env->isolate());
 
-  BIOPointer bio(BIO_new(BIO_s_mem()));
+  BIOPointer bio(Thin_BIO_new(Thin_BIO_s_mem()));
   CHECK(bio);
 
-  // X509_check_ca() returns a range of values. Only 1 means "is a CA"
-  auto is_ca = Boolean::New(env->isolate(), 1 == X509_check_ca(cert));
+  // Thin_X509_check_ca() returns a range of values. Only 1 means "is a CA"
+  auto is_ca = Boolean::New(env->isolate(), 1 == Thin_X509_check_ca(cert));
   if (!Set<Value>(context,
                   info,
                   env->subject_string(),
-                  GetX509NameObject<X509_get_subject_name>(env, cert)) ||
+                  GetX509NameObject<Thin_X509_get_subject_name>(env, cert)) ||
       !Set<Value>(context,
                   info,
                   env->issuer_string(),
-                  GetX509NameObject<X509_get_issuer_name>(env, cert)) ||
+                  GetX509NameObject<Thin_X509_get_issuer_name>(env, cert)) ||
       !Set<Value>(context,
                   info,
                   env->subjectaltname_string(),
@@ -1292,16 +1292,16 @@ MaybeLocal<Object> X509ToObject(
     return MaybeLocal<Object>();
   }
 
-  EVPKeyPointer pkey(X509_get_pubkey(cert));
+  EVPKeyPointer pkey(Thin_X509_get_pubkey(cert));
   RSAPointer rsa;
   ECPointer ec;
   if (pkey) {
-    switch (EVP_PKEY_id(pkey.get())) {
+    switch (Thin_EVP_PKEY_id(pkey.get())) {
       case EVP_PKEY_RSA:
-        rsa.reset(EVP_PKEY_get1_RSA(pkey.get()));
+        rsa.reset(Thin_EVP_PKEY_get1_RSA(pkey.get()));
         break;
       case EVP_PKEY_EC:
-        ec.reset(EVP_PKEY_get1_EC_KEY(pkey.get()));
+        ec.reset(Thin_EVP_PKEY_get1_EC_KEY(pkey.get()));
         break;
     }
   }
@@ -1309,7 +1309,7 @@ MaybeLocal<Object> X509ToObject(
   if (rsa) {
     const BIGNUM* n;
     const BIGNUM* e;
-    RSA_get0_key(rsa.get(), &n, &e, nullptr);
+    Thin_RSA_get0_key(rsa.get(), &n, &e, nullptr);
     if (!Set<Value>(context,
                     info,
                     env->modulus_string(),
@@ -1326,7 +1326,7 @@ MaybeLocal<Object> X509ToObject(
       return MaybeLocal<Object>();
     }
   } else if (ec) {
-    const EC_GROUP* group = EC_KEY_get0_group(ec.get());
+    const EC_GROUP* group = Thin_EC_KEY_get0_group(ec.get());
 
     if (!Set<Value>(context,
                     info,
@@ -1339,18 +1339,18 @@ MaybeLocal<Object> X509ToObject(
       return MaybeLocal<Object>();
     }
 
-    const int nid = EC_GROUP_get_curve_name(group);
+    const int nid = Thin_EC_GROUP_get_curve_name(group);
     if (nid != 0) {
       // Curve is well-known, get its OID and NIST nick-name (if it has one).
 
       if (!Set<Value>(context,
                       info,
                       env->asn1curve_string(),
-                      GetCurveName<OBJ_nid2sn>(env, nid)) ||
+                      GetCurveName<Thin_OBJ_nid2sn>(env, nid)) ||
           !Set<Value>(context,
                       info,
                       env->nistcurve_string(),
-                      GetCurveName<EC_curve_nid2nist>(env, nid))) {
+                      GetCurveName<Thin_EC_curve_nid2nist>(env, nid))) {
         return MaybeLocal<Object>();
       }
     } else {
@@ -1381,15 +1381,15 @@ MaybeLocal<Object> X509ToObject(
   if (!Set<Value>(context,
                   info,
                   env->fingerprint_string(),
-                  GetFingerprintDigest(env, EVP_sha1(), cert)) ||
+                  GetFingerprintDigest(env, Thin_EVP_sha1(), cert)) ||
       !Set<Value>(context,
                   info,
                   env->fingerprint256_string(),
-                  GetFingerprintDigest(env, EVP_sha256(), cert)) ||
+                  GetFingerprintDigest(env, Thin_EVP_sha256(), cert)) ||
       !Set<Value>(context,
                   info,
                   env->fingerprint512_string(),
-                  GetFingerprintDigest(env, EVP_sha512(), cert)) ||
+                  GetFingerprintDigest(env, Thin_EVP_sha512(), cert)) ||
       !Set<Value>(context,
                   info,
                   env->ext_key_usage_string(),
diff --git a/src/crypto/crypto_common.h b/src/crypto/crypto_common.h
index 99eb83aae8..76194aad94 100644
--- a/src/crypto/crypto_common.h
+++ b/src/crypto/crypto_common.h
@@ -14,13 +14,13 @@ namespace node {
 namespace crypto {
 
 struct StackOfX509Deleter {
-  void operator()(STACK_OF(X509)* p) const { sk_X509_pop_free(p, X509_free); }
+  void operator()(STACK_OF(X509)* p) const { Thin_sk_X509_pop_free(p, Thin_X509_free); }
 };
 using StackOfX509 = std::unique_ptr<STACK_OF(X509), StackOfX509Deleter>;
 
 struct StackOfXASN1Deleter {
   void operator()(STACK_OF(ASN1_OBJECT)* p) const {
-    sk_ASN1_OBJECT_pop_free(p, ASN1_OBJECT_free);
+    Thin_sk_ASN1_OBJECT_pop_free(p, Thin_ASN1_OBJECT_free);
   }
 };
 using StackOfASN1 = std::unique_ptr<STACK_OF(ASN1_OBJECT), StackOfXASN1Deleter>;
diff --git a/src/crypto/crypto_context.cc b/src/crypto/crypto_context.cc
index 2062d600da..18b79f6092 100644
--- a/src/crypto/crypto_context.cc
+++ b/src/crypto/crypto_context.cc
@@ -59,7 +59,7 @@ inline X509_STORE* GetOrCreateRootCertStore() {
 }
 
 // Takes a string or buffer and loads it into a BIO.
-// Caller responsible for BIO_free_all-ing the returned object.
+// Caller responsible for Thin_BIO_free_all-ing the returned object.
 BIOPointer LoadBIO(Environment* env, Local<Value> v) {
   HandleScope scope(env->isolate());
 
@@ -77,7 +77,7 @@ BIOPointer LoadBIO(Environment* env, Local<Value> v) {
 }
 
 namespace {
-int SSL_CTX_use_certificate_chain(SSL_CTX* ctx,
+int Thin_SSL_CTX_use_certificate_chain(SSL_CTX* ctx,
                                   X509Pointer&& x,
                                   STACK_OF(X509)* extra_certs,
                                   X509Pointer* cert,
@@ -86,18 +86,18 @@ int SSL_CTX_use_certificate_chain(SSL_CTX* ctx,
   CHECK(!*cert);
   X509* issuer = nullptr;
 
-  int ret = SSL_CTX_use_certificate(ctx, x.get());
+  int ret = Thin_SSL_CTX_use_certificate(ctx, x.get());
 
   if (ret) {
     // If we could set up our certificate, now proceed to
     // the CA certificates.
-    SSL_CTX_clear_extra_chain_certs(ctx);
+    Thin_SSL_CTX_clear_extra_chain_certs(ctx);
 
-    for (int i = 0; i < sk_X509_num(extra_certs); i++) {
-      X509* ca = sk_X509_value(extra_certs, i);
+    for (int i = 0; i < Thin_sk_X509_num(extra_certs); i++) {
+      X509* ca = Thin_sk_X509_value(extra_certs, i);
 
       // NOTE: Increments reference count on `ca`
-      if (!SSL_CTX_add1_chain_cert(ctx, ca)) {
+      if (!Thin_SSL_CTX_add1_chain_cert(ctx, ca)) {
         ret = 0;
         issuer = nullptr;
         break;
@@ -105,10 +105,10 @@ int SSL_CTX_use_certificate_chain(SSL_CTX* ctx,
       // Note that we must not free r if it was successfully
       // added to the chain (while we must free the main
       // certificate, since its reference count is increased
-      // by SSL_CTX_use_certificate).
+      // by Thin_SSL_CTX_use_certificate).
 
       // Find issuer
-      if (issuer != nullptr || X509_check_issued(ca, x.get()) != X509_V_OK)
+      if (issuer != nullptr || Thin_X509_check_issued(ca, x.get()) != X509_V_OK)
         continue;
 
       issuer = ca;
@@ -126,7 +126,7 @@ int SSL_CTX_use_certificate_chain(SSL_CTX* ctx,
       // no need to free `store`
     } else {
       // Increment issuer reference count
-      issuer_->reset(X509_dup(issuer));
+      issuer_->reset(Thin_X509_dup(issuer));
       if (!*issuer_) {
         ret = 0;
       }
@@ -134,7 +134,7 @@ int SSL_CTX_use_certificate_chain(SSL_CTX* ctx,
   }
 
   if (ret && x != nullptr) {
-    cert->reset(X509_dup(x.get()));
+    cert->reset(Thin_X509_dup(x.get()));
     if (!*cert)
       ret = 0;
   }
@@ -146,31 +146,31 @@ int SSL_CTX_use_certificate_chain(SSL_CTX* ctx,
 // sent to the peer in the Certificate message.
 //
 // Taken from OpenSSL - edited for style.
-int SSL_CTX_use_certificate_chain(SSL_CTX* ctx,
+int Thin_SSL_CTX_use_certificate_chain(SSL_CTX* ctx,
                                   BIOPointer&& in,
                                   X509Pointer* cert,
                                   X509Pointer* issuer) {
-  // Just to ensure that `ERR_peek_last_error` below will return only errors
+  // Just to ensure that `Thin_ERR_peek_last_error` below will return only errors
   // that we are interested in
-  ERR_clear_error();
+  Thin_ERR_clear_error();
 
   X509Pointer x(
-      PEM_read_bio_X509_AUX(in.get(), nullptr, NoPasswordCallback, nullptr));
+      Thin_PEM_read_bio_X509_AUX(in.get(), nullptr, NoPasswordCallback, nullptr));
 
   if (!x)
     return 0;
 
   unsigned long err = 0;  // NOLINT(runtime/int)
 
-  StackOfX509 extra_certs(sk_X509_new_null());
+  StackOfX509 extra_certs(Thin_sk_X509_new_null());
   if (!extra_certs)
     return 0;
 
-  while (X509Pointer extra {PEM_read_bio_X509(in.get(),
+  while (X509Pointer extra {Thin_PEM_read_bio_X509(in.get(),
                                     nullptr,
                                     NoPasswordCallback,
                                     nullptr)}) {
-    if (sk_X509_push(extra_certs.get(), extra.get())) {
+    if (Thin_sk_X509_push(extra_certs.get(), extra.get())) {
       extra.release();
       continue;
     }
@@ -179,16 +179,16 @@ int SSL_CTX_use_certificate_chain(SSL_CTX* ctx,
   }
 
   // When the while loop ends, it's usually just EOF.
-  err = ERR_peek_last_error();
+  err = Thin_ERR_peek_last_error();
   if (ERR_GET_LIB(err) == ERR_LIB_PEM &&
       ERR_GET_REASON(err) == PEM_R_NO_START_LINE) {
-    ERR_clear_error();
+    Thin_ERR_clear_error();
   } else {
     // some real error
     return 0;
   }
 
-  return SSL_CTX_use_certificate_chain(ctx,
+  return Thin_SSL_CTX_use_certificate_chain(ctx,
                                        std::move(x),
                                        extra_certs.get(),
                                        cert,
@@ -206,7 +206,7 @@ X509_STORE* NewRootCertStore() {
       per_process::cli_options->ssl_openssl_cert_store == false) {
     for (size_t i = 0; i < arraysize(root_certs); i++) {
       X509* x509 =
-          PEM_read_bio_X509(NodeBIO::NewFixed(root_certs[i],
+          Thin_PEM_read_bio_X509(NodeBIO::NewFixed(root_certs[i],
                                               strlen(root_certs[i])).get(),
                             nullptr,   // no re-use of X509 structure
                             NoPasswordCallback,
@@ -219,20 +219,20 @@ X509_STORE* NewRootCertStore() {
     }
   }
 
-  X509_STORE* store = X509_STORE_new();
+  X509_STORE* store = Thin_X509_STORE_new();
   if (*system_cert_path != '\0') {
-    ERR_set_mark();
-    X509_STORE_load_locations(store, system_cert_path, nullptr);
-    ERR_pop_to_mark();
+    Thin_ERR_set_mark();
+    Thin_X509_STORE_load_locations(store, system_cert_path, nullptr);
+    Thin_ERR_pop_to_mark();
   }
 
   Mutex::ScopedLock cli_lock(node::per_process::cli_options_mutex);
   if (per_process::cli_options->ssl_openssl_cert_store) {
-    X509_STORE_set_default_paths(store);
+    Thin_X509_STORE_set_default_paths(store);
   } else {
     for (X509* cert : root_certs_vector) {
-      X509_up_ref(cert);
-      X509_STORE_add_cert(store, cert);
+      Thin_X509_up_ref(cert);
+      Thin_X509_STORE_add_cert(store, cert);
     }
   }
 
@@ -434,7 +434,7 @@ void SecureContext::Init(const FunctionCallbackInfo<Value>& args) {
 
   int min_version = args[1].As<Int32>()->Value();
   int max_version = args[2].As<Int32>()->Value();
-  const SSL_METHOD* method = TLS_method();
+  const SSL_METHOD* method = Thin_TLS_method();
 
   if (max_version == 0)
     max_version = kMaxSupportedVersion;
@@ -460,54 +460,54 @@ void SecureContext::Init(const FunctionCallbackInfo<Value>& args) {
       max_version = TLS1_2_VERSION;
     } else if (sslmethod == "SSLv23_server_method") {
       max_version = TLS1_2_VERSION;
-      method = TLS_server_method();
+      method = Thin_TLS_server_method();
     } else if (sslmethod == "SSLv23_client_method") {
       max_version = TLS1_2_VERSION;
-      method = TLS_client_method();
-    } else if (sslmethod == "TLS_method") {
+      method = Thin_TLS_client_method();
+    } else if (sslmethod == "Thin_TLS_method") {
       min_version = 0;
       max_version = kMaxSupportedVersion;
-    } else if (sslmethod == "TLS_server_method") {
+    } else if (sslmethod == "Thin_TLS_server_method") {
       min_version = 0;
       max_version = kMaxSupportedVersion;
-      method = TLS_server_method();
-    } else if (sslmethod == "TLS_client_method") {
+      method = Thin_TLS_server_method();
+    } else if (sslmethod == "Thin_TLS_client_method") {
       min_version = 0;
       max_version = kMaxSupportedVersion;
-      method = TLS_client_method();
+      method = Thin_TLS_client_method();
     } else if (sslmethod == "TLSv1_method") {
       min_version = TLS1_VERSION;
       max_version = TLS1_VERSION;
     } else if (sslmethod == "TLSv1_server_method") {
       min_version = TLS1_VERSION;
       max_version = TLS1_VERSION;
-      method = TLS_server_method();
+      method = Thin_TLS_server_method();
     } else if (sslmethod == "TLSv1_client_method") {
       min_version = TLS1_VERSION;
       max_version = TLS1_VERSION;
-      method = TLS_client_method();
+      method = Thin_TLS_client_method();
     } else if (sslmethod == "TLSv1_1_method") {
       min_version = TLS1_1_VERSION;
       max_version = TLS1_1_VERSION;
     } else if (sslmethod == "TLSv1_1_server_method") {
       min_version = TLS1_1_VERSION;
       max_version = TLS1_1_VERSION;
-      method = TLS_server_method();
+      method = Thin_TLS_server_method();
     } else if (sslmethod == "TLSv1_1_client_method") {
       min_version = TLS1_1_VERSION;
       max_version = TLS1_1_VERSION;
-      method = TLS_client_method();
+      method = Thin_TLS_client_method();
     } else if (sslmethod == "TLSv1_2_method") {
       min_version = TLS1_2_VERSION;
       max_version = TLS1_2_VERSION;
     } else if (sslmethod == "TLSv1_2_server_method") {
       min_version = TLS1_2_VERSION;
       max_version = TLS1_2_VERSION;
-      method = TLS_server_method();
+      method = Thin_TLS_server_method();
     } else if (sslmethod == "TLSv1_2_client_method") {
       min_version = TLS1_2_VERSION;
       max_version = TLS1_2_VERSION;
-      method = TLS_client_method();
+      method = Thin_TLS_client_method();
     } else {
       THROW_ERR_TLS_INVALID_PROTOCOL_METHOD(
           env, "Unknown method: %s", *sslmethod);
@@ -515,36 +515,36 @@ void SecureContext::Init(const FunctionCallbackInfo<Value>& args) {
     }
   }
 
-  sc->ctx_.reset(SSL_CTX_new(method));
+  sc->ctx_.reset(Thin_SSL_CTX_new(method));
   if (!sc->ctx_) {
-    return ThrowCryptoError(env, ERR_get_error(), "SSL_CTX_new");
+    return ThrowCryptoError(env, Thin_ERR_get_error(), "Thin_SSL_CTX_new");
   }
-  SSL_CTX_set_app_data(sc->ctx_.get(), sc);
+  Thin_SSL_CTX_set_app_data(sc->ctx_.get(), sc);
 
-  // Disable SSLv2 in the case when method == TLS_method() and the
+  // Disable SSLv2 in the case when method == Thin_TLS_method() and the
   // cipher list contains SSLv2 ciphers (not the default, should be rare.)
   // The bundled OpenSSL doesn't have SSLv2 support but the system OpenSSL may.
   // SSLv3 is disabled because it's susceptible to downgrade attacks (POODLE.)
-  SSL_CTX_set_options(sc->ctx_.get(), SSL_OP_NO_SSLv2);
-  SSL_CTX_set_options(sc->ctx_.get(), SSL_OP_NO_SSLv3);
+  Thin_SSL_CTX_set_options(sc->ctx_.get(), SSL_OP_NO_SSLv2);
+  Thin_SSL_CTX_set_options(sc->ctx_.get(), SSL_OP_NO_SSLv3);
 #if OPENSSL_VERSION_MAJOR >= 3
-  SSL_CTX_set_options(sc->ctx_.get(), SSL_OP_ALLOW_CLIENT_RENEGOTIATION);
+  Thin_SSL_CTX_set_options(sc->ctx_.get(), SSL_OP_ALLOW_CLIENT_RENEGOTIATION);
 #endif
 
   // Enable automatic cert chaining. This is enabled by default in OpenSSL, but
   // disabled by default in BoringSSL. Enable it explicitly to make the
   // behavior match when Node is built with BoringSSL.
-  SSL_CTX_clear_mode(sc->ctx_.get(), SSL_MODE_NO_AUTO_CHAIN);
+  Thin_SSL_CTX_clear_mode(sc->ctx_.get(), SSL_MODE_NO_AUTO_CHAIN);
 
   // SSL session cache configuration
-  SSL_CTX_set_session_cache_mode(sc->ctx_.get(),
+  Thin_SSL_CTX_set_session_cache_mode(sc->ctx_.get(),
                                  SSL_SESS_CACHE_CLIENT |
                                  SSL_SESS_CACHE_SERVER |
                                  SSL_SESS_CACHE_NO_INTERNAL |
                                  SSL_SESS_CACHE_NO_AUTO_CLEAR);
 
-  SSL_CTX_set_min_proto_version(sc->ctx_.get(), min_version);
-  SSL_CTX_set_max_proto_version(sc->ctx_.get(), max_version);
+  Thin_SSL_CTX_set_min_proto_version(sc->ctx_.get(), min_version);
+  Thin_SSL_CTX_set_max_proto_version(sc->ctx_.get(), max_version);
 
   // OpenSSL 1.1.0 changed the ticket key size, but the OpenSSL 1.0.x size was
   // exposed in the public API. To retain compatibility, install a callback
@@ -555,31 +555,31 @@ void SecureContext::Init(const FunctionCallbackInfo<Value>& args) {
     return THROW_ERR_CRYPTO_OPERATION_FAILED(
         env, "Error generating ticket keys");
   }
-  SSL_CTX_set_tlsext_ticket_key_cb(sc->ctx_.get(), TicketCompatibilityCallback);
+  Thin_SSL_CTX_set_tlsext_ticket_key_cb(sc->ctx_.get(), TicketCompatibilityCallback);
 }
 
 SSLPointer SecureContext::CreateSSL() {
-  return SSLPointer(SSL_new(ctx_.get()));
+  return SSLPointer(Thin_SSL_new(ctx_.get()));
 }
 
 void SecureContext::SetNewSessionCallback(NewSessionCb cb) {
-  SSL_CTX_sess_set_new_cb(ctx_.get(), cb);
+  Thin_SSL_CTX_sess_set_new_cb(ctx_.get(), cb);
 }
 
 void SecureContext::SetGetSessionCallback(GetSessionCb cb) {
-  SSL_CTX_sess_set_get_cb(ctx_.get(), cb);
+  Thin_SSL_CTX_sess_set_get_cb(ctx_.get(), cb);
 }
 
 void SecureContext::SetSelectSNIContextCallback(SelectSNIContextCb cb) {
-  SSL_CTX_set_tlsext_servername_callback(ctx_.get(), cb);
+  Thin_SSL_CTX_set_tlsext_servername_callback(ctx_.get(), cb);
 }
 
 void SecureContext::SetSelectClientCertCallback(SelectClientCertCb cb) {
-  SSL_CTX_set_client_cert_cb(ctx_.get(), cb);
+  Thin_SSL_CTX_set_client_cert_cb(ctx_.get(), cb);
 }
 
 void SecureContext::SetKeylogCallback(KeylogCb cb) {
-  SSL_CTX_set_keylog_callback(ctx_.get(), cb);
+  Thin_SSL_CTX_set_keylog_callback(ctx_.get(), cb);
 }
 
 Maybe<bool> SecureContext::UseKey(Environment* env,
@@ -590,8 +590,8 @@ Maybe<bool> SecureContext::UseKey(Environment* env,
   }
 
   ClearErrorOnReturn clear_error_on_return;
-  if (!SSL_CTX_use_PrivateKey(ctx_.get(), key->GetAsymmetricKey().get())) {
-    ThrowCryptoError(env, ERR_get_error(), "SSL_CTX_use_PrivateKey");
+  if (!Thin_SSL_CTX_use_PrivateKey(ctx_.get(), key->GetAsymmetricKey().get())) {
+    ThrowCryptoError(env, Thin_ERR_get_error(), "Thin_SSL_CTX_use_PrivateKey");
     return Nothing<bool>();
   }
 
@@ -619,16 +619,16 @@ void SecureContext::SetKey(const FunctionCallbackInfo<Value>& args) {
   const ByteSource* pass_ptr = &passphrase;
 
   EVPKeyPointer key(
-      PEM_read_bio_PrivateKey(bio.get(),
+      Thin_PEM_read_bio_PrivateKey(bio.get(),
                               nullptr,
                               PasswordCallback,
                               &pass_ptr));
 
   if (!key)
-    return ThrowCryptoError(env, ERR_get_error(), "PEM_read_bio_PrivateKey");
+    return ThrowCryptoError(env, Thin_ERR_get_error(), "Thin_PEM_read_bio_PrivateKey");
 
-  if (!SSL_CTX_use_PrivateKey(sc->ctx_.get(), key.get()))
-    return ThrowCryptoError(env, ERR_get_error(), "SSL_CTX_use_PrivateKey");
+  if (!Thin_SSL_CTX_use_PrivateKey(sc->ctx_.get(), key.get()))
+    return ThrowCryptoError(env, Thin_ERR_get_error(), "Thin_SSL_CTX_use_PrivateKey");
   sc->client_key_provided_ = true;
 }
 
@@ -643,8 +643,8 @@ void SecureContext::SetSigalgs(const FunctionCallbackInfo<Value>& args) {
 
   const Utf8Value sigalgs(env->isolate(), args[0]);
 
-  if (!SSL_CTX_set1_sigalgs_list(sc->ctx_.get(), *sigalgs))
-    return ThrowCryptoError(env, ERR_get_error());
+  if (!Thin_SSL_CTX_set1_sigalgs_list(sc->ctx_.get(), *sigalgs))
+    return ThrowCryptoError(env, Thin_ERR_get_error());
 }
 
 #ifndef OPENSSL_NO_ENGINE
@@ -666,7 +666,7 @@ void SecureContext::SetEngineKey(const FunctionCallbackInfo<Value>& args) {
     return;
   }
 
-  if (!ENGINE_init(engine.get())) {
+  if (!Thin_ENGINE_init(engine.get())) {
     return THROW_ERR_CRYPTO_OPERATION_FAILED(
         env, "Failure to initialize engine");
   }
@@ -674,14 +674,14 @@ void SecureContext::SetEngineKey(const FunctionCallbackInfo<Value>& args) {
   engine.finish_on_exit = true;
 
   Utf8Value key_name(env->isolate(), args[0]);
-  EVPKeyPointer key(ENGINE_load_private_key(engine.get(), *key_name,
+  EVPKeyPointer key(Thin_ENGINE_load_private_key(engine.get(), *key_name,
                                             nullptr, nullptr));
 
   if (!key)
-    return ThrowCryptoError(env, ERR_get_error(), "ENGINE_load_private_key");
+    return ThrowCryptoError(env, Thin_ERR_get_error(), "Thin_ENGINE_load_private_key");
 
-  if (!SSL_CTX_use_PrivateKey(sc->ctx_.get(), key.get()))
-    return ThrowCryptoError(env, ERR_get_error(), "SSL_CTX_use_PrivateKey");
+  if (!Thin_SSL_CTX_use_PrivateKey(sc->ctx_.get(), key.get()))
+    return ThrowCryptoError(env, Thin_ERR_get_error(), "Thin_SSL_CTX_use_PrivateKey");
 
   sc->private_key_engine_ = std::move(engine);
 }
@@ -693,12 +693,12 @@ Maybe<bool> SecureContext::AddCert(Environment* env, BIOPointer&& bio) {
   cert_.reset();
   issuer_.reset();
 
-  // The SSL_CTX_use_certificate_chain call here is not from openssl, this is
+  // The Thin_SSL_CTX_use_certificate_chain call here is not from openssl, this is
   // the method implemented elsewhere in this file. The naming is a bit
   // confusing, unfortunately.
-  if (SSL_CTX_use_certificate_chain(
+  if (Thin_SSL_CTX_use_certificate_chain(
           ctx_.get(), std::move(bio), &cert_, &issuer_) == 0) {
-    ThrowCryptoError(env, ERR_get_error(), "SSL_CTX_use_certificate_chain");
+    ThrowCryptoError(env, Thin_ERR_get_error(), "Thin_SSL_CTX_use_certificate_chain");
     return Nothing<bool>();
   }
   return Just(true);
@@ -719,18 +719,18 @@ void SecureContext::SetCert(const FunctionCallbackInfo<Value>& args) {
 void SecureContext::SetCACert(const BIOPointer& bio) {
   ClearErrorOnReturn clear_error_on_return;
   if (!bio) return;
-  X509_STORE* cert_store = SSL_CTX_get_cert_store(ctx_.get());
-  while (X509Pointer x509 = X509Pointer(PEM_read_bio_X509_AUX(
+  X509_STORE* cert_store = Thin_SSL_CTX_get_cert_store(ctx_.get());
+  while (X509Pointer x509 = X509Pointer(Thin_PEM_read_bio_X509_AUX(
              bio.get(), nullptr, NoPasswordCallback, nullptr))) {
     if (cert_store == GetOrCreateRootCertStore()) {
       cert_store = NewRootCertStore();
-      SSL_CTX_set_cert_store(ctx_.get(), cert_store);
+      Thin_SSL_CTX_set_cert_store(ctx_.get(), cert_store);
     }
-    CHECK_EQ(1, X509_STORE_add_cert(cert_store, x509.get()));
-    CHECK_EQ(1, SSL_CTX_add_client_CA(ctx_.get(), x509.get()));
+    CHECK_EQ(1, Thin_X509_STORE_add_cert(cert_store, x509.get()));
+    CHECK_EQ(1, Thin_SSL_CTX_add_client_CA(ctx_.get(), x509.get()));
   }
   if (cert_store) {
-    X509_STORE_set_flags(cert_store, X509_V_FLAG_PARTIAL_CHAIN);
+    Thin_X509_STORE_set_flags(cert_store, X509_V_FLAG_PARTIAL_CHAIN);
   }
 }
 
@@ -750,23 +750,23 @@ Maybe<bool> SecureContext::SetCRL(Environment* env, const BIOPointer& bio) {
   ClearErrorOnReturn clear_error_on_return;
   if (!bio) return Just(false);
 
-  DeleteFnPtr<X509_CRL, X509_CRL_free> crl(
-      PEM_read_bio_X509_CRL(bio.get(), nullptr, NoPasswordCallback, nullptr));
+  DeleteFnPtr<X509_CRL, Thin_X509_CRL_free> crl(
+      Thin_PEM_read_bio_X509_CRL(bio.get(), nullptr, NoPasswordCallback, nullptr));
 
   if (!crl) {
     THROW_ERR_CRYPTO_OPERATION_FAILED(env, "Failed to parse CRL");
     return Nothing<bool>();
   }
 
-  X509_STORE* cert_store = SSL_CTX_get_cert_store(ctx_.get());
+  X509_STORE* cert_store = Thin_SSL_CTX_get_cert_store(ctx_.get());
   if (cert_store == GetOrCreateRootCertStore()) {
     cert_store = NewRootCertStore();
-    SSL_CTX_set_cert_store(ctx_.get(), cert_store);
+    Thin_SSL_CTX_set_cert_store(ctx_.get(), cert_store);
   }
 
-  CHECK_EQ(1, X509_STORE_add_crl(cert_store, crl.get()));
+  CHECK_EQ(1, Thin_X509_STORE_add_crl(cert_store, crl.get()));
   CHECK_EQ(1,
-           X509_STORE_set_flags(
+           Thin_X509_STORE_set_flags(
                cert_store, X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL));
   return Just(true);
 }
@@ -788,9 +788,9 @@ void SecureContext::SetRootCerts() {
   auto store = GetOrCreateRootCertStore();
 
   // Increment reference count so global store is not deleted along with CTX.
-  X509_STORE_up_ref(store);
-  X509_STORE_set_flags(store, X509_V_FLAG_PARTIAL_CHAIN);
-  SSL_CTX_set_cert_store(ctx_.get(), store);
+  Thin_X509_STORE_up_ref(store);
+  Thin_X509_STORE_set_flags(store, X509_V_FLAG_PARTIAL_CHAIN);
+  Thin_SSL_CTX_set_cert_store(ctx_.get(), store);
 }
 
 void SecureContext::AddRootCerts(const FunctionCallbackInfo<Value>& args) {
@@ -811,8 +811,8 @@ void SecureContext::SetCipherSuites(const FunctionCallbackInfo<Value>& args) {
   CHECK(args[0]->IsString());
 
   const Utf8Value ciphers(env->isolate(), args[0]);
-  if (!SSL_CTX_set_ciphersuites(sc->ctx_.get(), *ciphers))
-    return ThrowCryptoError(env, ERR_get_error(), "Failed to set ciphers");
+  if (!Thin_SSL_CTX_set_ciphersuites(sc->ctx_.get(), *ciphers))
+    return ThrowCryptoError(env, Thin_ERR_get_error(), "Failed to set ciphers");
 #endif
 }
 
@@ -826,8 +826,8 @@ void SecureContext::SetCiphers(const FunctionCallbackInfo<Value>& args) {
   CHECK(args[0]->IsString());
 
   Utf8Value ciphers(env->isolate(), args[0]);
-  if (!SSL_CTX_set_cipher_list(sc->ctx_.get(), *ciphers)) {
-    unsigned long err = ERR_get_error();  // NOLINT(runtime/int)
+  if (!Thin_SSL_CTX_set_cipher_list(sc->ctx_.get(), *ciphers)) {
+    unsigned long err = Thin_ERR_get_error();  // NOLINT(runtime/int)
 
     if (strlen(*ciphers) == 0 && ERR_GET_REASON(err) == SSL_R_NO_CIPHER_MATCH) {
       // TLS1.2 ciphers were deliberately cleared, so don't consider
@@ -851,7 +851,7 @@ void SecureContext::SetECDHCurve(const FunctionCallbackInfo<Value>& args) {
   Utf8Value curve(env->isolate(), args[0]);
 
   if (strcmp(*curve, "auto") != 0 &&
-      !SSL_CTX_set1_curves_list(sc->ctx_.get(), *curve)) {
+      !Thin_SSL_CTX_set1_curves_list(sc->ctx_.get(), *curve)) {
     return THROW_ERR_CRYPTO_OPERATION_FAILED(env, "Failed to set ECDH curve");
   }
 }
@@ -868,7 +868,7 @@ void SecureContext::SetDHParam(const FunctionCallbackInfo<Value>& args) {
   // true to this function instead of the original string. Any other string
   // value will be interpreted as custom DH parameters below.
   if (args[0]->IsTrue()) {
-    CHECK(SSL_CTX_set_dh_auto(sc->ctx_.get(), true));
+    CHECK(Thin_SSL_CTX_set_dh_auto(sc->ctx_.get(), true));
     return;
   }
 
@@ -878,7 +878,7 @@ void SecureContext::SetDHParam(const FunctionCallbackInfo<Value>& args) {
     if (!bio)
       return;
 
-    dh.reset(PEM_read_bio_DHparams(bio.get(), nullptr, nullptr, nullptr));
+    dh.reset(Thin_PEM_read_bio_DHparams(bio.get(), nullptr, nullptr, nullptr));
   }
 
   // Invalid dhparam is silently discarded and DHE is no longer used.
@@ -887,8 +887,8 @@ void SecureContext::SetDHParam(const FunctionCallbackInfo<Value>& args) {
     return;
 
   const BIGNUM* p;
-  DH_get0_pqg(dh.get(), &p, nullptr, nullptr);
-  const int size = BN_num_bits(p);
+  Thin_DH_get0_pqg(dh.get(), &p, nullptr, nullptr);
+  const int size = Thin_BN_num_bits(p);
   if (size < 1024) {
     return THROW_ERR_INVALID_ARG_VALUE(
         env, "DH parameter is less than 1024 bits");
@@ -897,7 +897,7 @@ void SecureContext::SetDHParam(const FunctionCallbackInfo<Value>& args) {
         env->isolate(), "DH parameter is less than 2048 bits"));
   }
 
-  if (!SSL_CTX_set_tmp_dh(sc->ctx_.get(), dh.get())) {
+  if (!Thin_SSL_CTX_set_tmp_dh(sc->ctx_.get(), dh.get())) {
     return THROW_ERR_CRYPTO_OPERATION_FAILED(
         env, "Error setting temp DH parameter");
   }
@@ -912,7 +912,7 @@ void SecureContext::SetMinProto(const FunctionCallbackInfo<Value>& args) {
 
   int version = args[0].As<Int32>()->Value();
 
-  CHECK(SSL_CTX_set_min_proto_version(sc->ctx_.get(), version));
+  CHECK(Thin_SSL_CTX_set_min_proto_version(sc->ctx_.get(), version));
 }
 
 void SecureContext::SetMaxProto(const FunctionCallbackInfo<Value>& args) {
@@ -924,7 +924,7 @@ void SecureContext::SetMaxProto(const FunctionCallbackInfo<Value>& args) {
 
   int version = args[0].As<Int32>()->Value();
 
-  CHECK(SSL_CTX_set_max_proto_version(sc->ctx_.get(), version));
+  CHECK(Thin_SSL_CTX_set_max_proto_version(sc->ctx_.get(), version));
 }
 
 void SecureContext::GetMinProto(const FunctionCallbackInfo<Value>& args) {
@@ -934,7 +934,7 @@ void SecureContext::GetMinProto(const FunctionCallbackInfo<Value>& args) {
   CHECK_EQ(args.Length(), 0);
 
   long version =  // NOLINT(runtime/int)
-    SSL_CTX_get_min_proto_version(sc->ctx_.get());
+    Thin_SSL_CTX_get_min_proto_version(sc->ctx_.get());
   args.GetReturnValue().Set(static_cast<uint32_t>(version));
 }
 
@@ -945,7 +945,7 @@ void SecureContext::GetMaxProto(const FunctionCallbackInfo<Value>& args) {
   CHECK_EQ(args.Length(), 0);
 
   long version =  // NOLINT(runtime/int)
-    SSL_CTX_get_max_proto_version(sc->ctx_.get());
+    Thin_SSL_CTX_get_max_proto_version(sc->ctx_.get());
   args.GetReturnValue().Set(static_cast<uint32_t>(version));
 }
 
@@ -959,7 +959,7 @@ void SecureContext::SetOptions(const FunctionCallbackInfo<Value>& args) {
 
   int64_t val = args[0]->IntegerValue(env->context()).FromMaybe(0);
 
-  SSL_CTX_set_options(sc->ctx_.get(),
+  Thin_SSL_CTX_set_options(sc->ctx_.get(),
                       static_cast<long>(val));  // NOLINT(runtime/int)
 }
 
@@ -977,19 +977,19 @@ void SecureContext::SetSessionIdContext(
       reinterpret_cast<const unsigned char*>(*sessionIdContext);
   unsigned int sid_ctx_len = sessionIdContext.length();
 
-  if (SSL_CTX_set_session_id_context(sc->ctx_.get(), sid_ctx, sid_ctx_len) == 1)
+  if (Thin_SSL_CTX_set_session_id_context(sc->ctx_.get(), sid_ctx, sid_ctx_len) == 1)
     return;
 
   BUF_MEM* mem;
   Local<String> message;
 
-  BIOPointer bio(BIO_new(BIO_s_mem()));
+  BIOPointer bio(Thin_BIO_new(Thin_BIO_s_mem()));
   if (!bio) {
     message = FIXED_ONE_BYTE_STRING(env->isolate(),
-                                    "SSL_CTX_set_session_id_context error");
+                                    "Thin_SSL_CTX_set_session_id_context error");
   } else {
-    ERR_print_errors(bio.get());
-    BIO_get_mem_ptr(bio.get(), &mem);
+    Thin_ERR_print_errors(bio.get());
+    Thin_BIO_get_mem_ptr(bio.get(), &mem);
     message = OneByteString(env->isolate(), mem->data, mem->length);
   }
 
@@ -1004,7 +1004,7 @@ void SecureContext::SetSessionTimeout(const FunctionCallbackInfo<Value>& args) {
   CHECK(args[0]->IsInt32());
 
   int32_t sessionTimeout = args[0].As<Int32>()->Value();
-  SSL_CTX_set_timeout(sc->ctx_.get(), sessionTimeout);
+  Thin_SSL_CTX_set_timeout(sc->ctx_.get(), sessionTimeout);
 }
 
 void SecureContext::Close(const FunctionCallbackInfo<Value>& args) {
@@ -1047,9 +1047,9 @@ void SecureContext::LoadPKCS12(const FunctionCallbackInfo<Value>& args) {
   sc->issuer_.reset();
   sc->cert_.reset();
 
-  X509_STORE* cert_store = SSL_CTX_get_cert_store(sc->ctx_.get());
+  X509_STORE* cert_store = Thin_SSL_CTX_get_cert_store(sc->ctx_.get());
 
-  DeleteFnPtr<PKCS12, PKCS12_free> p12;
+  DeleteFnPtr<PKCS12, Thin_PKCS12_free> p12;
   EVPKeyPointer pkey;
   X509Pointer cert;
   StackOfX509 extra_certs;
@@ -1058,38 +1058,38 @@ void SecureContext::LoadPKCS12(const FunctionCallbackInfo<Value>& args) {
   EVP_PKEY* pkey_ptr = nullptr;
   X509* cert_ptr = nullptr;
   STACK_OF(X509)* extra_certs_ptr = nullptr;
-  if (d2i_PKCS12_bio(in.get(), &p12_ptr) &&
+  if (Thin_d2i_PKCS12_bio(in.get(), &p12_ptr) &&
       (p12.reset(p12_ptr), true) &&  // Move ownership to the smart pointer.
-      PKCS12_parse(p12.get(), pass.data(),
+      Thin_PKCS12_parse(p12.get(), pass.data(),
                    &pkey_ptr,
                    &cert_ptr,
                    &extra_certs_ptr) &&
       (pkey.reset(pkey_ptr), cert.reset(cert_ptr),
        extra_certs.reset(extra_certs_ptr), true) &&  // Move ownership.
-      SSL_CTX_use_certificate_chain(sc->ctx_.get(),
+      Thin_SSL_CTX_use_certificate_chain(sc->ctx_.get(),
                                     std::move(cert),
                                     extra_certs.get(),
                                     &sc->cert_,
                                     &sc->issuer_) &&
-      SSL_CTX_use_PrivateKey(sc->ctx_.get(), pkey.get())) {
+      Thin_SSL_CTX_use_PrivateKey(sc->ctx_.get(), pkey.get())) {
     // Add CA certs too
-    for (int i = 0; i < sk_X509_num(extra_certs.get()); i++) {
-      X509* ca = sk_X509_value(extra_certs.get(), i);
+    for (int i = 0; i < Thin_sk_X509_num(extra_certs.get()); i++) {
+      X509* ca = Thin_sk_X509_value(extra_certs.get(), i);
 
       if (cert_store == GetOrCreateRootCertStore()) {
         cert_store = NewRootCertStore();
-        SSL_CTX_set_cert_store(sc->ctx_.get(), cert_store);
+        Thin_SSL_CTX_set_cert_store(sc->ctx_.get(), cert_store);
       }
-      X509_STORE_add_cert(cert_store, ca);
-      SSL_CTX_add_client_CA(sc->ctx_.get(), ca);
+      Thin_X509_STORE_add_cert(cert_store, ca);
+      Thin_SSL_CTX_add_client_CA(sc->ctx_.get(), ca);
     }
     ret = true;
   }
 
   if (!ret) {
     // TODO(@jasnell): Should this use ThrowCryptoError?
-    unsigned long err = ERR_get_error();  // NOLINT(runtime/int)
-    const char* str = ERR_reason_error_string(err);
+    unsigned long err = Thin_ERR_get_error();  // NOLINT(runtime/int)
+    const char* str = Thin_ERR_reason_error_string(err);
     str = str != nullptr ? str : "Unknown error";
 
     return env->ThrowError(str);
@@ -1108,7 +1108,7 @@ void SecureContext::SetClientCertEngine(
 
   MarkPopErrorOnReturn mark_pop_error_on_return;
 
-  // SSL_CTX_set_client_cert_engine does not itself support multiple
+  // Thin_SSL_CTX_set_client_cert_engine does not itself support multiple
   // calls by cleaning up before overwriting the client_cert_engine
   // internal context variable.
   // Instead of trying to fix up this problem we in turn also do not
@@ -1126,8 +1126,8 @@ void SecureContext::SetClientCertEngine(
   }
 
   // Note that this takes another reference to `engine`.
-  if (!SSL_CTX_set_client_cert_engine(sc->ctx_.get(), engine.get()))
-    return ThrowCryptoError(env, ERR_get_error());
+  if (!Thin_SSL_CTX_set_client_cert_engine(sc->ctx_.get(), engine.get()))
+    return ThrowCryptoError(env, Thin_ERR_get_error());
   sc->client_cert_engine_provided_ = true;
 }
 #endif  // !OPENSSL_NO_ENGINE
@@ -1176,7 +1176,7 @@ void SecureContext::EnableTicketKeyCallback(
   SecureContext* wrap;
   ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
 
-  SSL_CTX_set_tlsext_ticket_key_cb(wrap->ctx_.get(), TicketKeyCallback);
+  Thin_SSL_CTX_set_tlsext_ticket_key_cb(wrap->ctx_.get(), TicketKeyCallback);
 }
 
 int SecureContext::TicketKeyCallback(SSL* ssl,
@@ -1188,7 +1188,7 @@ int SecureContext::TicketKeyCallback(SSL* ssl,
   static const int kTicketPartSize = 16;
 
   SecureContext* sc = static_cast<SecureContext*>(
-      SSL_CTX_get_app_data(SSL_get_SSL_CTX(ssl)));
+      Thin_SSL_CTX_get_app_data(Thin_SSL_get_SSL_CTX(ssl)));
 
   Environment* env = sc->env();
   HandleScope handle_scope(env->isolate());
@@ -1256,22 +1256,22 @@ int SecureContext::TicketKeyCallback(SSL* ssl,
   }
 
   ArrayBufferViewContents<unsigned char> hmac_buf(hmac);
-  HMAC_Init_ex(hctx,
+  Thin_HMAC_Init_ex(hctx,
                hmac_buf.data(),
                hmac_buf.length(),
-               EVP_sha256(),
+               Thin_EVP_sha256(),
                nullptr);
 
   ArrayBufferViewContents<unsigned char> aes_key(aes.As<ArrayBufferView>());
   if (enc) {
-    EVP_EncryptInit_ex(ectx,
-                       EVP_aes_128_cbc(),
+    Thin_EVP_EncryptInit_ex(ectx,
+                       Thin_EVP_aes_128_cbc(),
                        nullptr,
                        aes_key.data(),
                        iv);
   } else {
-    EVP_DecryptInit_ex(ectx,
-                       EVP_aes_128_cbc(),
+    Thin_EVP_DecryptInit_ex(ectx,
+                       Thin_EVP_aes_128_cbc(),
                        nullptr,
                        aes_key.data(),
                        iv);
@@ -1287,17 +1287,17 @@ int SecureContext::TicketCompatibilityCallback(SSL* ssl,
                                                HMAC_CTX* hctx,
                                                int enc) {
   SecureContext* sc = static_cast<SecureContext*>(
-      SSL_CTX_get_app_data(SSL_get_SSL_CTX(ssl)));
+      Thin_SSL_CTX_get_app_data(Thin_SSL_get_SSL_CTX(ssl)));
 
   if (enc) {
     memcpy(name, sc->ticket_key_name_, sizeof(sc->ticket_key_name_));
     if (CSPRNG(iv, 16).is_err() ||
-        EVP_EncryptInit_ex(
-            ectx, EVP_aes_128_cbc(), nullptr, sc->ticket_key_aes_, iv) <= 0 ||
-        HMAC_Init_ex(hctx,
+        Thin_EVP_EncryptInit_ex(
+            ectx, Thin_EVP_aes_128_cbc(), nullptr, sc->ticket_key_aes_, iv) <= 0 ||
+        Thin_HMAC_Init_ex(hctx,
                      sc->ticket_key_hmac_,
                      sizeof(sc->ticket_key_hmac_),
-                     EVP_sha256(),
+                     Thin_EVP_sha256(),
                      nullptr) <= 0) {
       return -1;
     }
@@ -1309,10 +1309,10 @@ int SecureContext::TicketCompatibilityCallback(SSL* ssl,
     return 0;
   }
 
-  if (EVP_DecryptInit_ex(ectx, EVP_aes_128_cbc(), nullptr, sc->ticket_key_aes_,
+  if (Thin_EVP_DecryptInit_ex(ectx, Thin_EVP_aes_128_cbc(), nullptr, sc->ticket_key_aes_,
                          iv) <= 0 ||
-      HMAC_Init_ex(hctx, sc->ticket_key_hmac_, sizeof(sc->ticket_key_hmac_),
-                   EVP_sha256(), nullptr) <= 0) {
+      Thin_HMAC_Init_ex(hctx, sc->ticket_key_hmac_, sizeof(sc->ticket_key_hmac_),
+                   Thin_EVP_sha256(), nullptr) <= 0) {
     return -1;
   }
   return 1;
@@ -1339,13 +1339,13 @@ void SecureContext::GetCertificate(const FunctionCallbackInfo<Value>& args) {
   if (cert == nullptr)
     return args.GetReturnValue().SetNull();
 
-  int size = i2d_X509(cert, nullptr);
+  int size = Thin_i2d_X509(cert, nullptr);
   Local<Object> buff;
   if (!Buffer::New(env, size).ToLocal(&buff))
     return;
   unsigned char* serialized = reinterpret_cast<unsigned char*>(
       Buffer::Data(buff));
-  i2d_X509(cert, &serialized);
+  Thin_i2d_X509(cert, &serialized);
 
   args.GetReturnValue().Set(buff);
 }
@@ -1354,19 +1354,19 @@ namespace {
 unsigned long AddCertsFromFile(  // NOLINT(runtime/int)
     X509_STORE* store,
     const char* file) {
-  ERR_clear_error();
+  Thin_ERR_clear_error();
   MarkPopErrorOnReturn mark_pop_error_on_return;
 
-  BIOPointer bio(BIO_new_file(file, "r"));
+  BIOPointer bio(Thin_BIO_new_file(file, "r"));
   if (!bio)
-    return ERR_get_error();
+    return Thin_ERR_get_error();
 
-  while (X509Pointer x509 = X509Pointer(PEM_read_bio_X509(
+  while (X509Pointer x509 = X509Pointer(Thin_PEM_read_bio_X509(
              bio.get(), nullptr, NoPasswordCallback, nullptr))) {
-    X509_STORE_add_cert(store, x509.get());
+    Thin_X509_STORE_add_cert(store, x509.get());
   }
 
-  unsigned long err = ERR_peek_error();  // NOLINT(runtime/int)
+  unsigned long err = Thin_ERR_peek_error();  // NOLINT(runtime/int)
   // Ignore error if its EOF/no start line found.
   if (ERR_GET_LIB(err) == ERR_LIB_PEM &&
       ERR_GET_REASON(err) == PEM_R_NO_START_LINE) {
@@ -1384,7 +1384,7 @@ void UseExtraCaCerts(const std::string& file) {
   X509_STORE* store = GetOrCreateRootCertStore();
   if (auto err = AddCertsFromFile(store, file.c_str())) {
     char buf[256];
-    ERR_error_string_n(err, buf, sizeof(buf));
+    Thin_ERR_error_string_n(err, buf, sizeof(buf));
     fprintf(stderr,
             "Warning: Ignoring extra certs from `%s`, load failed: %s\n",
             file.c_str(),
diff --git a/src/crypto/crypto_dh.cc b/src/crypto/crypto_dh.cc
index dd69323b80..37e81e0936 100644
--- a/src/crypto/crypto_dh.cc
+++ b/src/crypto/crypto_dh.cc
@@ -39,8 +39,8 @@ namespace {
 void ZeroPadDiffieHellmanSecret(size_t remainder_size,
                                 char* data,
                                 size_t length) {
-  // DH_size returns number of bytes in a prime number.
-  // DH_compute_key returns number of bytes in a remainder of exponent, which
+  // Thin_DH_size returns number of bytes in a prime number.
+  // Thin_DH_compute_key returns number of bytes in a remainder of exponent, which
   // may have less bytes than a prime number. Therefore add 0-padding to the
   // allocated buffer.
   const size_t prime_size = length;
@@ -132,8 +132,8 @@ void DiffieHellman::RegisterExternalReferences(
 }
 
 bool DiffieHellman::Init(int primeLength, int g) {
-  dh_.reset(DH_new());
-  if (!DH_generate_parameters_ex(dh_.get(), primeLength, g, nullptr))
+  dh_.reset(Thin_DH_new());
+  if (!Thin_DH_generate_parameters_ex(dh_.get(), primeLength, g, nullptr))
     return false;
   return VerifyContext();
 }
@@ -143,63 +143,63 @@ void DiffieHellman::MemoryInfo(MemoryTracker* tracker) const {
 }
 
 bool DiffieHellman::Init(BignumPointer&& bn_p, int g) {
-  dh_.reset(DH_new());
+  dh_.reset(Thin_DH_new());
   CHECK_GE(g, 2);
-  BignumPointer bn_g(BN_new());
-  return bn_g && BN_set_word(bn_g.get(), g) &&
-         DH_set0_pqg(dh_.get(), bn_p.release(), nullptr, bn_g.release()) &&
+  BignumPointer bn_g(Thin_BN_new());
+  return bn_g && Thin_BN_set_word(bn_g.get(), g) &&
+         Thin_DH_set0_pqg(dh_.get(), bn_p.release(), nullptr, bn_g.release()) &&
          VerifyContext();
 }
 
 bool DiffieHellman::Init(const char* p, int p_len, int g) {
-  dh_.reset(DH_new());
+  dh_.reset(Thin_DH_new());
   if (p_len <= 0) {
-    ERR_put_error(ERR_LIB_BN, BN_F_BN_GENERATE_PRIME_EX,
+    Thin_ERR_put_error(ERR_LIB_BN, BN_F_BN_GENERATE_PRIME_EX,
       BN_R_BITS_TOO_SMALL, __FILE__, __LINE__);
     return false;
   }
   if (g <= 1) {
-    ERR_put_error(ERR_LIB_DH, DH_F_DH_BUILTIN_GENPARAMS,
+    Thin_ERR_put_error(ERR_LIB_DH, DH_F_DH_BUILTIN_GENPARAMS,
       DH_R_BAD_GENERATOR, __FILE__, __LINE__);
     return false;
   }
   BIGNUM* bn_p =
-      BN_bin2bn(reinterpret_cast<const unsigned char*>(p), p_len, nullptr);
-  BIGNUM* bn_g = BN_new();
-  if (!BN_set_word(bn_g, g) ||
-      !DH_set0_pqg(dh_.get(), bn_p, nullptr, bn_g)) {
-    BN_free(bn_p);
-    BN_free(bn_g);
+      Thin_BN_bin2bn(reinterpret_cast<const unsigned char*>(p), p_len, nullptr);
+  BIGNUM* bn_g = Thin_BN_new();
+  if (!Thin_BN_set_word(bn_g, g) ||
+      !Thin_DH_set0_pqg(dh_.get(), bn_p, nullptr, bn_g)) {
+    Thin_BN_free(bn_p);
+    Thin_BN_free(bn_g);
     return false;
   }
   return VerifyContext();
 }
 
 bool DiffieHellman::Init(const char* p, int p_len, const char* g, int g_len) {
-  dh_.reset(DH_new());
+  dh_.reset(Thin_DH_new());
   if (p_len <= 0) {
-    ERR_put_error(ERR_LIB_BN, BN_F_BN_GENERATE_PRIME_EX,
+    Thin_ERR_put_error(ERR_LIB_BN, BN_F_BN_GENERATE_PRIME_EX,
       BN_R_BITS_TOO_SMALL, __FILE__, __LINE__);
     return false;
   }
   if (g_len <= 0) {
-    ERR_put_error(ERR_LIB_DH, DH_F_DH_BUILTIN_GENPARAMS,
+    Thin_ERR_put_error(ERR_LIB_DH, DH_F_DH_BUILTIN_GENPARAMS,
       DH_R_BAD_GENERATOR, __FILE__, __LINE__);
     return false;
   }
   BIGNUM* bn_g =
-      BN_bin2bn(reinterpret_cast<const unsigned char*>(g), g_len, nullptr);
-  if (BN_is_zero(bn_g) || BN_is_one(bn_g)) {
-    BN_free(bn_g);
-    ERR_put_error(ERR_LIB_DH, DH_F_DH_BUILTIN_GENPARAMS,
+      Thin_BN_bin2bn(reinterpret_cast<const unsigned char*>(g), g_len, nullptr);
+  if (Thin_BN_is_zero(bn_g) || Thin_BN_is_one(bn_g)) {
+    Thin_BN_free(bn_g);
+    Thin_ERR_put_error(ERR_LIB_DH, DH_F_DH_BUILTIN_GENPARAMS,
       DH_R_BAD_GENERATOR, __FILE__, __LINE__);
     return false;
   }
   BIGNUM* bn_p =
-      BN_bin2bn(reinterpret_cast<const unsigned char*>(p), p_len, nullptr);
-  if (!DH_set0_pqg(dh_.get(), bn_p, nullptr, bn_g)) {
-    BN_free(bn_p);
-    BN_free(bn_g);
+      Thin_BN_bin2bn(reinterpret_cast<const unsigned char*>(p), p_len, nullptr);
+  if (!Thin_DH_set0_pqg(dh_.get(), bn_p, nullptr, bn_g)) {
+    Thin_BN_free(bn_p);
+    Thin_BN_free(bn_g);
     return false;
   }
   return VerifyContext();
@@ -219,8 +219,8 @@ typedef BignumPointer (*StandardizedGroupInstantiator)();
 inline StandardizedGroupInstantiator FindDiffieHellmanGroup(const char* name) {
 #define V(n, p)                                                                \
   if (StringEqualNoCase(name, n)) return InstantiateStandardizedGroup<p>
-  V("modp1", BN_get_rfc2409_prime_768);
-  V("modp2", BN_get_rfc2409_prime_1024);
+  V("modp1", Thin_BN_get_rfc2409_prime_768);
+  V("modp2", Thin_BN_get_rfc2409_prime_1024);
   V("modp5", BN_get_rfc3526_prime_1536);
   V("modp14", BN_get_rfc3526_prime_2048);
   V("modp15", BN_get_rfc3526_prime_3072);
@@ -283,7 +283,7 @@ void DiffieHellman::New(const FunctionCallbackInfo<Value>& args) {
   }
 
   if (!initialized) {
-    return ThrowCryptoError(env, ERR_get_error(), "Initialization failed");
+    return ThrowCryptoError(env, Thin_ERR_get_error(), "Initialization failed");
   }
 }
 
@@ -294,23 +294,23 @@ void DiffieHellman::GenerateKeys(const FunctionCallbackInfo<Value>& args) {
   DiffieHellman* diffieHellman;
   ASSIGN_OR_RETURN_UNWRAP(&diffieHellman, args.Holder());
 
-  if (!DH_generate_key(diffieHellman->dh_.get())) {
-    return ThrowCryptoError(env, ERR_get_error(), "Key generation failed");
+  if (!Thin_DH_generate_key(diffieHellman->dh_.get())) {
+    return ThrowCryptoError(env, Thin_ERR_get_error(), "Key generation failed");
   }
 
   const BIGNUM* pub_key;
-  DH_get0_key(diffieHellman->dh_.get(), &pub_key, nullptr);
+  Thin_DH_get0_key(diffieHellman->dh_.get(), &pub_key, nullptr);
 
   std::unique_ptr<BackingStore> bs;
   {
-    const int size = BN_num_bytes(pub_key);
+    const int size = Thin_BN_num_bytes(pub_key);
     CHECK_GE(size, 0);
     NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
     bs = ArrayBuffer::NewBackingStore(env->isolate(), size);
   }
 
   CHECK_EQ(static_cast<int>(bs->ByteLength()),
-           BN_bn2binpad(pub_key,
+           Thin_BN_bn2binpad(pub_key,
                         static_cast<unsigned char*>(bs->Data()),
                         bs->ByteLength()));
 
@@ -335,14 +335,14 @@ void DiffieHellman::GetField(const FunctionCallbackInfo<Value>& args,
 
   std::unique_ptr<BackingStore> bs;
   {
-    const int size = BN_num_bytes(num);
+    const int size = Thin_BN_num_bytes(num);
     CHECK_GE(size, 0);
     NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
     bs = ArrayBuffer::NewBackingStore(env->isolate(), size);
   }
 
   CHECK_EQ(static_cast<int>(bs->ByteLength()),
-           BN_bn2binpad(num,
+           Thin_BN_bn2binpad(num,
                         static_cast<unsigned char*>(bs->Data()),
                         bs->ByteLength()));
 
@@ -355,7 +355,7 @@ void DiffieHellman::GetField(const FunctionCallbackInfo<Value>& args,
 void DiffieHellman::GetPrime(const FunctionCallbackInfo<Value>& args) {
   GetField(args, [](const DH* dh) -> const BIGNUM* {
     const BIGNUM* p;
-    DH_get0_pqg(dh, &p, nullptr, nullptr);
+    Thin_DH_get0_pqg(dh, &p, nullptr, nullptr);
     return p;
   }, "p is null");
 }
@@ -363,7 +363,7 @@ void DiffieHellman::GetPrime(const FunctionCallbackInfo<Value>& args) {
 void DiffieHellman::GetGenerator(const FunctionCallbackInfo<Value>& args) {
   GetField(args, [](const DH* dh) -> const BIGNUM* {
     const BIGNUM* g;
-    DH_get0_pqg(dh, nullptr, nullptr, &g);
+    Thin_DH_get0_pqg(dh, nullptr, nullptr, &g);
     return g;
   }, "g is null");
 }
@@ -371,7 +371,7 @@ void DiffieHellman::GetGenerator(const FunctionCallbackInfo<Value>& args) {
 void DiffieHellman::GetPublicKey(const FunctionCallbackInfo<Value>& args) {
   GetField(args, [](const DH* dh) -> const BIGNUM* {
     const BIGNUM* pub_key;
-    DH_get0_key(dh, &pub_key, nullptr);
+    Thin_DH_get0_key(dh, &pub_key, nullptr);
     return pub_key;
   }, "No public key - did you forget to generate one?");
 }
@@ -379,7 +379,7 @@ void DiffieHellman::GetPublicKey(const FunctionCallbackInfo<Value>& args) {
 void DiffieHellman::GetPrivateKey(const FunctionCallbackInfo<Value>& args) {
   GetField(args, [](const DH* dh) -> const BIGNUM* {
     const BIGNUM* priv_key;
-    DH_get0_key(dh, nullptr, &priv_key);
+    Thin_DH_get0_key(dh, nullptr, &priv_key);
     return priv_key;
   }, "No private key - did you forget to generate one?");
 }
@@ -396,16 +396,16 @@ void DiffieHellman::ComputeSecret(const FunctionCallbackInfo<Value>& args) {
   ArrayBufferOrViewContents<unsigned char> key_buf(args[0]);
   if (UNLIKELY(!key_buf.CheckSizeInt32()))
     return THROW_ERR_OUT_OF_RANGE(env, "secret is too big");
-  BignumPointer key(BN_bin2bn(key_buf.data(), key_buf.size(), nullptr));
+  BignumPointer key(Thin_BN_bin2bn(key_buf.data(), key_buf.size(), nullptr));
 
   std::unique_ptr<BackingStore> bs;
   {
     NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
     bs = ArrayBuffer::NewBackingStore(env->isolate(),
-                                      DH_size(diffieHellman->dh_.get()));
+                                      Thin_DH_size(diffieHellman->dh_.get()));
   }
 
-  int size = DH_compute_key(static_cast<unsigned char*>(bs->Data()),
+  int size = Thin_DH_compute_key(static_cast<unsigned char*>(bs->Data()),
                             key.get(),
                             diffieHellman->dh_.get());
 
@@ -413,12 +413,12 @@ void DiffieHellman::ComputeSecret(const FunctionCallbackInfo<Value>& args) {
     int checkResult;
     int checked;
 
-    checked = DH_check_pub_key(diffieHellman->dh_.get(),
+    checked = Thin_DH_check_pub_key(diffieHellman->dh_.get(),
                                key.get(),
                                &checkResult);
 
     if (!checked) {
-      return ThrowCryptoError(env, ERR_get_error(), "Invalid Key");
+      return ThrowCryptoError(env, Thin_ERR_get_error(), "Invalid Key");
     } else if (checkResult) {
       if (checkResult & DH_CHECK_PUBKEY_TOO_SMALL) {
         return THROW_ERR_CRYPTO_INVALID_KEYLEN(env,
@@ -452,20 +452,20 @@ void DiffieHellman::SetKey(const FunctionCallbackInfo<Value>& args,
   ArrayBufferOrViewContents<unsigned char> buf(args[0]);
   if (UNLIKELY(!buf.CheckSizeInt32()))
     return THROW_ERR_OUT_OF_RANGE(env, "buf is too big");
-  BIGNUM* num = BN_bin2bn(buf.data(), buf.size(), nullptr);
+  BIGNUM* num = Thin_BN_bin2bn(buf.data(), buf.size(), nullptr);
   CHECK_NOT_NULL(num);
   CHECK_EQ(1, set_field(dh->dh_.get(), num));
 }
 
 void DiffieHellman::SetPublicKey(const FunctionCallbackInfo<Value>& args) {
   SetKey(args,
-         [](DH* dh, BIGNUM* num) { return DH_set0_key(dh, num, nullptr); },
+         [](DH* dh, BIGNUM* num) { return Thin_DH_set0_key(dh, num, nullptr); },
          "Public key");
 }
 
 void DiffieHellman::SetPrivateKey(const FunctionCallbackInfo<Value>& args) {
   SetKey(args,
-         [](DH* dh, BIGNUM* num) { return DH_set0_key(dh, nullptr, num); },
+         [](DH* dh, BIGNUM* num) { return Thin_DH_set0_key(dh, nullptr, num); },
          "Private key");
 }
 
@@ -480,7 +480,7 @@ void DiffieHellman::VerifyErrorGetter(const FunctionCallbackInfo<Value>& args) {
 
 bool DiffieHellman::VerifyContext() {
   int codes;
-  if (!DH_check(dh_.get(), &codes))
+  if (!Thin_DH_check(dh_.get(), &codes))
     return false;
   verifyError_ = codes;
   return true;
@@ -533,7 +533,7 @@ Maybe<bool> DhKeyGenTraits::AdditionalConfig(
         return Nothing<bool>();
       }
       params->params.prime = BignumPointer(
-          BN_bin2bn(input.data(), input.size(), nullptr));
+          Thin_BN_bin2bn(input.data(), input.size(), nullptr));
     }
 
     CHECK(args[*offset + 1]->IsInt32());
@@ -548,35 +548,35 @@ EVPKeyCtxPointer DhKeyGenTraits::Setup(DhKeyPairGenConfig* params) {
   EVPKeyPointer key_params;
   if (BignumPointer* prime_fixed_value =
           std::get_if<BignumPointer>(&params->params.prime)) {
-    DHPointer dh(DH_new());
+    DHPointer dh(Thin_DH_new());
     if (!dh)
       return EVPKeyCtxPointer();
 
     BIGNUM* prime = prime_fixed_value->get();
-    BignumPointer bn_g(BN_new());
-    if (!BN_set_word(bn_g.get(), params->params.generator) ||
-        !DH_set0_pqg(dh.get(), prime, nullptr, bn_g.get())) {
+    BignumPointer bn_g(Thin_BN_new());
+    if (!Thin_BN_set_word(bn_g.get(), params->params.generator) ||
+        !Thin_DH_set0_pqg(dh.get(), prime, nullptr, bn_g.get())) {
       return EVPKeyCtxPointer();
     }
 
     prime_fixed_value->release();
     bn_g.release();
 
-    key_params = EVPKeyPointer(EVP_PKEY_new());
+    key_params = EVPKeyPointer(Thin_EVP_PKEY_new());
     CHECK(key_params);
-    CHECK_EQ(EVP_PKEY_assign_DH(key_params.get(), dh.release()), 1);
+    CHECK_EQ(Thin_EVP_PKEY_assign_DH(key_params.get(), dh.release()), 1);
   } else if (int* prime_size = std::get_if<int>(&params->params.prime)) {
-    EVPKeyCtxPointer param_ctx(EVP_PKEY_CTX_new_id(EVP_PKEY_DH, nullptr));
+    EVPKeyCtxPointer param_ctx(Thin_EVP_PKEY_CTX_new_id(EVP_PKEY_DH, nullptr));
     EVP_PKEY* raw_params = nullptr;
     if (!param_ctx ||
-        EVP_PKEY_paramgen_init(param_ctx.get()) <= 0 ||
-        EVP_PKEY_CTX_set_dh_paramgen_prime_len(
+        Thin_EVP_PKEY_paramgen_init(param_ctx.get()) <= 0 ||
+        Thin_EVP_PKEY_CTX_set_dh_paramgen_prime_len(
             param_ctx.get(),
             *prime_size) <= 0 ||
-        EVP_PKEY_CTX_set_dh_paramgen_generator(
+        Thin_EVP_PKEY_CTX_set_dh_paramgen_generator(
             param_ctx.get(),
             params->params.generator) <= 0 ||
-        EVP_PKEY_paramgen(param_ctx.get(), &raw_params) <= 0) {
+        Thin_EVP_PKEY_paramgen(param_ctx.get(), &raw_params) <= 0) {
       return EVPKeyCtxPointer();
     }
 
@@ -585,8 +585,8 @@ EVPKeyCtxPointer DhKeyGenTraits::Setup(DhKeyPairGenConfig* params) {
     UNREACHABLE();
   }
 
-  EVPKeyCtxPointer ctx(EVP_PKEY_CTX_new(key_params.get(), nullptr));
-  if (!ctx || EVP_PKEY_keygen_init(ctx.get()) <= 0)
+  EVPKeyCtxPointer ctx(Thin_EVP_PKEY_CTX_new(key_params.get(), nullptr));
+  if (!ctx || Thin_EVP_PKEY_keygen_init(ctx.get()) <= 0)
     return EVPKeyCtxPointer();
 
   return ctx;
@@ -626,15 +626,15 @@ ByteSource StatelessDiffieHellmanThreadsafe(
     const ManagedEVPPKey& their_key) {
   size_t out_size;
 
-  EVPKeyCtxPointer ctx(EVP_PKEY_CTX_new(our_key.get(), nullptr));
+  EVPKeyCtxPointer ctx(Thin_EVP_PKEY_CTX_new(our_key.get(), nullptr));
   if (!ctx ||
-      EVP_PKEY_derive_init(ctx.get()) <= 0 ||
-      EVP_PKEY_derive_set_peer(ctx.get(), their_key.get()) <= 0 ||
-      EVP_PKEY_derive(ctx.get(), nullptr, &out_size) <= 0)
+      Thin_EVP_PKEY_derive_init(ctx.get()) <= 0 ||
+      Thin_EVP_PKEY_derive_set_peer(ctx.get(), their_key.get()) <= 0 ||
+      Thin_EVP_PKEY_derive(ctx.get(), nullptr, &out_size) <= 0)
     return ByteSource();
 
   ByteSource::Builder out(out_size);
-  if (EVP_PKEY_derive(ctx.get(), out.data<unsigned char>(), &out_size) <= 0) {
+  if (Thin_EVP_PKEY_derive(ctx.get(), out.data<unsigned char>(), &out_size) <= 0) {
     return ByteSource();
   }
 
@@ -663,7 +663,7 @@ void DiffieHellman::Stateless(const FunctionCallbackInfo<Value>& args) {
               .ToLocal(&out)) return;
 
   if (Buffer::Length(out) == 0)
-    return ThrowCryptoError(env, ERR_get_error(), "diffieHellman failed");
+    return ThrowCryptoError(env, Thin_ERR_get_error(), "diffieHellman failed");
 
   args.GetReturnValue().Set(out);
 }
@@ -720,7 +720,7 @@ Maybe<bool> GetDhKeyDetail(
     std::shared_ptr<KeyObjectData> key,
     Local<Object> target) {
   ManagedEVPPKey pkey = key->GetAsymmetricKey();
-  CHECK_EQ(EVP_PKEY_id(pkey.get()), EVP_PKEY_DH);
+  CHECK_EQ(Thin_EVP_PKEY_id(pkey.get()), EVP_PKEY_DH);
   return Just(true);
 }
 
diff --git a/src/crypto/crypto_dsa.cc b/src/crypto/crypto_dsa.cc
index 6839283fbf..956aaf0b1c 100644
--- a/src/crypto/crypto_dsa.cc
+++ b/src/crypto/crypto_dsa.cc
@@ -15,7 +15,7 @@
 // EVP_PKEY_CTX_set_dsa_paramgen_q_bits was added in OpenSSL 1.1.1e.
 #if OPENSSL_VERSION_NUMBER < 0x1010105fL
 #define EVP_PKEY_CTX_set_dsa_paramgen_q_bits(ctx, qbits)                       \
-  EVP_PKEY_CTX_ctrl((ctx),                                                     \
+  Thin_EVP_PKEY_CTX_ctrl((ctx),                                                     \
                     EVP_PKEY_DSA,                                              \
                     EVP_PKEY_OP_PARAMGEN,                                      \
                     EVP_PKEY_CTRL_DSA_PARAMGEN_Q_BITS,                         \
@@ -38,12 +38,12 @@ using v8::Value;
 
 namespace crypto {
 EVPKeyCtxPointer DsaKeyGenTraits::Setup(DsaKeyPairGenConfig* params) {
-  EVPKeyCtxPointer param_ctx(EVP_PKEY_CTX_new_id(EVP_PKEY_DSA, nullptr));
+  EVPKeyCtxPointer param_ctx(Thin_EVP_PKEY_CTX_new_id(EVP_PKEY_DSA, nullptr));
   EVP_PKEY* raw_params = nullptr;
 
   if (!param_ctx ||
-      EVP_PKEY_paramgen_init(param_ctx.get()) <= 0 ||
-      EVP_PKEY_CTX_set_dsa_paramgen_bits(
+      Thin_EVP_PKEY_paramgen_init(param_ctx.get()) <= 0 ||
+      Thin_EVP_PKEY_CTX_set_dsa_paramgen_bits(
           param_ctx.get(),
           params->params.modulus_bits) <= 0) {
     return EVPKeyCtxPointer();
@@ -56,13 +56,13 @@ EVPKeyCtxPointer DsaKeyGenTraits::Setup(DsaKeyPairGenConfig* params) {
     }
   }
 
-  if (EVP_PKEY_paramgen(param_ctx.get(), &raw_params) <= 0)
+  if (Thin_EVP_PKEY_paramgen(param_ctx.get(), &raw_params) <= 0)
     return EVPKeyCtxPointer();
 
   EVPKeyPointer key_params(raw_params);
-  EVPKeyCtxPointer key_ctx(EVP_PKEY_CTX_new(key_params.get(), nullptr));
+  EVPKeyCtxPointer key_ctx(Thin_EVP_PKEY_CTX_new(key_params.get(), nullptr));
 
-  if (!key_ctx || EVP_PKEY_keygen_init(key_ctx.get()) <= 0)
+  if (!key_ctx || Thin_EVP_PKEY_keygen_init(key_ctx.get()) <= 0)
     return EVPKeyCtxPointer();
 
   return key_ctx;
@@ -139,16 +139,16 @@ Maybe<bool> GetDsaKeyDetail(
 
   ManagedEVPPKey m_pkey = key->GetAsymmetricKey();
   Mutex::ScopedLock lock(*m_pkey.mutex());
-  int type = EVP_PKEY_id(m_pkey.get());
+  int type = Thin_EVP_PKEY_id(m_pkey.get());
   CHECK(type == EVP_PKEY_DSA);
 
-  const DSA* dsa = EVP_PKEY_get0_DSA(m_pkey.get());
+  const DSA* dsa = Thin_EVP_PKEY_get0_DSA(m_pkey.get());
   CHECK_NOT_NULL(dsa);
 
-  DSA_get0_pqg(dsa, &p, &q, nullptr);
+  Thin_DSA_get0_pqg(dsa, &p, &q, nullptr);
 
-  size_t modulus_length = BN_num_bits(p);
-  size_t divisor_length = BN_num_bits(q);
+  size_t modulus_length = Thin_BN_num_bits(p);
+  size_t divisor_length = Thin_BN_num_bits(q);
 
   if (target
           ->Set(
diff --git a/src/crypto/crypto_ec.cc b/src/crypto/crypto_ec.cc
index 3ccea99fb2..64adc0b1a1 100644
--- a/src/crypto/crypto_ec.cc
+++ b/src/crypto/crypto_ec.cc
@@ -39,9 +39,9 @@ using v8::Value;
 namespace crypto {
 
 int GetCurveFromName(const char* name) {
-  int nid = EC_curve_nist2nid(name);
+  int nid = Thin_EC_curve_nist2nid(name);
   if (nid == NID_undef)
-    nid = OBJ_sn2nid(name);
+    nid = Thin_OBJ_sn2nid(name);
   return nid;
 }
 
@@ -108,13 +108,13 @@ void ECDH::RegisterExternalReferences(ExternalReferenceRegistry* registry) {
 
 void ECDH::GetCurves(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
-  const size_t num_curves = EC_get_builtin_curves(nullptr, 0);
+  const size_t num_curves = Thin_EC_get_builtin_curves(nullptr, 0);
   std::vector<EC_builtin_curve> curves(num_curves);
-  CHECK_EQ(EC_get_builtin_curves(curves.data(), num_curves), num_curves);
+  CHECK_EQ(Thin_EC_get_builtin_curves(curves.data(), num_curves), num_curves);
 
   std::vector<Local<Value>> arr(num_curves);
   std::transform(curves.begin(), curves.end(), arr.begin(), [env](auto& curve) {
-    return OneByteString(env->isolate(), OBJ_nid2sn(curve.nid));
+    return OneByteString(env->isolate(), Thin_OBJ_nid2sn(curve.nid));
   });
   args.GetReturnValue().Set(Array::New(env->isolate(), arr.data(), arr.size()));
 }
@@ -122,7 +122,7 @@ void ECDH::GetCurves(const FunctionCallbackInfo<Value>& args) {
 ECDH::ECDH(Environment* env, Local<Object> wrap, ECKeyPointer&& key)
     : BaseObject(env, wrap),
     key_(std::move(key)),
-    group_(EC_KEY_get0_group(key_.get())) {
+    group_(Thin_EC_KEY_get0_group(key_.get())) {
   MakeWeak();
   CHECK_NOT_NULL(group_);
 }
@@ -142,11 +142,11 @@ void ECDH::New(const FunctionCallbackInfo<Value>& args) {
   CHECK(args[0]->IsString());
   node::Utf8Value curve(env->isolate(), args[0]);
 
-  int nid = OBJ_sn2nid(*curve);
+  int nid = Thin_OBJ_sn2nid(*curve);
   if (nid == NID_undef)
     return THROW_ERR_CRYPTO_INVALID_CURVE(env);
 
-  ECKeyPointer key(EC_KEY_new_by_curve_name(nid));
+  ECKeyPointer key(Thin_EC_KEY_new_by_curve_name(nid));
   if (!key)
     return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
       "Failed to create key using named curve");
@@ -160,7 +160,7 @@ void ECDH::GenerateKeys(const FunctionCallbackInfo<Value>& args) {
   ECDH* ecdh;
   ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());
 
-  if (!EC_KEY_generate_key(ecdh->key_.get()))
+  if (!Thin_EC_KEY_generate_key(ecdh->key_.get()))
     return THROW_ERR_CRYPTO_OPERATION_FAILED(env, "Failed to generate key");
 }
 
@@ -169,7 +169,7 @@ ECPointPointer ECDH::BufferToPoint(Environment* env,
                                    Local<Value> buf) {
   int r;
 
-  ECPointPointer pub(EC_POINT_new(group));
+  ECPointPointer pub(Thin_EC_POINT_new(group));
   if (!pub) {
     THROW_ERR_CRYPTO_OPERATION_FAILED(env,
         "Failed to allocate EC_POINT for a public key");
@@ -181,7 +181,7 @@ ECPointPointer ECDH::BufferToPoint(Environment* env,
     THROW_ERR_OUT_OF_RANGE(env, "buffer is too big");
     return ECPointPointer();
   }
-  r = EC_POINT_oct2point(
+  r = Thin_EC_POINT_oct2point(
       group,
       pub.get(),
       input.data(),
@@ -221,12 +221,12 @@ void ECDH::ComputeSecret(const FunctionCallbackInfo<Value>& args) {
   {
     NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
     // NOTE: field_size is in bits
-    int field_size = EC_GROUP_get_degree(ecdh->group_);
+    int field_size = Thin_EC_GROUP_get_degree(ecdh->group_);
     size_t out_len = (field_size + 7) / 8;
     bs = ArrayBuffer::NewBackingStore(env->isolate(), out_len);
   }
 
-  if (!ECDH_compute_key(
+  if (!Thin_ECDH_compute_key(
           bs->Data(), bs->ByteLength(), pub.get(), ecdh->key_.get(), nullptr))
     return THROW_ERR_CRYPTO_OPERATION_FAILED(env, "Failed to compute ECDH key");
 
@@ -245,8 +245,8 @@ void ECDH::GetPublicKey(const FunctionCallbackInfo<Value>& args) {
   ECDH* ecdh;
   ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());
 
-  const EC_GROUP* group = EC_KEY_get0_group(ecdh->key_.get());
-  const EC_POINT* pub = EC_KEY_get0_public_key(ecdh->key_.get());
+  const EC_GROUP* group = Thin_EC_KEY_get0_group(ecdh->key_.get());
+  const EC_POINT* pub = Thin_EC_KEY_get0_public_key(ecdh->key_.get());
   if (pub == nullptr)
     return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
         "Failed to get ECDH public key");
@@ -268,7 +268,7 @@ void ECDH::GetPrivateKey(const FunctionCallbackInfo<Value>& args) {
   ECDH* ecdh;
   ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());
 
-  const BIGNUM* b = EC_KEY_get0_private_key(ecdh->key_.get());
+  const BIGNUM* b = Thin_EC_KEY_get0_private_key(ecdh->key_.get());
   if (b == nullptr)
     return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
         "Failed to get ECDH private key");
@@ -276,10 +276,10 @@ void ECDH::GetPrivateKey(const FunctionCallbackInfo<Value>& args) {
   std::unique_ptr<BackingStore> bs;
   {
     NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
-    bs = ArrayBuffer::NewBackingStore(env->isolate(), BN_num_bytes(b));
+    bs = ArrayBuffer::NewBackingStore(env->isolate(), Thin_BN_num_bytes(b));
   }
   CHECK_EQ(static_cast<int>(bs->ByteLength()),
-           BN_bn2binpad(
+           Thin_BN_bn2binpad(
                b, static_cast<unsigned char*>(bs->Data()), bs->ByteLength()));
 
   Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
@@ -298,7 +298,7 @@ void ECDH::SetPrivateKey(const FunctionCallbackInfo<Value>& args) {
   if (UNLIKELY(!priv_buffer.CheckSizeInt32()))
     return THROW_ERR_OUT_OF_RANGE(env, "key is too big");
 
-  BignumPointer priv(BN_bin2bn(
+  BignumPointer priv(Thin_BN_bin2bn(
       priv_buffer.data(), priv_buffer.size(), nullptr));
   if (!priv) {
     return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
@@ -310,10 +310,10 @@ void ECDH::SetPrivateKey(const FunctionCallbackInfo<Value>& args) {
         "Private key is not valid for specified curve.");
   }
 
-  ECKeyPointer new_key(EC_KEY_dup(ecdh->key_.get()));
+  ECKeyPointer new_key(Thin_EC_KEY_dup(ecdh->key_.get()));
   CHECK(new_key);
 
-  int result = EC_KEY_set_private_key(new_key.get(), priv.get());
+  int result = Thin_EC_KEY_set_private_key(new_key.get(), priv.get());
   priv.reset();
 
   if (!result) {
@@ -324,24 +324,24 @@ void ECDH::SetPrivateKey(const FunctionCallbackInfo<Value>& args) {
   MarkPopErrorOnReturn mark_pop_error_on_return;
   USE(&mark_pop_error_on_return);
 
-  const BIGNUM* priv_key = EC_KEY_get0_private_key(new_key.get());
+  const BIGNUM* priv_key = Thin_EC_KEY_get0_private_key(new_key.get());
   CHECK_NOT_NULL(priv_key);
 
-  ECPointPointer pub(EC_POINT_new(ecdh->group_));
+  ECPointPointer pub(Thin_EC_POINT_new(ecdh->group_));
   CHECK(pub);
 
-  if (!EC_POINT_mul(ecdh->group_, pub.get(), priv_key,
+  if (!Thin_EC_POINT_mul(ecdh->group_, pub.get(), priv_key,
                     nullptr, nullptr, nullptr)) {
     return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
         "Failed to generate ECDH public key");
   }
 
-  if (!EC_KEY_set_public_key(new_key.get(), pub.get()))
+  if (!Thin_EC_KEY_set_public_key(new_key.get(), pub.get()))
     return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
         "Failed to set generated public key");
 
   ecdh->key_ = std::move(new_key);
-  ecdh->group_ = EC_KEY_get0_group(ecdh->key_.get());
+  ecdh->group_ = Thin_EC_KEY_get0_group(ecdh->key_.get());
 }
 
 void ECDH::SetPublicKey(const FunctionCallbackInfo<Value>& args) {
@@ -363,7 +363,7 @@ void ECDH::SetPublicKey(const FunctionCallbackInfo<Value>& args) {
         "Failed to convert Buffer to EC_POINT");
   }
 
-  int r = EC_KEY_set_public_key(ecdh->key_.get(), pub.get());
+  int r = Thin_EC_KEY_set_public_key(ecdh->key_.get(), pub.get());
   if (!r) {
     return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
         "Failed to set EC_POINT as the public key");
@@ -375,19 +375,19 @@ bool ECDH::IsKeyValidForCurve(const BignumPointer& private_key) {
   CHECK(private_key);
   // Private keys must be in the range [1, n-1].
   // Ref: Section 3.2.1 - http://www.secg.org/sec1-v2.pdf
-  if (BN_cmp(private_key.get(), BN_value_one()) < 0) {
+  if (Thin_BN_cmp(private_key.get(), Thin_BN_value_one()) < 0) {
     return false;
   }
-  BignumPointer order(BN_new());
+  BignumPointer order(Thin_BN_new());
   CHECK(order);
-  return EC_GROUP_get_order(group_, order.get(), nullptr) &&
-         BN_cmp(private_key.get(), order.get()) < 0;
+  return Thin_EC_GROUP_get_order(group_, order.get(), nullptr) &&
+         Thin_BN_cmp(private_key.get(), order.get()) < 0;
 }
 
 bool ECDH::IsKeyPairValid() {
   MarkPopErrorOnReturn mark_pop_error_on_return;
   USE(&mark_pop_error_on_return);
-  return 1 == EC_KEY_check_key(key_.get());
+  return 1 == Thin_EC_KEY_check_key(key_.get());
 }
 
 // Convert the input public key to compressed, uncompressed, or hybrid formats.
@@ -406,12 +406,12 @@ void ECDH::ConvertKey(const FunctionCallbackInfo<Value>& args) {
 
   node::Utf8Value curve(env->isolate(), args[1]);
 
-  int nid = OBJ_sn2nid(*curve);
+  int nid = Thin_OBJ_sn2nid(*curve);
   if (nid == NID_undef)
     return THROW_ERR_CRYPTO_INVALID_CURVE(env);
 
   ECGroupPointer group(
-      EC_GROUP_new_by_curve_name(nid));
+      Thin_EC_GROUP_new_by_curve_name(nid));
   if (group == nullptr)
     return THROW_ERR_CRYPTO_OPERATION_FAILED(env, "Failed to get EC_GROUP");
 
@@ -495,20 +495,20 @@ bool ECDHBitsTraits::DeriveBits(Environment* env,
     case EVP_PKEY_X448: {
       EVPKeyCtxPointer ctx = nullptr;
       {
-        ctx.reset(EVP_PKEY_CTX_new(m_privkey.get(), nullptr));
+        ctx.reset(Thin_EVP_PKEY_CTX_new(m_privkey.get(), nullptr));
       }
       Mutex::ScopedLock pub_lock(*m_pubkey.mutex());
-      if (EVP_PKEY_derive_init(ctx.get()) <= 0 ||
-          EVP_PKEY_derive_set_peer(
+      if (Thin_EVP_PKEY_derive_init(ctx.get()) <= 0 ||
+          Thin_EVP_PKEY_derive_set_peer(
               ctx.get(),
               m_pubkey.get()) <= 0 ||
-          EVP_PKEY_derive(ctx.get(), nullptr, &len) <= 0) {
+          Thin_EVP_PKEY_derive(ctx.get(), nullptr, &len) <= 0) {
         return false;
       }
 
       ByteSource::Builder buf(len);
 
-      if (EVP_PKEY_derive(ctx.get(), buf.data<unsigned char>(), &len) <= 0) {
+      if (Thin_EVP_PKEY_derive(ctx.get(), buf.data<unsigned char>(), &len) <= 0) {
         return false;
       }
 
@@ -520,25 +520,25 @@ bool ECDHBitsTraits::DeriveBits(Environment* env,
       const EC_KEY* private_key;
       {
         Mutex::ScopedLock priv_lock(*m_privkey.mutex());
-        private_key = EVP_PKEY_get0_EC_KEY(m_privkey.get());
+        private_key = Thin_EVP_PKEY_get0_EC_KEY(m_privkey.get());
       }
 
       Mutex::ScopedLock pub_lock(*m_pubkey.mutex());
-      const EC_KEY* public_key = EVP_PKEY_get0_EC_KEY(m_pubkey.get());
+      const EC_KEY* public_key = Thin_EVP_PKEY_get0_EC_KEY(m_pubkey.get());
 
-      const EC_GROUP* group = EC_KEY_get0_group(private_key);
+      const EC_GROUP* group = Thin_EC_KEY_get0_group(private_key);
       if (group == nullptr)
         return false;
 
-      CHECK_EQ(EC_KEY_check_key(private_key), 1);
-      CHECK_EQ(EC_KEY_check_key(public_key), 1);
-      const EC_POINT* pub = EC_KEY_get0_public_key(public_key);
-      int field_size = EC_GROUP_get_degree(group);
+      CHECK_EQ(Thin_EC_KEY_check_key(private_key), 1);
+      CHECK_EQ(Thin_EC_KEY_check_key(public_key), 1);
+      const EC_POINT* pub = Thin_EC_KEY_get0_public_key(public_key);
+      int field_size = Thin_EC_GROUP_get_degree(group);
       len = (field_size + 7) / 8;
       ByteSource::Builder buf(len);
       CHECK_NOT_NULL(pub);
       CHECK_NOT_NULL(private_key);
-      if (ECDH_compute_key(buf.data<char>(), len, pub, private_key, nullptr) <=
+      if (Thin_ECDH_compute_key(buf.data<char>(), len, pub, private_key, nullptr) <=
           0) {
         return false;
       }
@@ -560,26 +560,26 @@ EVPKeyCtxPointer EcKeyGenTraits::Setup(EcKeyPairGenConfig* params) {
     case EVP_PKEY_X25519:
       // Fall through
     case EVP_PKEY_X448:
-      key_ctx.reset(EVP_PKEY_CTX_new_id(params->params.curve_nid, nullptr));
+      key_ctx.reset(Thin_EVP_PKEY_CTX_new_id(params->params.curve_nid, nullptr));
       break;
     default: {
-      EVPKeyCtxPointer param_ctx(EVP_PKEY_CTX_new_id(EVP_PKEY_EC, nullptr));
+      EVPKeyCtxPointer param_ctx(Thin_EVP_PKEY_CTX_new_id(EVP_PKEY_EC, nullptr));
       EVP_PKEY* raw_params = nullptr;
       if (!param_ctx ||
-          EVP_PKEY_paramgen_init(param_ctx.get()) <= 0 ||
-          EVP_PKEY_CTX_set_ec_paramgen_curve_nid(
+          Thin_EVP_PKEY_paramgen_init(param_ctx.get()) <= 0 ||
+          Thin_EVP_PKEY_CTX_set_ec_paramgen_curve_nid(
               param_ctx.get(), params->params.curve_nid) <= 0 ||
-          EVP_PKEY_CTX_set_ec_param_enc(
+          Thin_EVP_PKEY_CTX_set_ec_param_enc(
               param_ctx.get(), params->params.param_encoding) <= 0 ||
-          EVP_PKEY_paramgen(param_ctx.get(), &raw_params) <= 0) {
+          Thin_EVP_PKEY_paramgen(param_ctx.get(), &raw_params) <= 0) {
         return EVPKeyCtxPointer();
       }
       EVPKeyPointer key_params(raw_params);
-      key_ctx.reset(EVP_PKEY_CTX_new(key_params.get(), nullptr));
+      key_ctx.reset(Thin_EVP_PKEY_CTX_new(key_params.get(), nullptr));
     }
   }
 
-  if (key_ctx && EVP_PKEY_keygen_init(key_ctx.get()) <= 0)
+  if (key_ctx && Thin_EVP_PKEY_keygen_init(key_ctx.get()) <= 0)
     key_ctx.reset();
 
   return key_ctx;
@@ -632,7 +632,7 @@ WebCryptoKeyExportStatus EC_Raw_Export(
   CHECK(m_pkey);
   Mutex::ScopedLock lock(*m_pkey.mutex());
 
-  const EC_KEY* ec_key = EVP_PKEY_get0_EC_KEY(m_pkey.get());
+  const EC_KEY* ec_key = Thin_EVP_PKEY_get0_EC_KEY(m_pkey.get());
 
   size_t len = 0;
 
@@ -641,10 +641,10 @@ WebCryptoKeyExportStatus EC_Raw_Export(
     export_fn fn = nullptr;
     switch (key_data->GetKeyType()) {
       case kKeyTypePrivate:
-        fn = EVP_PKEY_get_raw_private_key;
+        fn = Thin_EVP_PKEY_get_raw_private_key;
         break;
       case kKeyTypePublic:
-        fn = EVP_PKEY_get_raw_public_key;
+        fn = Thin_EVP_PKEY_get_raw_public_key;
         break;
       case kKeyTypeSecret:
         UNREACHABLE();
@@ -660,16 +660,16 @@ WebCryptoKeyExportStatus EC_Raw_Export(
   } else {
     if (key_data->GetKeyType() != kKeyTypePublic)
       return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
-    const EC_GROUP* group = EC_KEY_get0_group(ec_key);
-    const EC_POINT* point = EC_KEY_get0_public_key(ec_key);
+    const EC_GROUP* group = Thin_EC_KEY_get0_group(ec_key);
+    const EC_POINT* point = Thin_EC_KEY_get0_public_key(ec_key);
     point_conversion_form_t form = POINT_CONVERSION_UNCOMPRESSED;
 
     // Get the allocated data size...
-    len = EC_POINT_point2oct(group, point, form, nullptr, 0, nullptr);
+    len = Thin_EC_POINT_point2oct(group, point, form, nullptr, 0, nullptr);
     if (len == 0)
       return WebCryptoKeyExportStatus::FAILED;
     ByteSource::Builder data(len);
-    size_t check_len = EC_POINT_point2oct(
+    size_t check_len = Thin_EC_POINT_point2oct(
         group, point, form, data.data<unsigned char>(), len, nullptr);
     if (check_len == 0)
       return WebCryptoKeyExportStatus::FAILED;
@@ -708,41 +708,41 @@ WebCryptoKeyExportStatus ECKeyExportTraits::DoExport(
         return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
 
       ManagedEVPPKey m_pkey = key_data->GetAsymmetricKey();
-      if (EVP_PKEY_id(m_pkey.get()) != EVP_PKEY_EC) {
+      if (Thin_EVP_PKEY_id(m_pkey.get()) != EVP_PKEY_EC) {
         return PKEY_SPKI_Export(key_data.get(), out);
       } else {
         // Ensure exported key is in uncompressed point format.
-        // The temporary EC key is so we can have i2d_PUBKEY_bio() write out
+        // The temporary EC key is so we can have Thin_i2d_PUBKEY_bio() write out
         // the header but it is a somewhat silly hoop to jump through because
         // the header is for all practical purposes a static 26 byte sequence
         // where only the second byte changes.
         Mutex::ScopedLock lock(*m_pkey.mutex());
-        const EC_KEY* ec_key = EVP_PKEY_get0_EC_KEY(m_pkey.get());
-        const EC_GROUP* group = EC_KEY_get0_group(ec_key);
-        const EC_POINT* point = EC_KEY_get0_public_key(ec_key);
+        const EC_KEY* ec_key = Thin_EVP_PKEY_get0_EC_KEY(m_pkey.get());
+        const EC_GROUP* group = Thin_EC_KEY_get0_group(ec_key);
+        const EC_POINT* point = Thin_EC_KEY_get0_public_key(ec_key);
         const point_conversion_form_t form = POINT_CONVERSION_UNCOMPRESSED;
         const size_t need =
-            EC_POINT_point2oct(group, point, form, nullptr, 0, nullptr);
+            Thin_EC_POINT_point2oct(group, point, form, nullptr, 0, nullptr);
         if (need == 0) return WebCryptoKeyExportStatus::FAILED;
         ByteSource::Builder data(need);
-        const size_t have = EC_POINT_point2oct(
+        const size_t have = Thin_EC_POINT_point2oct(
             group, point, form, data.data<unsigned char>(), need, nullptr);
         if (have == 0) return WebCryptoKeyExportStatus::FAILED;
         ECKeyPointer ec(EC_KEY_new());
         CHECK_EQ(1, EC_KEY_set_group(ec.get(), group));
-        ECPointPointer uncompressed(EC_POINT_new(group));
+        ECPointPointer uncompressed(Thin_EC_POINT_new(group));
         CHECK_EQ(1,
-                 EC_POINT_oct2point(group,
+                 Thin_EC_POINT_oct2point(group,
                                     uncompressed.get(),
                                     data.data<unsigned char>(),
                                     data.size(),
                                     nullptr));
-        CHECK_EQ(1, EC_KEY_set_public_key(ec.get(), uncompressed.get()));
-        EVPKeyPointer pkey(EVP_PKEY_new());
-        CHECK_EQ(1, EVP_PKEY_set1_EC_KEY(pkey.get(), ec.get()));
-        BIOPointer bio(BIO_new(BIO_s_mem()));
+        CHECK_EQ(1, Thin_EC_KEY_set_public_key(ec.get(), uncompressed.get()));
+        EVPKeyPointer pkey(Thin_EVP_PKEY_new());
+        CHECK_EQ(1, Thin_EVP_PKEY_set1_EC_KEY(pkey.get(), ec.get()));
+        BIOPointer bio(Thin_BIO_new(Thin_BIO_s_mem()));
         CHECK(bio);
-        if (!i2d_PUBKEY_bio(bio.get(), pkey.get()))
+        if (!Thin_i2d_PUBKEY_bio(bio.get(), pkey.get()))
           return WebCryptoKeyExportStatus::FAILED;
         *out = ByteSource::FromBIO(bio);
         return WebCryptoKeyExportStatus::OK;
@@ -759,23 +759,23 @@ Maybe<void> ExportJWKEcKey(
     Local<Object> target) {
   ManagedEVPPKey m_pkey = key->GetAsymmetricKey();
   Mutex::ScopedLock lock(*m_pkey.mutex());
-  CHECK_EQ(EVP_PKEY_id(m_pkey.get()), EVP_PKEY_EC);
+  CHECK_EQ(Thin_EVP_PKEY_id(m_pkey.get()), EVP_PKEY_EC);
 
-  const EC_KEY* ec = EVP_PKEY_get0_EC_KEY(m_pkey.get());
+  const EC_KEY* ec = Thin_EVP_PKEY_get0_EC_KEY(m_pkey.get());
   CHECK_NOT_NULL(ec);
 
-  const EC_POINT* pub = EC_KEY_get0_public_key(ec);
-  const EC_GROUP* group = EC_KEY_get0_group(ec);
+  const EC_POINT* pub = Thin_EC_KEY_get0_public_key(ec);
+  const EC_GROUP* group = Thin_EC_KEY_get0_group(ec);
 
-  int degree_bits = EC_GROUP_get_degree(group);
+  int degree_bits = Thin_EC_GROUP_get_degree(group);
   int degree_bytes =
     (degree_bits / CHAR_BIT) + (7 + (degree_bits % CHAR_BIT)) / 8;
 
-  BignumPointer x(BN_new());
-  BignumPointer y(BN_new());
+  BignumPointer x(Thin_BN_new());
+  BignumPointer y(Thin_BN_new());
 
-  if (!EC_POINT_get_affine_coordinates(group, pub, x.get(), y.get(), nullptr)) {
-    ThrowCryptoError(env, ERR_get_error(),
+  if (!Thin_EC_POINT_get_affine_coordinates(group, pub, x.get(), y.get(), nullptr)) {
+    ThrowCryptoError(env, Thin_ERR_get_error(),
                      "Failed to get elliptic-curve point coordinates");
     return Nothing<void>();
   }
@@ -803,7 +803,7 @@ Maybe<void> ExportJWKEcKey(
   }
 
   Local<String> crv_name;
-  const int nid = EC_GROUP_get_curve_name(group);
+  const int nid = Thin_EC_GROUP_get_curve_name(group);
   switch (nid) {
     case NID_X9_62_prime256v1:
       crv_name = OneByteString(env->isolate(), "P-256");
@@ -819,7 +819,7 @@ Maybe<void> ExportJWKEcKey(
       break;
     default: {
       THROW_ERR_CRYPTO_JWK_UNSUPPORTED_CURVE(
-          env, "Unsupported JWK EC curve: %s.", OBJ_nid2sn(nid));
+          env, "Unsupported JWK EC curve: %s.", Thin_OBJ_nid2sn(nid));
       return Nothing<void>();
     }
   }
@@ -831,7 +831,7 @@ Maybe<void> ExportJWKEcKey(
   }
 
   if (key->GetKeyType() == kKeyTypePrivate) {
-    const BIGNUM* pvt = EC_KEY_get0_private_key(ec);
+    const BIGNUM* pvt = Thin_EC_KEY_get0_private_key(ec);
     return SetEncodedValue(
       env,
       target,
@@ -851,7 +851,7 @@ Maybe<bool> ExportJWKEdKey(
   Mutex::ScopedLock lock(*pkey.mutex());
 
   const char* curve = nullptr;
-  switch (EVP_PKEY_id(pkey.get())) {
+  switch (Thin_EVP_PKEY_id(pkey.get())) {
     case EVP_PKEY_ED25519:
       curve = "Ed25519";
       break;
@@ -878,13 +878,13 @@ Maybe<bool> ExportJWKEdKey(
   Local<Value> encoded;
   Local<Value> error;
 
-  if (!EVP_PKEY_get_raw_public_key(pkey.get(), nullptr, &len))
+  if (!Thin_EVP_PKEY_get_raw_public_key(pkey.get(), nullptr, &len))
     return Nothing<bool>();
 
   ByteSource::Builder out(len);
 
   if (key->GetKeyType() == kKeyTypePrivate) {
-    if (!EVP_PKEY_get_raw_private_key(
+    if (!Thin_EVP_PKEY_get_raw_private_key(
             pkey.get(), out.data<unsigned char>(), &len) ||
         !StringBytes::Encode(
              env->isolate(), out.data<const char>(), len, BASE64URL, &error)
@@ -896,7 +896,7 @@ Maybe<bool> ExportJWKEdKey(
     }
   }
 
-  if (!EVP_PKEY_get_raw_public_key(
+  if (!Thin_EVP_PKEY_get_raw_public_key(
           pkey.get(), out.data<unsigned char>(), &len) ||
       !StringBytes::Encode(
            env->isolate(), out.data<const char>(), len, BASE64URL, &error)
@@ -950,7 +950,7 @@ std::shared_ptr<KeyObjectData> ImportJWKEcKey(
 
   KeyType type = d_value->IsString() ? kKeyTypePrivate : kKeyTypePublic;
 
-  ECKeyPointer ec(EC_KEY_new_by_curve_name(nid));
+  ECKeyPointer ec(Thin_EC_KEY_new_by_curve_name(nid));
   if (!ec) {
     THROW_ERR_CRYPTO_INVALID_JWK(env, "Invalid JWK EC key");
     return std::shared_ptr<KeyObjectData>();
@@ -959,7 +959,7 @@ std::shared_ptr<KeyObjectData> ImportJWKEcKey(
   ByteSource x = ByteSource::FromEncodedString(env, x_value.As<String>());
   ByteSource y = ByteSource::FromEncodedString(env, y_value.As<String>());
 
-  if (!EC_KEY_set_public_key_affine_coordinates(
+  if (!Thin_EC_KEY_set_public_key_affine_coordinates(
           ec.get(),
           x.ToBN().get(),
           y.ToBN().get())) {
@@ -969,14 +969,14 @@ std::shared_ptr<KeyObjectData> ImportJWKEcKey(
 
   if (type == kKeyTypePrivate) {
     ByteSource d = ByteSource::FromEncodedString(env, d_value.As<String>());
-    if (!EC_KEY_set_private_key(ec.get(), d.ToBN().get())) {
+    if (!Thin_EC_KEY_set_private_key(ec.get(), d.ToBN().get())) {
       THROW_ERR_CRYPTO_INVALID_JWK(env, "Invalid JWK EC key");
       return std::shared_ptr<KeyObjectData>();
     }
   }
 
-  EVPKeyPointer pkey(EVP_PKEY_new());
-  CHECK_EQ(EVP_PKEY_set1_EC_KEY(pkey.get(), ec.get()), 1);
+  EVPKeyPointer pkey(Thin_EVP_PKEY_new());
+  CHECK_EQ(Thin_EVP_PKEY_set1_EC_KEY(pkey.get(), ec.get()), 1);
 
   return KeyObjectData::CreateAsymmetric(type, ManagedEVPPKey(std::move(pkey)));
 }
@@ -987,18 +987,18 @@ Maybe<bool> GetEcKeyDetail(
     Local<Object> target) {
   ManagedEVPPKey m_pkey = key->GetAsymmetricKey();
   Mutex::ScopedLock lock(*m_pkey.mutex());
-  CHECK_EQ(EVP_PKEY_id(m_pkey.get()), EVP_PKEY_EC);
+  CHECK_EQ(Thin_EVP_PKEY_id(m_pkey.get()), EVP_PKEY_EC);
 
-  const EC_KEY* ec = EVP_PKEY_get0_EC_KEY(m_pkey.get());
+  const EC_KEY* ec = Thin_EVP_PKEY_get0_EC_KEY(m_pkey.get());
   CHECK_NOT_NULL(ec);
 
-  const EC_GROUP* group = EC_KEY_get0_group(ec);
-  int nid = EC_GROUP_get_curve_name(group);
+  const EC_GROUP* group = Thin_EC_KEY_get0_group(ec);
+  int nid = Thin_EC_GROUP_get_curve_name(group);
 
   return target->Set(
       env->context(),
       env->named_curve_string(),
-      OneByteString(env->isolate(), OBJ_nid2sn(nid)));
+      OneByteString(env->isolate(), Thin_OBJ_nid2sn(nid)));
 }
 
 // WebCrypto requires a different format for ECDSA signatures than
@@ -1007,12 +1007,12 @@ Maybe<bool> GetEcKeyDetail(
 // https://github.com/chromium/chromium/blob/7af6cfd/components/webcrypto/algorithms/ecdsa.cc
 
 size_t GroupOrderSize(const ManagedEVPPKey& key) {
-  const EC_KEY* ec = EVP_PKEY_get0_EC_KEY(key.get());
+  const EC_KEY* ec = Thin_EVP_PKEY_get0_EC_KEY(key.get());
   CHECK_NOT_NULL(ec);
-  const EC_GROUP* group = EC_KEY_get0_group(ec);
-  BignumPointer order(BN_new());
-  CHECK(EC_GROUP_get_order(group, order.get(), nullptr));
-  return BN_num_bytes(order.get());
+  const EC_GROUP* group = Thin_EC_KEY_get0_group(ec);
+  BignumPointer order(Thin_BN_new());
+  CHECK(Thin_EC_GROUP_get_order(group, order.get(), nullptr));
+  return Thin_BN_num_bytes(order.get());
 }
 }  // namespace crypto
 }  // namespace node
diff --git a/src/crypto/crypto_hash.cc b/src/crypto/crypto_hash.cc
index 200603a85e..a89db5fd45 100644
--- a/src/crypto/crypto_hash.cc
+++ b/src/crypto/crypto_hash.cc
@@ -38,13 +38,13 @@ void Hash::GetHashes(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   MarkPopErrorOnReturn mark_pop_error_on_return;
   CipherPushContext ctx(env);
-  EVP_MD_do_all_sorted(
+  Thin_EVP_MD_do_all_sorted(
 #if OPENSSL_VERSION_MAJOR >= 3
     array_push_back<EVP_MD,
-                    EVP_MD_fetch,
-                    EVP_MD_free,
-                    EVP_get_digestbyname,
-                    EVP_MD_get0_name>,
+                    Thin_EVP_MD_fetch,
+                    Thin_EVP_MD_free,
+                    Thin_EVP_get_digestbyname,
+                    Thin_EVP_MD_get0_name>,
 #else
     array_push_back<EVP_MD>,
 #endif
@@ -88,10 +88,10 @@ void Hash::New(const FunctionCallbackInfo<Value>& args) {
 
   if (args[0]->IsObject()) {
     ASSIGN_OR_RETURN_UNWRAP(&orig, args[0].As<Object>());
-    md = EVP_MD_CTX_md(orig->mdctx_.get());
+    md = Thin_EVP_MD_CTX_md(orig->mdctx_.get());
   } else {
     const Utf8Value hash_type(env->isolate(), args[0]);
-    md = EVP_get_digestbyname(*hash_type);
+    md = Thin_EVP_get_digestbyname(*hash_type);
   }
 
   Maybe<unsigned int> xof_md_len = Nothing<unsigned int>();
@@ -102,29 +102,29 @@ void Hash::New(const FunctionCallbackInfo<Value>& args) {
 
   Hash* hash = new Hash(env, args.This());
   if (md == nullptr || !hash->HashInit(md, xof_md_len)) {
-    return ThrowCryptoError(env, ERR_get_error(),
+    return ThrowCryptoError(env, Thin_ERR_get_error(),
                             "Digest method not supported");
   }
 
   if (orig != nullptr &&
-      0 >= EVP_MD_CTX_copy(hash->mdctx_.get(), orig->mdctx_.get())) {
-    return ThrowCryptoError(env, ERR_get_error(), "Digest copy error");
+      0 >= Thin_EVP_MD_CTX_copy(hash->mdctx_.get(), orig->mdctx_.get())) {
+    return ThrowCryptoError(env, Thin_ERR_get_error(), "Digest copy error");
   }
 }
 
 bool Hash::HashInit(const EVP_MD* md, Maybe<unsigned int> xof_md_len) {
-  mdctx_.reset(EVP_MD_CTX_new());
-  if (!mdctx_ || EVP_DigestInit_ex(mdctx_.get(), md, nullptr) <= 0) {
+  mdctx_.reset(Thin_EVP_MD_CTX_new());
+  if (!mdctx_ || Thin_EVP_DigestInit_ex(mdctx_.get(), md, nullptr) <= 0) {
     mdctx_.reset();
     return false;
   }
 
-  md_len_ = EVP_MD_size(md);
+  md_len_ = Thin_EVP_MD_size(md);
   if (xof_md_len.IsJust() && xof_md_len.FromJust() != md_len_) {
     // This is a little hack to cause createHash to fail when an incorrect
     // hashSize option was passed for a non-XOF hash function.
-    if ((EVP_MD_flags(md) & EVP_MD_FLAG_XOF) == 0) {
-      EVPerr(EVP_F_EVP_DIGESTFINALXOF, EVP_R_NOT_XOF_OR_INVALID_LENGTH);
+    if ((Thin_EVP_MD_flags(md) & EVP_MD_FLAG_XOF) == 0) {
+      Thin_EVPerr(EVP_F_EVP_DIGESTFINALXOF, EVP_R_NOT_XOF_OR_INVALID_LENGTH);
       return false;
     }
     md_len_ = xof_md_len.FromJust();
@@ -136,7 +136,7 @@ bool Hash::HashInit(const EVP_MD* md, Maybe<unsigned int> xof_md_len) {
 bool Hash::HashUpdate(const char* data, size_t len) {
   if (!mdctx_)
     return false;
-  return EVP_DigestUpdate(mdctx_.get(), data, len) == 1;
+  return Thin_EVP_DigestUpdate(mdctx_.get(), data, len) == 1;
 }
 
 void Hash::HashUpdate(const FunctionCallbackInfo<Value>& args) {
@@ -170,27 +170,27 @@ void Hash::HashDigest(const FunctionCallbackInfo<Value>& args) {
 
   if (!hash->digest_ && len > 0) {
     // Some hash algorithms such as SHA3 do not support calling
-    // EVP_DigestFinal_ex more than once, however, Hash._flush
+    // Thin_EVP_DigestFinal_ex more than once, however, Hash._flush
     // and Hash.digest can both be used to retrieve the digest,
     // so we need to cache it.
     // See https://github.com/nodejs/node/issues/28245.
 
     ByteSource::Builder digest(len);
 
-    size_t default_len = EVP_MD_CTX_size(hash->mdctx_.get());
+    size_t default_len = Thin_EVP_MD_CTX_size(hash->mdctx_.get());
     int ret;
     if (len == default_len) {
-      ret = EVP_DigestFinal_ex(
+      ret = Thin_EVP_DigestFinal_ex(
           hash->mdctx_.get(), digest.data<unsigned char>(), &len);
       // The output length should always equal hash->md_len_
       CHECK_EQ(len, hash->md_len_);
     } else {
-      ret = EVP_DigestFinalXOF(
+      ret = Thin_EVP_DigestFinalXOF(
           hash->mdctx_.get(), digest.data<unsigned char>(), len);
     }
 
     if (ret != 1)
-      return ThrowCryptoError(env, ERR_get_error());
+      return ThrowCryptoError(env, Thin_ERR_get_error());
 
     hash->digest_ = std::move(digest).release();
   }
@@ -244,7 +244,7 @@ Maybe<bool> HashTraits::AdditionalConfig(
 
   CHECK(args[offset]->IsString());  // Hash algorithm
   Utf8Value digest(env->isolate(), args[offset]);
-  params->digest = EVP_get_digestbyname(*digest);
+  params->digest = Thin_EVP_get_digestbyname(*digest);
   if (UNLIKELY(params->digest == nullptr)) {
     THROW_ERR_CRYPTO_INVALID_DIGEST(env, "Invalid digest: %s", *digest);
     return Nothing<bool>();
@@ -259,7 +259,7 @@ Maybe<bool> HashTraits::AdditionalConfig(
       ? data.ToCopy()
       : data.ToByteSource();
 
-  unsigned int expected = EVP_MD_size(params->digest);
+  unsigned int expected = Thin_EVP_MD_size(params->digest);
   params->length = expected;
   if (UNLIKELY(args[offset + 2]->IsUint32())) {
     // length is expressed in terms of bits
@@ -267,7 +267,7 @@ Maybe<bool> HashTraits::AdditionalConfig(
         static_cast<uint32_t>(args[offset + 2]
             .As<Uint32>()->Value()) / CHAR_BIT;
     if (params->length != expected) {
-      if ((EVP_MD_flags(params->digest) & EVP_MD_FLAG_XOF) == 0) {
+      if ((Thin_EVP_MD_flags(params->digest) & EVP_MD_FLAG_XOF) == 0) {
         THROW_ERR_CRYPTO_INVALID_DIGEST(env, "Digest method not supported");
         return Nothing<bool>();
       }
@@ -281,11 +281,11 @@ bool HashTraits::DeriveBits(
     Environment* env,
     const HashConfig& params,
     ByteSource* out) {
-  EVPMDPointer ctx(EVP_MD_CTX_new());
+  EVPMDPointer ctx(Thin_EVP_MD_CTX_new());
 
   if (UNLIKELY(!ctx ||
-               EVP_DigestInit_ex(ctx.get(), params.digest, nullptr) <= 0 ||
-               EVP_DigestUpdate(
+               Thin_EVP_DigestInit_ex(ctx.get(), params.digest, nullptr) <= 0 ||
+               Thin_EVP_DigestUpdate(
                    ctx.get(), params.in.data<char>(), params.in.size()) <= 0)) {
     return false;
   }
@@ -294,12 +294,12 @@ bool HashTraits::DeriveBits(
     unsigned int length = params.length;
     ByteSource::Builder buf(length);
 
-    size_t expected = EVP_MD_CTX_size(ctx.get());
+    size_t expected = Thin_EVP_MD_CTX_size(ctx.get());
 
     int ret =
         (length == expected)
-            ? EVP_DigestFinal_ex(ctx.get(), buf.data<unsigned char>(), &length)
-            : EVP_DigestFinalXOF(ctx.get(), buf.data<unsigned char>(), length);
+            ? Thin_EVP_DigestFinal_ex(ctx.get(), buf.data<unsigned char>(), &length)
+            : Thin_EVP_DigestFinalXOF(ctx.get(), buf.data<unsigned char>(), length);
 
     if (UNLIKELY(ret != 1))
       return false;
diff --git a/src/crypto/crypto_hkdf.cc b/src/crypto/crypto_hkdf.cc
index 7663dd6937..06b4b1e986 100644
--- a/src/crypto/crypto_hkdf.cc
+++ b/src/crypto/crypto_hkdf.cc
@@ -56,7 +56,7 @@ Maybe<bool> HKDFTraits::AdditionalConfig(
   CHECK(args[offset + 4]->IsUint32());  // Length
 
   Utf8Value hash(env->isolate(), args[offset]);
-  params->digest = EVP_get_digestbyname(*hash);
+  params->digest = Thin_EVP_get_digestbyname(*hash);
   if (params->digest == nullptr) {
     THROW_ERR_CRYPTO_INVALID_DIGEST(env, "Invalid digest: %s", *hash);
     return Nothing<bool>();
@@ -91,7 +91,7 @@ Maybe<bool> HKDFTraits::AdditionalConfig(
   // output of the hash function. 255 is a hard limit because HKDF appends an
   // 8-bit counter to each HMAC'd message, starting at 1.
   constexpr size_t kMaxDigestMultiplier = 255;
-  size_t max_length = EVP_MD_size(params->digest) * kMaxDigestMultiplier;
+  size_t max_length = Thin_EVP_MD_size(params->digest) * kMaxDigestMultiplier;
   if (params->length > max_length) {
     THROW_ERR_CRYPTO_INVALID_KEYLEN(env);
     return Nothing<bool>();
@@ -105,10 +105,10 @@ bool HKDFTraits::DeriveBits(
     const HKDFConfig& params,
     ByteSource* out) {
   EVPKeyCtxPointer ctx =
-      EVPKeyCtxPointer(EVP_PKEY_CTX_new_id(EVP_PKEY_HKDF, nullptr));
-  if (!ctx || !EVP_PKEY_derive_init(ctx.get()) ||
-      !EVP_PKEY_CTX_set_hkdf_md(ctx.get(), params.digest) ||
-      !EVP_PKEY_CTX_add1_hkdf_info(
+      EVPKeyCtxPointer(Thin_EVP_PKEY_CTX_new_id(EVP_PKEY_HKDF, nullptr));
+  if (!ctx || !Thin_EVP_PKEY_derive_init(ctx.get()) ||
+      !Thin_EVP_PKEY_CTX_set_hkdf_md(ctx.get(), params.digest) ||
+      !Thin_EVP_PKEY_CTX_add1_hkdf_info(
           ctx.get(), params.info.data<unsigned char>(), params.info.size())) {
     return false;
   }
@@ -122,11 +122,11 @@ bool HKDFTraits::DeriveBits(
     salt = {params.salt.data<char>(), params.salt.size()};
   } else {
     static const char default_salt[EVP_MAX_MD_SIZE] = {0};
-    salt = {default_salt, static_cast<unsigned>(EVP_MD_size(params.digest))};
+    salt = {default_salt, static_cast<unsigned>(Thin_EVP_MD_size(params.digest))};
   }
 
   // We do not use EVP_PKEY_HKDEF_MODE_EXTRACT_AND_EXPAND and instead implement
-  // the extraction step ourselves because EVP_PKEY_derive does not handle
+  // the extraction step ourselves because Thin_EVP_PKEY_derive does not handle
   // zero-length keys, which are required for Web Crypto.
   unsigned char pseudorandom_key[EVP_MAX_MD_SIZE];
   unsigned int prk_len = sizeof(pseudorandom_key);
@@ -140,14 +140,14 @@ bool HKDFTraits::DeriveBits(
           &prk_len) == nullptr) {
     return false;
   }
-  if (!EVP_PKEY_CTX_hkdf_mode(ctx.get(), EVP_PKEY_HKDEF_MODE_EXPAND_ONLY) ||
-      !EVP_PKEY_CTX_set1_hkdf_key(ctx.get(), pseudorandom_key, prk_len)) {
+  if (!Thin_EVP_PKEY_CTX_hkdf_mode(ctx.get(), EVP_PKEY_HKDEF_MODE_EXPAND_ONLY) ||
+      !Thin_EVP_PKEY_CTX_set1_hkdf_key(ctx.get(), pseudorandom_key, prk_len)) {
     return false;
   }
 
   size_t length = params.length;
   ByteSource::Builder buf(length);
-  if (EVP_PKEY_derive(ctx.get(), buf.data<unsigned char>(), &length) <= 0)
+  if (Thin_EVP_PKEY_derive(ctx.get(), buf.data<unsigned char>(), &length) <= 0)
     return false;
 
   *out = std::move(buf).release();
diff --git a/src/crypto/crypto_hmac.cc b/src/crypto/crypto_hmac.cc
index ed78e21f11..953799aa51 100644
--- a/src/crypto/crypto_hmac.cc
+++ b/src/crypto/crypto_hmac.cc
@@ -70,17 +70,17 @@ void Hmac::New(const FunctionCallbackInfo<Value>& args) {
 void Hmac::HmacInit(const char* hash_type, const char* key, int key_len) {
   HandleScope scope(env()->isolate());
 
-  const EVP_MD* md = EVP_get_digestbyname(hash_type);
+  const EVP_MD* md = Thin_EVP_get_digestbyname(hash_type);
   if (md == nullptr)
     return THROW_ERR_CRYPTO_INVALID_DIGEST(
         env(), "Invalid digest: %s", hash_type);
   if (key_len == 0) {
     key = "";
   }
-  ctx_.reset(HMAC_CTX_new());
-  if (!ctx_ || !HMAC_Init_ex(ctx_.get(), key, key_len, md, nullptr)) {
+  ctx_.reset(Thin_HMAC_CTX_new());
+  if (!ctx_ || !Thin_HMAC_Init_ex(ctx_.get(), key, key_len, md, nullptr)) {
     ctx_.reset();
-    return ThrowCryptoError(env(), ERR_get_error());
+    return ThrowCryptoError(env(), Thin_ERR_get_error());
   }
 }
 
@@ -95,7 +95,7 @@ void Hmac::HmacInit(const FunctionCallbackInfo<Value>& args) {
 }
 
 bool Hmac::HmacUpdate(const char* data, size_t len) {
-  return ctx_ && HMAC_Update(ctx_.get(),
+  return ctx_ && Thin_HMAC_Update(ctx_.get(),
                              reinterpret_cast<const unsigned char*>(data),
                              len) == 1;
 }
@@ -126,10 +126,10 @@ void Hmac::HmacDigest(const FunctionCallbackInfo<Value>& args) {
   unsigned int md_len = 0;
 
   if (hmac->ctx_) {
-    bool ok = HMAC_Final(hmac->ctx_.get(), md_value, &md_len);
+    bool ok = Thin_HMAC_Final(hmac->ctx_.get(), md_value, &md_len);
     hmac->ctx_.reset();
     if (!ok) {
-      return ThrowCryptoError(env, ERR_get_error(), "Failed to finalize HMAC");
+      return ThrowCryptoError(env, Thin_ERR_get_error(), "Failed to finalize HMAC");
     }
   }
 
@@ -188,7 +188,7 @@ Maybe<bool> HmacTraits::AdditionalConfig(
   CHECK(args[offset + 2]->IsObject());  // Key
 
   Utf8Value digest(env->isolate(), args[offset + 1]);
-  params->digest = EVP_get_digestbyname(*digest);
+  params->digest = Thin_EVP_get_digestbyname(*digest);
   if (params->digest == nullptr) {
     THROW_ERR_CRYPTO_INVALID_DIGEST(env, "Invalid digest: %s", *digest);
     return Nothing<bool>();
@@ -225,10 +225,10 @@ bool HmacTraits::DeriveBits(
     Environment* env,
     const HmacConfig& params,
     ByteSource* out) {
-  HMACCtxPointer ctx(HMAC_CTX_new());
+  HMACCtxPointer ctx(Thin_HMAC_CTX_new());
 
   if (!ctx ||
-      !HMAC_Init_ex(
+      !Thin_HMAC_Init_ex(
           ctx.get(),
           params.key->GetSymmetricKey(),
           params.key->GetSymmetricKeySize(),
@@ -237,7 +237,7 @@ bool HmacTraits::DeriveBits(
     return false;
   }
 
-  if (!HMAC_Update(
+  if (!Thin_HMAC_Update(
           ctx.get(),
           params.data.data<unsigned char>(),
           params.data.size())) {
@@ -247,7 +247,7 @@ bool HmacTraits::DeriveBits(
   ByteSource::Builder buf(EVP_MAX_MD_SIZE);
   unsigned int len;
 
-  if (!HMAC_Final(ctx.get(), buf.data<unsigned char>(), &len)) {
+  if (!Thin_HMAC_Final(ctx.get(), buf.data<unsigned char>(), &len)) {
     return false;
   }
 
diff --git a/src/crypto/crypto_keygen.cc b/src/crypto/crypto_keygen.cc
index 752c8402aa..cd05fdca1b 100644
--- a/src/crypto/crypto_keygen.cc
+++ b/src/crypto/crypto_keygen.cc
@@ -45,8 +45,8 @@ Maybe<bool> NidKeyPairGenTraits::AdditionalConfig(
 
 EVPKeyCtxPointer NidKeyPairGenTraits::Setup(NidKeyPairGenConfig* params) {
   EVPKeyCtxPointer ctx =
-      EVPKeyCtxPointer(EVP_PKEY_CTX_new_id(params->params.id, nullptr));
-  if (!ctx || EVP_PKEY_keygen_init(ctx.get()) <= 0)
+      EVPKeyCtxPointer(Thin_EVP_PKEY_CTX_new_id(params->params.id, nullptr));
+  if (!ctx || Thin_EVP_PKEY_keygen_init(ctx.get()) <= 0)
     return EVPKeyCtxPointer();
 
   return ctx;
@@ -78,7 +78,7 @@ KeyGenJobStatus SecretKeyGenTraits::DoKeyGen(
   params->out = MallocOpenSSL<char>(params->length);
   if (CSPRNG(reinterpret_cast<unsigned char*>(params->out),
              params->length).is_err()) {
-    OPENSSL_clear_free(params->out, params->length);
+    Thin_OPENSSL_clear_free(params->out, params->length);
     params->out = nullptr;
     params->length = 0;
     return KeyGenJobStatus::FAILED;
diff --git a/src/crypto/crypto_keygen.h b/src/crypto/crypto_keygen.h
index 1a933a2478..edb7c6cd03 100644
--- a/src/crypto/crypto_keygen.h
+++ b/src/crypto/crypto_keygen.h
@@ -171,7 +171,7 @@ struct KeyPairGenTraits final {
 
     // Generate the key
     EVP_PKEY* pkey = nullptr;
-    if (!EVP_PKEY_keygen(ctx.get(), &pkey))
+    if (!Thin_EVP_PKEY_keygen(ctx.get(), &pkey))
       return KeyGenJobStatus::FAILED;
 
     params->key = ManagedEVPPKey(EVPKeyPointer(pkey));
diff --git a/src/crypto/crypto_keys.cc b/src/crypto/crypto_keys.cc
index 0be2283d60..b580f21a89 100644
--- a/src/crypto/crypto_keys.cc
+++ b/src/crypto/crypto_keys.cc
@@ -87,7 +87,7 @@ ParseKeyResult TryParsePublicKey(
   // This skips surrounding data and decodes PEM to DER.
   {
     MarkPopErrorOnReturn mark_pop_error_on_return;
-    if (PEM_bytes_read_bio(&der_data, &der_len, nullptr, name,
+    if (Thin_PEM_bytes_read_bio(&der_data, &der_len, nullptr, name,
                            bp.get(), nullptr, nullptr) != 1)
       return ParseKeyResult::kParseKeyNotRecognized;
   }
@@ -95,7 +95,7 @@ ParseKeyResult TryParsePublicKey(
   // OpenSSL might modify the pointer, so we need to make a copy before parsing.
   const unsigned char* p = der_data;
   pkey->reset(parse(&p, der_len));
-  OPENSSL_clear_free(der_data, der_len);
+  Thin_OPENSSL_clear_free(der_data, der_len);
 
   return *pkey ? ParseKeyResult::kParseKeyOk :
                  ParseKeyResult::kParseKeyFailed;
@@ -104,7 +104,7 @@ ParseKeyResult TryParsePublicKey(
 ParseKeyResult ParsePublicKeyPEM(EVPKeyPointer* pkey,
                                  const char* key_pem,
                                  int key_pem_len) {
-  BIOPointer bp(BIO_new_mem_buf(const_cast<char*>(key_pem), key_pem_len));
+  BIOPointer bp(Thin_BIO_new_mem_buf(const_cast<char*>(key_pem), key_pem_len));
   if (!bp)
     return ParseKeyResult::kParseKeyFailed;
 
@@ -113,26 +113,26 @@ ParseKeyResult ParsePublicKeyPEM(EVPKeyPointer* pkey,
   // Try parsing as a SubjectPublicKeyInfo first.
   ret = TryParsePublicKey(pkey, bp, "PUBLIC KEY",
       [](const unsigned char** p, long l) {  // NOLINT(runtime/int)
-        return d2i_PUBKEY(nullptr, p, l);
+        return Thin_d2i_PUBKEY(nullptr, p, l);
       });
   if (ret != ParseKeyResult::kParseKeyNotRecognized)
     return ret;
 
   // Maybe it is PKCS#1.
-  CHECK(BIO_reset(bp.get()));
+  CHECK(Thin_BIO_reset(bp.get()));
   ret = TryParsePublicKey(pkey, bp, "RSA PUBLIC KEY",
       [](const unsigned char** p, long l) {  // NOLINT(runtime/int)
-        return d2i_PublicKey(EVP_PKEY_RSA, nullptr, p, l);
+        return Thin_d2i_PublicKey(EVP_PKEY_RSA, nullptr, p, l);
       });
   if (ret != ParseKeyResult::kParseKeyNotRecognized)
     return ret;
 
   // X.509 fallback.
-  CHECK(BIO_reset(bp.get()));
+  CHECK(Thin_BIO_reset(bp.get()));
   return TryParsePublicKey(pkey, bp, "CERTIFICATE",
       [](const unsigned char** p, long l) {  // NOLINT(runtime/int)
-        X509Pointer x509(d2i_X509(nullptr, p, l));
-        return x509 ? X509_get_pubkey(x509.get()) : nullptr;
+        X509Pointer x509(Thin_d2i_X509(nullptr, p, l));
+        return x509 ? Thin_X509_get_pubkey(x509.get()) : nullptr;
       });
 }
 
@@ -147,10 +147,10 @@ ParseKeyResult ParsePublicKey(EVPKeyPointer* pkey,
 
     const unsigned char* p = reinterpret_cast<const unsigned char*>(key);
     if (config.type_.ToChecked() == kKeyEncodingPKCS1) {
-      pkey->reset(d2i_PublicKey(EVP_PKEY_RSA, nullptr, &p, key_len));
+      pkey->reset(Thin_d2i_PublicKey(EVP_PKEY_RSA, nullptr, &p, key_len));
     } else {
       CHECK_EQ(config.type_.ToChecked(), kKeyEncodingSPKI);
-      pkey->reset(d2i_PUBKEY(nullptr, &p, key_len));
+      pkey->reset(Thin_d2i_PUBKEY(nullptr, &p, key_len));
     }
 
     return *pkey ? ParseKeyResult::kParseKeyOk :
@@ -218,11 +218,11 @@ ParseKeyResult ParsePrivateKey(EVPKeyPointer* pkey,
   const ByteSource* passphrase = config.passphrase_.get();
 
   if (config.format_ == kKeyFormatPEM) {
-    BIOPointer bio(BIO_new_mem_buf(key, key_len));
+    BIOPointer bio(Thin_BIO_new_mem_buf(key, key_len));
     if (!bio)
       return ParseKeyResult::kParseKeyFailed;
 
-    pkey->reset(PEM_read_bio_PrivateKey(bio.get(),
+    pkey->reset(Thin_PEM_read_bio_PrivateKey(bio.get(),
                                         nullptr,
                                         PasswordCallback,
                                         &passphrase));
@@ -231,32 +231,32 @@ ParseKeyResult ParsePrivateKey(EVPKeyPointer* pkey,
 
     if (config.type_.ToChecked() == kKeyEncodingPKCS1) {
       const unsigned char* p = reinterpret_cast<const unsigned char*>(key);
-      pkey->reset(d2i_PrivateKey(EVP_PKEY_RSA, nullptr, &p, key_len));
+      pkey->reset(Thin_d2i_PrivateKey(EVP_PKEY_RSA, nullptr, &p, key_len));
     } else if (config.type_.ToChecked() == kKeyEncodingPKCS8) {
-      BIOPointer bio(BIO_new_mem_buf(key, key_len));
+      BIOPointer bio(Thin_BIO_new_mem_buf(key, key_len));
       if (!bio)
         return ParseKeyResult::kParseKeyFailed;
 
       if (IsEncryptedPrivateKeyInfo(
               reinterpret_cast<const unsigned char*>(key), key_len)) {
-        pkey->reset(d2i_PKCS8PrivateKey_bio(bio.get(),
+        pkey->reset(Thin_d2i_PKCS8PrivateKey_bio(bio.get(),
                                             nullptr,
                                             PasswordCallback,
                                             &passphrase));
       } else {
-        PKCS8Pointer p8inf(d2i_PKCS8_PRIV_KEY_INFO_bio(bio.get(), nullptr));
+        PKCS8Pointer p8inf(Thin_d2i_PKCS8_PRIV_KEY_INFO_bio(bio.get(), nullptr));
         if (p8inf)
-          pkey->reset(EVP_PKCS82PKEY(p8inf.get()));
+          pkey->reset(Thin_EVP_PKCS82PKEY(p8inf.get()));
       }
     } else {
       CHECK_EQ(config.type_.ToChecked(), kKeyEncodingSEC1);
       const unsigned char* p = reinterpret_cast<const unsigned char*>(key);
-      pkey->reset(d2i_PrivateKey(EVP_PKEY_EC, nullptr, &p, key_len));
+      pkey->reset(Thin_d2i_PrivateKey(EVP_PKEY_EC, nullptr, &p, key_len));
     }
   }
 
   // OpenSSL can fail to parse the key but still return a non-null pointer.
-  unsigned long err = ERR_peek_error();  // NOLINT(runtime/int)
+  unsigned long err = Thin_ERR_peek_error();  // NOLINT(runtime/int)
   if (err != 0)
     pkey->reset();
 
@@ -275,7 +275,7 @@ MaybeLocal<Value> BIOToStringOrBuffer(
     BIO* bio,
     PKFormatType format) {
   BUF_MEM* bptr;
-  BIO_get_mem_ptr(bio, &bptr);
+  Thin_BIO_get_mem_ptr(bio, &bptr);
   if (format == kKeyFormatPEM) {
     // PEM is an ASCII format, so we will return it as a string.
     return String::NewFromUtf8(env->isolate(), bptr->data,
@@ -294,7 +294,7 @@ MaybeLocal<Value> WritePrivateKey(
     Environment* env,
     EVP_PKEY* pkey,
     const PrivateKeyEncodingConfig& config) {
-  BIOPointer bio(BIO_new(BIO_s_mem()));
+  BIOPointer bio(Thin_BIO_new(Thin_BIO_s_mem()));
   CHECK(bio);
 
   // If an empty string was passed as the passphrase, the ByteSource might
@@ -325,12 +325,12 @@ MaybeLocal<Value> WritePrivateKey(
   PKEncodingType encoding_type = config.type_.ToChecked();
   if (encoding_type == kKeyEncodingPKCS1) {
     // PKCS#1 is only permitted for RSA keys.
-    CHECK_EQ(EVP_PKEY_id(pkey), EVP_PKEY_RSA);
+    CHECK_EQ(Thin_EVP_PKEY_id(pkey), EVP_PKEY_RSA);
 
-    RSAPointer rsa(EVP_PKEY_get1_RSA(pkey));
+    RSAPointer rsa(Thin_EVP_PKEY_get1_RSA(pkey));
     if (config.format_ == kKeyFormatPEM) {
       // Encode PKCS#1 as PEM.
-      err = PEM_write_bio_RSAPrivateKey(
+      err = Thin_PEM_write_bio_RSAPrivateKey(
                 bio.get(), rsa.get(),
                 config.cipher_,
                 reinterpret_cast<unsigned char*>(pass),
@@ -340,12 +340,12 @@ MaybeLocal<Value> WritePrivateKey(
       // Encode PKCS#1 as DER. This does not permit encryption.
       CHECK_EQ(config.format_, kKeyFormatDER);
       CHECK_NULL(config.cipher_);
-      err = i2d_RSAPrivateKey_bio(bio.get(), rsa.get()) != 1;
+      err = Thin_i2d_RSAPrivateKey_bio(bio.get(), rsa.get()) != 1;
     }
   } else if (encoding_type == kKeyEncodingPKCS8) {
     if (config.format_ == kKeyFormatPEM) {
       // Encode PKCS#8 as PEM.
-      err = PEM_write_bio_PKCS8PrivateKey(
+      err = Thin_PEM_write_bio_PKCS8PrivateKey(
                 bio.get(), pkey,
                 config.cipher_,
                 pass,
@@ -354,7 +354,7 @@ MaybeLocal<Value> WritePrivateKey(
     } else {
       // Encode PKCS#8 as DER.
       CHECK_EQ(config.format_, kKeyFormatDER);
-      err = i2d_PKCS8PrivateKey_bio(
+      err = Thin_i2d_PKCS8PrivateKey_bio(
                 bio.get(), pkey,
                 config.cipher_,
                 pass,
@@ -365,12 +365,12 @@ MaybeLocal<Value> WritePrivateKey(
     CHECK_EQ(encoding_type, kKeyEncodingSEC1);
 
     // SEC1 is only permitted for EC keys.
-    CHECK_EQ(EVP_PKEY_id(pkey), EVP_PKEY_EC);
+    CHECK_EQ(Thin_EVP_PKEY_id(pkey), EVP_PKEY_EC);
 
-    ECKeyPointer ec_key(EVP_PKEY_get1_EC_KEY(pkey));
+    ECKeyPointer ec_key(Thin_EVP_PKEY_get1_EC_KEY(pkey));
     if (config.format_ == kKeyFormatPEM) {
       // Encode SEC1 as PEM.
-      err = PEM_write_bio_ECPrivateKey(
+      err = Thin_PEM_write_bio_ECPrivateKey(
                 bio.get(), ec_key.get(),
                 config.cipher_,
                 reinterpret_cast<unsigned char*>(pass),
@@ -380,12 +380,12 @@ MaybeLocal<Value> WritePrivateKey(
       // Encode SEC1 as DER. This does not permit encryption.
       CHECK_EQ(config.format_, kKeyFormatDER);
       CHECK_NULL(config.cipher_);
-      err = i2d_ECPrivateKey_bio(bio.get(), ec_key.get()) != 1;
+      err = Thin_i2d_ECPrivateKey_bio(bio.get(), ec_key.get()) != 1;
     }
   }
 
   if (err) {
-    ThrowCryptoError(env, ERR_get_error(), "Failed to encode private key");
+    ThrowCryptoError(env, Thin_ERR_get_error(), "Failed to encode private key");
     return MaybeLocal<Value>();
   }
   return BIOToStringOrBuffer(env, bio.get(), config.format_);
@@ -396,25 +396,25 @@ bool WritePublicKeyInner(EVP_PKEY* pkey,
                          const PublicKeyEncodingConfig& config) {
   if (config.type_.ToChecked() == kKeyEncodingPKCS1) {
     // PKCS#1 is only valid for RSA keys.
-    CHECK_EQ(EVP_PKEY_id(pkey), EVP_PKEY_RSA);
-    RSAPointer rsa(EVP_PKEY_get1_RSA(pkey));
+    CHECK_EQ(Thin_EVP_PKEY_id(pkey), EVP_PKEY_RSA);
+    RSAPointer rsa(Thin_EVP_PKEY_get1_RSA(pkey));
     if (config.format_ == kKeyFormatPEM) {
       // Encode PKCS#1 as PEM.
-      return PEM_write_bio_RSAPublicKey(bio.get(), rsa.get()) == 1;
+      return Thin_PEM_write_bio_RSAPublicKey(bio.get(), rsa.get()) == 1;
     } else {
       // Encode PKCS#1 as DER.
       CHECK_EQ(config.format_, kKeyFormatDER);
-      return i2d_RSAPublicKey_bio(bio.get(), rsa.get()) == 1;
+      return Thin_i2d_RSAPublicKey_bio(bio.get(), rsa.get()) == 1;
     }
   } else {
     CHECK_EQ(config.type_.ToChecked(), kKeyEncodingSPKI);
     if (config.format_ == kKeyFormatPEM) {
       // Encode SPKI as PEM.
-      return PEM_write_bio_PUBKEY(bio.get(), pkey) == 1;
+      return Thin_PEM_write_bio_PUBKEY(bio.get(), pkey) == 1;
     } else {
       // Encode SPKI as DER.
       CHECK_EQ(config.format_, kKeyFormatDER);
-      return i2d_PUBKEY_bio(bio.get(), pkey) == 1;
+      return Thin_i2d_PUBKEY_bio(bio.get(), pkey) == 1;
     }
   }
 }
@@ -422,11 +422,11 @@ bool WritePublicKeyInner(EVP_PKEY* pkey,
 MaybeLocal<Value> WritePublicKey(Environment* env,
                                  EVP_PKEY* pkey,
                                  const PublicKeyEncodingConfig& config) {
-  BIOPointer bio(BIO_new(BIO_s_mem()));
+  BIOPointer bio(Thin_BIO_new(Thin_BIO_s_mem()));
   CHECK(bio);
 
   if (!WritePublicKeyInner(pkey, bio, config)) {
-    ThrowCryptoError(env, ERR_get_error(), "Failed to encode public key");
+    ThrowCryptoError(env, Thin_ERR_get_error(), "Failed to encode public key");
     return MaybeLocal<Value>();
   }
   return BIOToStringOrBuffer(env, bio.get(), config.format_);
@@ -489,7 +489,7 @@ Maybe<bool> ExportJWKAsymmetricKey(
     std::shared_ptr<KeyObjectData> key,
     Local<Object> target,
     bool handleRsaPss) {
-  switch (EVP_PKEY_id(key->GetAsymmetricKey().get())) {
+  switch (Thin_EVP_PKEY_id(key->GetAsymmetricKey().get())) {
     case EVP_PKEY_RSA_PSS: {
       if (handleRsaPss) return ExportJWKRsaKey(env, key, target);
       break;
@@ -542,7 +542,7 @@ Maybe<bool> GetAsymmetricKeyDetail(
   Environment* env,
   std::shared_ptr<KeyObjectData> key,
   Local<Object> target) {
-  switch (EVP_PKEY_id(key->GetAsymmetricKey().get())) {
+  switch (Thin_EVP_PKEY_id(key->GetAsymmetricKey().get())) {
     case EVP_PKEY_RSA:
       // Fall through
     case EVP_PKEY_RSA_PSS: return GetRsaKeyDetail(env, key, target);
@@ -568,7 +568,7 @@ ManagedEVPPKey& ManagedEVPPKey::operator=(const ManagedEVPPKey& that) {
   pkey_.reset(that.get());
 
   if (pkey_)
-    EVP_PKEY_up_ref(pkey_.get());
+    Thin_EVP_PKEY_up_ref(pkey_.get());
 
   mutex_ = that.mutex_;
 
@@ -596,13 +596,13 @@ void ManagedEVPPKey::MemoryInfo(MemoryTracker* tracker) const {
 
 size_t ManagedEVPPKey::size_of_private_key() const {
   size_t len = 0;
-  return (pkey_ && EVP_PKEY_get_raw_private_key(
+  return (pkey_ && Thin_EVP_PKEY_get_raw_private_key(
       pkey_.get(), nullptr, &len) == 1) ? len : 0;
 }
 
 size_t ManagedEVPPKey::size_of_public_key() const {
   size_t len = 0;
-  return (pkey_ && EVP_PKEY_get_raw_public_key(
+  return (pkey_ && Thin_EVP_PKEY_get_raw_public_key(
       pkey_.get(), nullptr, &len) == 1) ? len : 0;
 }
 
@@ -686,7 +686,7 @@ ManagedEVPPKey::GetPrivateKeyEncodingFromJs(
     if (context != kKeyContextInput) {
       if (args[*offset]->IsString()) {
         Utf8Value cipher_name(env->isolate(), args[*offset]);
-        result.cipher_ = EVP_get_cipherbyname(*cipher_name);
+        result.cipher_ = Thin_EVP_get_cipherbyname(*cipher_name);
         if (result.cipher_ == nullptr) {
           THROW_ERR_CRYPTO_UNKNOWN_CIPHER(env);
           return NonCopyableMaybe<PrivateKeyEncodingConfig>();
@@ -830,7 +830,7 @@ ManagedEVPPKey ManagedEVPPKey::GetParsedKey(Environment* env,
                                    "Passphrase required for encrypted key");
       break;
     default:
-      ThrowCryptoError(env, ERR_get_error(), default_msg);
+      ThrowCryptoError(env, Thin_ERR_get_error(), default_msg);
   }
 
   return ManagedEVPPKey(std::move(pkey));
@@ -1059,22 +1059,22 @@ void KeyObjectHandle::InitECRaw(const FunctionCallbackInfo<Value>& args) {
 
   MarkPopErrorOnReturn mark_pop_error_on_return;
 
-  int id = OBJ_txt2nid(*name);
-  ECKeyPointer eckey(EC_KEY_new_by_curve_name(id));
+  int id = Thin_OBJ_txt2nid(*name);
+  ECKeyPointer eckey(Thin_EC_KEY_new_by_curve_name(id));
   if (!eckey)
     return args.GetReturnValue().Set(false);
 
-  const EC_GROUP* group = EC_KEY_get0_group(eckey.get());
+  const EC_GROUP* group = Thin_EC_KEY_get0_group(eckey.get());
   ECPointPointer pub(ECDH::BufferToPoint(env, group, args[1]));
 
   if (!pub ||
       !eckey ||
-      !EC_KEY_set_public_key(eckey.get(), pub.get())) {
+      !Thin_EC_KEY_set_public_key(eckey.get(), pub.get())) {
     return args.GetReturnValue().Set(false);
   }
 
-  EVPKeyPointer pkey(EVP_PKEY_new());
-  if (!EVP_PKEY_assign_EC_KEY(pkey.get(), eckey.get()))
+  EVPKeyPointer pkey(Thin_EVP_PKEY_new());
+  if (!Thin_EVP_PKEY_assign_EC_KEY(pkey.get(), eckey.get()))
     args.GetReturnValue().Set(false);
 
   eckey.release();  // Release ownership of the key
@@ -1102,8 +1102,8 @@ void KeyObjectHandle::InitEDRaw(const FunctionCallbackInfo<Value>& args) {
 
   typedef EVP_PKEY* (*new_key_fn)(int, ENGINE*, const unsigned char*, size_t);
   new_key_fn fn = type == kKeyTypePrivate
-      ? EVP_PKEY_new_raw_private_key
-      : EVP_PKEY_new_raw_public_key;
+      ? Thin_EVP_PKEY_new_raw_private_key
+      : Thin_EVP_PKEY_new_raw_public_key;
 
   int id = GetOKPCurveFromName(*name);
 
@@ -1145,7 +1145,7 @@ void KeyObjectHandle::Equals(const FunctionCallbackInfo<Value>& args) {
     case kKeyTypeSecret: {
       size_t size = key->GetSymmetricKeySize();
       if (size == key2->GetSymmetricKeySize()) {
-        ret = CRYPTO_memcmp(
+        ret = Thin_CRYPTO_memcmp(
           key->GetSymmetricKey(),
           key2->GetSymmetricKey(),
           size) == 0;
@@ -1159,7 +1159,7 @@ void KeyObjectHandle::Equals(const FunctionCallbackInfo<Value>& args) {
       EVP_PKEY* pkey = key->GetAsymmetricKey().get();
       EVP_PKEY* pkey2 = key2->GetAsymmetricKey().get();
 #if OPENSSL_VERSION_MAJOR >= 3
-      int ok = EVP_PKEY_eq(pkey, pkey2);
+      int ok = Thin_EVP_PKEY_eq(pkey, pkey2);
 #else
       int ok = EVP_PKEY_cmp(pkey, pkey2);
 #endif
@@ -1206,7 +1206,7 @@ void KeyObjectHandle::GetKeyDetail(const FunctionCallbackInfo<Value>& args) {
 
 Local<Value> KeyObjectHandle::GetAsymmetricKeyType() const {
   const ManagedEVPPKey& key = data_->GetAsymmetricKey();
-  switch (EVP_PKEY_id(key.get())) {
+  switch (Thin_EVP_PKEY_id(key.get())) {
   case EVP_PKEY_RSA:
     return env()->crypto_rsa_string();
   case EVP_PKEY_RSA_PSS:
@@ -1421,9 +1421,9 @@ WebCryptoKeyExportStatus PKEY_SPKI_Export(
   CHECK_EQ(key_data->GetKeyType(), kKeyTypePublic);
   ManagedEVPPKey m_pkey = key_data->GetAsymmetricKey();
   Mutex::ScopedLock lock(*m_pkey.mutex());
-  BIOPointer bio(BIO_new(BIO_s_mem()));
+  BIOPointer bio(Thin_BIO_new(Thin_BIO_s_mem()));
   CHECK(bio);
-  if (!i2d_PUBKEY_bio(bio.get(), m_pkey.get()))
+  if (!Thin_i2d_PUBKEY_bio(bio.get(), m_pkey.get()))
     return WebCryptoKeyExportStatus::FAILED;
 
   *out = ByteSource::FromBIO(bio);
@@ -1437,10 +1437,10 @@ WebCryptoKeyExportStatus PKEY_PKCS8_Export(
   ManagedEVPPKey m_pkey = key_data->GetAsymmetricKey();
   Mutex::ScopedLock lock(*m_pkey.mutex());
 
-  BIOPointer bio(BIO_new(BIO_s_mem()));
+  BIOPointer bio(Thin_BIO_new(Thin_BIO_s_mem()));
   CHECK(bio);
-  PKCS8Pointer p8inf(EVP_PKEY2PKCS8(m_pkey.get()));
-  if (!i2d_PKCS8_PRIV_KEY_INFO_bio(bio.get(), p8inf.get()))
+  PKCS8Pointer p8inf(Thin_EVP_PKEY2PKCS8(m_pkey.get()));
+  if (!Thin_i2d_PKCS8_PRIV_KEY_INFO_bio(bio.get(), p8inf.get()))
     return WebCryptoKeyExportStatus::FAILED;
 
   *out = ByteSource::FromBIO(bio);
diff --git a/src/crypto/crypto_pbkdf2.cc b/src/crypto/crypto_pbkdf2.cc
index 963d0db6c6..a5c9685137 100644
--- a/src/crypto/crypto_pbkdf2.cc
+++ b/src/crypto/crypto_pbkdf2.cc
@@ -102,7 +102,7 @@ Maybe<bool> PBKDF2Traits::AdditionalConfig(
   }
 
   Utf8Value name(args.GetIsolate(), args[offset + 4]);
-  params->digest = EVP_get_digestbyname(*name);
+  params->digest = Thin_EVP_get_digestbyname(*name);
   if (params->digest == nullptr) {
     THROW_ERR_CRYPTO_INVALID_DIGEST(env, "Invalid digest: %s", *name);
     return Nothing<bool>();
@@ -121,7 +121,7 @@ bool PBKDF2Traits::DeriveBits(
   // The generated bytes are stored in buf, which is
   // assigned to out on success.
 
-  if (PKCS5_PBKDF2_HMAC(params.pass.data<char>(),
+  if (Thin_PKCS5_PBKDF2_HMAC(params.pass.data<char>(),
                         params.pass.size(),
                         params.salt.data<unsigned char>(),
                         params.salt.size(),
diff --git a/src/crypto/crypto_random.cc b/src/crypto/crypto_random.cc
index 2f9e9aacb1..0af3267bad 100644
--- a/src/crypto/crypto_random.cc
+++ b/src/crypto/crypto_random.cc
@@ -78,10 +78,10 @@ Maybe<bool> RandomPrimeTraits::EncodeOutput(
     const RandomPrimeConfig& params,
     ByteSource* unused,
     v8::Local<v8::Value>* result) {
-  size_t size = BN_num_bytes(params.prime.get());
+  size_t size = Thin_BN_num_bytes(params.prime.get());
   std::shared_ptr<BackingStore> store =
       ArrayBuffer::NewBackingStore(env->isolate(), size);
-  BN_bn2binpad(
+  Thin_BN_bn2binpad(
       params.prime.get(),
       reinterpret_cast<unsigned char*>(store->Data()),
       size);
@@ -104,7 +104,7 @@ Maybe<bool> RandomPrimeTraits::AdditionalConfig(
 
   if (!args[offset + 2]->IsUndefined()) {
     ArrayBufferOrViewContents<unsigned char> add(args[offset + 2]);
-    params->add.reset(BN_bin2bn(add.data(), add.size(), nullptr));
+    params->add.reset(Thin_BN_bin2bn(add.data(), add.size(), nullptr));
     if (!params->add) {
       THROW_ERR_CRYPTO_OPERATION_FAILED(env, "could not generate prime");
       return Nothing<bool>();
@@ -113,7 +113,7 @@ Maybe<bool> RandomPrimeTraits::AdditionalConfig(
 
   if (!args[offset + 3]->IsUndefined()) {
     ArrayBufferOrViewContents<unsigned char> rem(args[offset + 3]);
-    params->rem.reset(BN_bin2bn(rem.data(), rem.size(), nullptr));
+    params->rem.reset(Thin_BN_bin2bn(rem.data(), rem.size(), nullptr));
     if (!params->rem) {
       THROW_ERR_CRYPTO_OPERATION_FAILED(env, "could not generate prime");
       return Nothing<bool>();
@@ -125,7 +125,7 @@ Maybe<bool> RandomPrimeTraits::AdditionalConfig(
   CHECK_GT(bits, 0);
 
   if (params->add) {
-    if (BN_num_bits(params->add.get()) > bits) {
+    if (Thin_BN_num_bits(params->add.get()) > bits) {
       // If we allowed this, the best case would be returning a static prime
       // that wasn't generated randomly. The worst case would be an infinite
       // loop within OpenSSL, blocking the main thread or one of the threads
@@ -135,7 +135,7 @@ Maybe<bool> RandomPrimeTraits::AdditionalConfig(
     }
 
     if (params->rem) {
-      if (BN_cmp(params->add.get(), params->rem.get()) != 1) {
+      if (Thin_BN_cmp(params->add.get(), params->rem.get()) != 1) {
         // This would definitely lead to an infinite loop if allowed since
         // OpenSSL does not check this condition.
         THROW_ERR_OUT_OF_RANGE(env, "invalid options.rem");
@@ -146,7 +146,7 @@ Maybe<bool> RandomPrimeTraits::AdditionalConfig(
 
   params->bits = bits;
   params->safe = safe;
-  params->prime.reset(BN_secure_new());
+  params->prime.reset(Thin_BN_secure_new());
   if (!params->prime) {
     THROW_ERR_CRYPTO_OPERATION_FAILED(env, "could not generate prime");
     return Nothing<bool>();
@@ -158,11 +158,11 @@ Maybe<bool> RandomPrimeTraits::AdditionalConfig(
 bool RandomPrimeTraits::DeriveBits(Environment* env,
                                    const RandomPrimeConfig& params,
                                    ByteSource* unused) {
-  // BN_generate_prime_ex() calls RAND_bytes_ex() internally.
+  // Thin_BN_generate_prime_ex() calls Thin_RAND_bytes_ex() internally.
   // Make sure the CSPRNG is properly seeded.
   CHECK(CSPRNG(nullptr, 0).is_ok());
 
-  if (BN_generate_prime_ex(
+  if (Thin_BN_generate_prime_ex(
           params.prime.get(),
           params.bits,
           params.safe ? 1 : 0,
@@ -177,7 +177,7 @@ bool RandomPrimeTraits::DeriveBits(Environment* env,
 
 void CheckPrimeConfig::MemoryInfo(MemoryTracker* tracker) const {
   tracker->TrackFieldWithSize(
-      "prime", candidate ? BN_num_bytes(candidate.get()) : 0);
+      "prime", candidate ? Thin_BN_num_bytes(candidate.get()) : 0);
 }
 
 Maybe<bool> CheckPrimeTraits::AdditionalConfig(
@@ -190,7 +190,7 @@ Maybe<bool> CheckPrimeTraits::AdditionalConfig(
   ArrayBufferOrViewContents<unsigned char> candidate(args[offset]);
 
   params->candidate =
-      BignumPointer(BN_bin2bn(
+      BignumPointer(Thin_BN_bin2bn(
           candidate.data(),
           candidate.size(),
           nullptr));
@@ -213,9 +213,9 @@ bool CheckPrimeTraits::DeriveBits(
     const CheckPrimeConfig& params,
     ByteSource* out) {
 
-  BignumCtxPointer ctx(BN_CTX_new());
+  BignumCtxPointer ctx(Thin_BN_CTX_new());
 
-  int ret = BN_is_prime_ex(
+  int ret = Thin_BN_is_prime_ex(
             params.candidate.get(),
             params.checks,
             ctx.get(),
diff --git a/src/crypto/crypto_rsa.cc b/src/crypto/crypto_rsa.cc
index 47a42246ed..e0e710dc32 100644
--- a/src/crypto/crypto_rsa.cc
+++ b/src/crypto/crypto_rsa.cc
@@ -31,16 +31,16 @@ using v8::Value;
 namespace crypto {
 EVPKeyCtxPointer RsaKeyGenTraits::Setup(RsaKeyPairGenConfig* params) {
   EVPKeyCtxPointer ctx(
-      EVP_PKEY_CTX_new_id(
+      Thin_EVP_PKEY_CTX_new_id(
           params->params.variant == kKeyVariantRSA_PSS
               ? EVP_PKEY_RSA_PSS
               : EVP_PKEY_RSA,
           nullptr));
 
-  if (EVP_PKEY_keygen_init(ctx.get()) <= 0)
+  if (Thin_EVP_PKEY_keygen_init(ctx.get()) <= 0)
     return EVPKeyCtxPointer();
 
-  if (EVP_PKEY_CTX_set_rsa_keygen_bits(
+  if (Thin_EVP_PKEY_CTX_set_rsa_keygen_bits(
           ctx.get(),
           params->params.modulus_bits) <= 0) {
     return EVPKeyCtxPointer();
@@ -48,11 +48,11 @@ EVPKeyCtxPointer RsaKeyGenTraits::Setup(RsaKeyPairGenConfig* params) {
 
   // 0x10001 is the default RSA exponent.
   if (params->params.exponent != 0x10001) {
-    BignumPointer bn(BN_new());
+    BignumPointer bn(Thin_BN_new());
     CHECK_NOT_NULL(bn.get());
-    CHECK(BN_set_word(bn.get(), params->params.exponent));
+    CHECK(Thin_BN_set_word(bn.get(), params->params.exponent));
     // EVP_CTX accepts ownership of bn on success.
-    if (EVP_PKEY_CTX_set_rsa_keygen_pubexp(ctx.get(), bn.get()) <= 0)
+    if (Thin_EVP_PKEY_CTX_set_rsa_keygen_pubexp(ctx.get(), bn.get()) <= 0)
       return EVPKeyCtxPointer();
 
     bn.release();
@@ -60,7 +60,7 @@ EVPKeyCtxPointer RsaKeyGenTraits::Setup(RsaKeyPairGenConfig* params) {
 
   if (params->params.variant == kKeyVariantRSA_PSS) {
     if (params->params.md != nullptr &&
-        EVP_PKEY_CTX_set_rsa_pss_keygen_md(ctx.get(), params->params.md) <= 0) {
+        Thin_EVP_PKEY_CTX_set_rsa_pss_keygen_md(ctx.get(), params->params.md) <= 0) {
       return EVPKeyCtxPointer();
     }
 
@@ -74,7 +74,7 @@ EVPKeyCtxPointer RsaKeyGenTraits::Setup(RsaKeyPairGenConfig* params) {
     }
 
     if (mgf1_md != nullptr &&
-        EVP_PKEY_CTX_set_rsa_pss_keygen_mgf1_md(
+        Thin_EVP_PKEY_CTX_set_rsa_pss_keygen_mgf1_md(
             ctx.get(),
             mgf1_md) <= 0) {
       return EVPKeyCtxPointer();
@@ -82,11 +82,11 @@ EVPKeyCtxPointer RsaKeyGenTraits::Setup(RsaKeyPairGenConfig* params) {
 
     int saltlen = params->params.saltlen;
     if (saltlen < 0 && params->params.md != nullptr) {
-      saltlen = EVP_MD_size(params->params.md);
+      saltlen = Thin_EVP_MD_size(params->params.md);
     }
 
     if (saltlen >= 0 &&
-        EVP_PKEY_CTX_set_rsa_pss_keygen_saltlen(
+        Thin_EVP_PKEY_CTX_set_rsa_pss_keygen_saltlen(
             ctx.get(),
             saltlen) <= 0) {
       return EVPKeyCtxPointer();
@@ -151,7 +151,7 @@ Maybe<bool> RsaKeyGenTraits::AdditionalConfig(
     if (!args[*offset]->IsUndefined()) {
       CHECK(args[*offset]->IsString());
       Utf8Value digest(env->isolate(), args[*offset]);
-      params->params.md = EVP_get_digestbyname(*digest);
+      params->params.md = Thin_EVP_get_digestbyname(*digest);
       if (params->params.md == nullptr) {
         THROW_ERR_CRYPTO_INVALID_DIGEST(env, "Invalid digest: %s", *digest);
         return Nothing<bool>();
@@ -161,7 +161,7 @@ Maybe<bool> RsaKeyGenTraits::AdditionalConfig(
     if (!args[*offset + 1]->IsUndefined()) {
       CHECK(args[*offset + 1]->IsString());
       Utf8Value digest(env->isolate(), args[*offset + 1]);
-      params->params.mgf1_md = EVP_get_digestbyname(*digest);
+      params->params.mgf1_md = Thin_EVP_get_digestbyname(*digest);
       if (params->params.mgf1_md == nullptr) {
         THROW_ERR_CRYPTO_INVALID_DIGEST(
             env, "Invalid MGF1 digest: %s", *digest);
@@ -206,18 +206,18 @@ WebCryptoCipherStatus RSA_Cipher(
   ManagedEVPPKey m_pkey = key_data->GetAsymmetricKey();
   Mutex::ScopedLock lock(*m_pkey.mutex());
 
-  EVPKeyCtxPointer ctx(EVP_PKEY_CTX_new(m_pkey.get(), nullptr));
+  EVPKeyCtxPointer ctx(Thin_EVP_PKEY_CTX_new(m_pkey.get(), nullptr));
 
   if (!ctx || init(ctx.get()) <= 0)
     return WebCryptoCipherStatus::FAILED;
 
-  if (EVP_PKEY_CTX_set_rsa_padding(ctx.get(), params.padding) <= 0) {
+  if (Thin_EVP_PKEY_CTX_set_rsa_padding(ctx.get(), params.padding) <= 0) {
     return WebCryptoCipherStatus::FAILED;
   }
 
   if (params.digest != nullptr &&
-      (EVP_PKEY_CTX_set_rsa_oaep_md(ctx.get(), params.digest) <= 0 ||
-       EVP_PKEY_CTX_set_rsa_mgf1_md(ctx.get(), params.digest) <= 0)) {
+      (Thin_EVP_PKEY_CTX_set_rsa_oaep_md(ctx.get(), params.digest) <= 0 ||
+       Thin_EVP_PKEY_CTX_set_rsa_mgf1_md(ctx.get(), params.digest) <= 0)) {
     return WebCryptoCipherStatus::FAILED;
   }
 
@@ -315,7 +315,7 @@ Maybe<bool> RSACipherTraits::AdditionalConfig(
       CHECK(args[offset + 1]->IsString());  // digest
       Utf8Value digest(env->isolate(), args[offset + 1]);
 
-      params->digest = EVP_get_digestbyname(*digest);
+      params->digest = Thin_EVP_get_digestbyname(*digest);
       if (params->digest == nullptr) {
         THROW_ERR_CRYPTO_INVALID_DIGEST(env, "Invalid digest: %s", *digest);
         return Nothing<bool>();
@@ -349,11 +349,11 @@ WebCryptoCipherStatus RSACipherTraits::DoCipher(
   switch (cipher_mode) {
     case kWebCryptoCipherEncrypt:
       CHECK_EQ(key_data->GetKeyType(), kKeyTypePublic);
-      return RSA_Cipher<EVP_PKEY_encrypt_init, EVP_PKEY_encrypt>(
+      return RSA_Cipher<Thin_EVP_PKEY_encrypt_init, Thin_EVP_PKEY_encrypt>(
           env, key_data.get(), params, in, out);
     case kWebCryptoCipherDecrypt:
       CHECK_EQ(key_data->GetKeyType(), kKeyTypePrivate);
-      return RSA_Cipher<EVP_PKEY_decrypt_init, EVP_PKEY_decrypt>(
+      return RSA_Cipher<Thin_EVP_PKEY_decrypt_init, Thin_EVP_PKEY_decrypt>(
           env, key_data.get(), params, in, out);
   }
   return WebCryptoCipherStatus::FAILED;
@@ -365,16 +365,16 @@ Maybe<bool> ExportJWKRsaKey(
     Local<Object> target) {
   ManagedEVPPKey m_pkey = key->GetAsymmetricKey();
   Mutex::ScopedLock lock(*m_pkey.mutex());
-  int type = EVP_PKEY_id(m_pkey.get());
+  int type = Thin_EVP_PKEY_id(m_pkey.get());
   CHECK(type == EVP_PKEY_RSA || type == EVP_PKEY_RSA_PSS);
 
   // TODO(tniessen): Remove the "else" branch once we drop support for OpenSSL
   // versions older than 1.1.1e via FIPS / dynamic linking.
   const RSA* rsa;
-  if (OpenSSL_version_num() >= 0x1010105fL) {
-    rsa = EVP_PKEY_get0_RSA(m_pkey.get());
+  if (Thin_OpenSSL_version_num() >= 0x1010105fL) {
+    rsa = Thin_EVP_PKEY_get0_RSA(m_pkey.get());
   } else {
-    rsa = static_cast<const RSA*>(EVP_PKEY_get0(m_pkey.get()));
+    rsa = static_cast<const RSA*>(Thin_EVP_PKEY_get0(m_pkey.get()));
   }
   CHECK_NOT_NULL(rsa);
 
@@ -386,7 +386,7 @@ Maybe<bool> ExportJWKRsaKey(
   const BIGNUM* dp;
   const BIGNUM* dq;
   const BIGNUM* qi;
-  RSA_get0_key(rsa, &n, &e, &d);
+  Thin_RSA_get0_key(rsa, &n, &e, &d);
 
   if (target->Set(
           env->context(),
@@ -401,8 +401,8 @@ Maybe<bool> ExportJWKRsaKey(
   }
 
   if (key->GetKeyType() == kKeyTypePrivate) {
-    RSA_get0_factors(rsa, &p, &q);
-    RSA_get0_crt_params(rsa, &dp, &dq, &qi);
+    Thin_RSA_get0_factors(rsa, &p, &q);
+    Thin_RSA_get0_crt_params(rsa, &dp, &dq, &qi);
     if (SetEncodedValue(env, target, env->jwk_d_string(), d).IsNothing() ||
         SetEncodedValue(env, target, env->jwk_p_string(), p).IsNothing() ||
         SetEncodedValue(env, target, env->jwk_q_string(), q).IsNothing() ||
@@ -441,12 +441,12 @@ std::shared_ptr<KeyObjectData> ImportJWKRsaKey(
 
   KeyType type = d_value->IsString() ? kKeyTypePrivate : kKeyTypePublic;
 
-  RsaPointer rsa(RSA_new());
+  RsaPointer rsa(Thin_RSA_new());
 
   ByteSource n = ByteSource::FromEncodedString(env, n_value.As<String>());
   ByteSource e = ByteSource::FromEncodedString(env, e_value.As<String>());
 
-  if (!RSA_set0_key(
+  if (!Thin_RSA_set0_key(
           rsa.get(),
           n.ToBN().release(),
           e.ToBN().release(),
@@ -487,9 +487,9 @@ std::shared_ptr<KeyObjectData> ImportJWKRsaKey(
     ByteSource dq = ByteSource::FromEncodedString(env, dq_value.As<String>());
     ByteSource qi = ByteSource::FromEncodedString(env, qi_value.As<String>());
 
-    if (!RSA_set0_key(rsa.get(), nullptr, nullptr, d.ToBN().release()) ||
-        !RSA_set0_factors(rsa.get(), p.ToBN().release(), q.ToBN().release()) ||
-        !RSA_set0_crt_params(
+    if (!Thin_RSA_set0_key(rsa.get(), nullptr, nullptr, d.ToBN().release()) ||
+        !Thin_RSA_set0_factors(rsa.get(), p.ToBN().release(), q.ToBN().release()) ||
+        !Thin_RSA_set0_crt_params(
             rsa.get(),
             dp.ToBN().release(),
             dq.ToBN().release(),
@@ -499,8 +499,8 @@ std::shared_ptr<KeyObjectData> ImportJWKRsaKey(
     }
   }
 
-  EVPKeyPointer pkey(EVP_PKEY_new());
-  CHECK_EQ(EVP_PKEY_set1_RSA(pkey.get(), rsa.get()), 1);
+  EVPKeyPointer pkey(Thin_EVP_PKEY_new());
+  CHECK_EQ(Thin_EVP_PKEY_set1_RSA(pkey.get(), rsa.get()), 1);
 
   return KeyObjectData::CreateAsymmetric(type, ManagedEVPPKey(std::move(pkey)));
 }
@@ -514,22 +514,22 @@ Maybe<bool> GetRsaKeyDetail(
 
   ManagedEVPPKey m_pkey = key->GetAsymmetricKey();
   Mutex::ScopedLock lock(*m_pkey.mutex());
-  int type = EVP_PKEY_id(m_pkey.get());
+  int type = Thin_EVP_PKEY_id(m_pkey.get());
   CHECK(type == EVP_PKEY_RSA || type == EVP_PKEY_RSA_PSS);
 
   // TODO(tniessen): Remove the "else" branch once we drop support for OpenSSL
   // versions older than 1.1.1e via FIPS / dynamic linking.
   const RSA* rsa;
-  if (OpenSSL_version_num() >= 0x1010105fL) {
-    rsa = EVP_PKEY_get0_RSA(m_pkey.get());
+  if (Thin_OpenSSL_version_num() >= 0x1010105fL) {
+    rsa = Thin_EVP_PKEY_get0_RSA(m_pkey.get());
   } else {
-    rsa = static_cast<const RSA*>(EVP_PKEY_get0(m_pkey.get()));
+    rsa = static_cast<const RSA*>(Thin_EVP_PKEY_get0(m_pkey.get()));
   }
   CHECK_NOT_NULL(rsa);
 
-  RSA_get0_key(rsa, &n, &e, nullptr);
+  Thin_RSA_get0_key(rsa, &n, &e, nullptr);
 
-  size_t modulus_length = BN_num_bits(n);
+  size_t modulus_length = Thin_BN_num_bits(n);
 
   if (target
           ->Set(
@@ -544,9 +544,9 @@ Maybe<bool> GetRsaKeyDetail(
   {
     NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
     public_exponent =
-        ArrayBuffer::NewBackingStore(env->isolate(), BN_num_bytes(e));
+        ArrayBuffer::NewBackingStore(env->isolate(), Thin_BN_num_bytes(e));
   }
-  CHECK_EQ(BN_bn2binpad(e,
+  CHECK_EQ(Thin_BN_bn2binpad(e,
                         static_cast<unsigned char*>(public_exponent->Data()),
                         public_exponent->ByteLength()),
            static_cast<int>(public_exponent->ByteLength()));
@@ -563,13 +563,13 @@ Maybe<bool> GetRsaKeyDetail(
     // Due to the way ASN.1 encoding works, default values are omitted when
     // encoding the data structure. However, there are also RSA-PSS keys for
     // which no parameters are set. In that case, the ASN.1 RSASSA-PSS-params
-    // sequence will be missing entirely and RSA_get0_pss_params will return
+    // sequence will be missing entirely and Thin_RSA_get0_pss_params will return
     // nullptr. If parameters are present but all parameters are set to their
     // default values, an empty sequence will be stored in the ASN.1 structure.
-    // In that case, RSA_get0_pss_params does not return nullptr but all fields
+    // In that case, Thin_RSA_get0_pss_params does not return nullptr but all fields
     // of the returned RSA_PSS_PARAMS will be set to nullptr.
 
-    const RSA_PSS_PARAMS* params = RSA_get0_pss_params(rsa);
+    const RSA_PSS_PARAMS* params = Thin_RSA_get0_pss_params(rsa);
     if (params != nullptr) {
       int hash_nid = NID_sha1;
       int mgf_nid = NID_mgf1;
@@ -577,22 +577,22 @@ Maybe<bool> GetRsaKeyDetail(
       int64_t salt_length = 20;
 
       if (params->hashAlgorithm != nullptr) {
-        hash_nid = OBJ_obj2nid(params->hashAlgorithm->algorithm);
+        hash_nid = Thin_OBJ_obj2nid(params->hashAlgorithm->algorithm);
       }
 
       if (target
               ->Set(
                   env->context(),
                   env->hash_algorithm_string(),
-                  OneByteString(env->isolate(), OBJ_nid2ln(hash_nid)))
+                  OneByteString(env->isolate(), Thin_OBJ_nid2ln(hash_nid)))
               .IsNothing()) {
         return Nothing<bool>();
       }
 
       if (params->maskGenAlgorithm != nullptr) {
-        mgf_nid = OBJ_obj2nid(params->maskGenAlgorithm->algorithm);
+        mgf_nid = Thin_OBJ_obj2nid(params->maskGenAlgorithm->algorithm);
         if (mgf_nid == NID_mgf1) {
-          mgf1_hash_nid = OBJ_obj2nid(params->maskHash->algorithm);
+          mgf1_hash_nid = Thin_OBJ_obj2nid(params->maskHash->algorithm);
         }
       }
 
@@ -603,15 +603,15 @@ Maybe<bool> GetRsaKeyDetail(
                 ->Set(
                     env->context(),
                     env->mgf1_hash_algorithm_string(),
-                    OneByteString(env->isolate(), OBJ_nid2ln(mgf1_hash_nid)))
+                    OneByteString(env->isolate(), Thin_OBJ_nid2ln(mgf1_hash_nid)))
                 .IsNothing()) {
           return Nothing<bool>();
         }
       }
 
       if (params->saltLength != nullptr) {
-        if (ASN1_INTEGER_get_int64(&salt_length, params->saltLength) != 1) {
-          ThrowCryptoError(env, ERR_get_error(), "ASN1_INTEGER_get_in64 error");
+        if (Thin_ASN1_INTEGER_get_int64(&salt_length, params->saltLength) != 1) {
+          ThrowCryptoError(env, Thin_ERR_get_error(), "ASN1_INTEGER_get_in64 error");
           return Nothing<bool>();
         }
       }
diff --git a/src/crypto/crypto_scrypt.cc b/src/crypto/crypto_scrypt.cc
index 88d355446c..41f9dd06da 100644
--- a/src/crypto/crypto_scrypt.cc
+++ b/src/crypto/crypto_scrypt.cc
@@ -93,7 +93,7 @@ Maybe<bool> ScryptTraits::AdditionalConfig(
   params->p = args[offset + 4].As<Uint32>()->Value();
   params->maxmem = args[offset + 5]->IntegerValue(env->context()).ToChecked();
 
-  if (EVP_PBE_scrypt(
+  if (Thin_EVP_PBE_scrypt(
           nullptr,
           0,
           nullptr,
@@ -125,7 +125,7 @@ bool ScryptTraits::DeriveBits(
 
   // Both the pass and salt may be zero-length at this point
 
-  if (!EVP_PBE_scrypt(params.pass.data<char>(),
+  if (!Thin_EVP_PBE_scrypt(params.pass.data<char>(),
                       params.pass.size(),
                       params.salt.data<unsigned char>(),
                       params.salt.size(),
diff --git a/src/crypto/crypto_sig.cc b/src/crypto/crypto_sig.cc
index 92188911b3..b0f6868f67 100644
--- a/src/crypto/crypto_sig.cc
+++ b/src/crypto/crypto_sig.cc
@@ -31,18 +31,18 @@ namespace {
 bool ValidateDSAParameters(EVP_PKEY* key) {
   /* Validate DSA2 parameters from FIPS 186-4 */
 #if OPENSSL_VERSION_MAJOR >= 3
-  if (EVP_default_properties_is_fips_enabled(nullptr) &&
-      EVP_PKEY_DSA == EVP_PKEY_base_id(key)) {
+  if (Thin_EVP_default_properties_is_fips_enabled(nullptr) &&
+      EVP_PKEY_DSA == Thin_EVP_PKEY_base_id(key)) {
 #else
-  if (FIPS_mode() && EVP_PKEY_DSA == EVP_PKEY_base_id(key)) {
+  if (Thin_FIPS_mode() && EVP_PKEY_DSA == Thin_EVP_PKEY_base_id(key)) {
 #endif
-    const DSA* dsa = EVP_PKEY_get0_DSA(key);
+    const DSA* dsa = Thin_EVP_PKEY_get0_DSA(key);
     const BIGNUM* p;
-    DSA_get0_pqg(dsa, &p, nullptr, nullptr);
-    size_t L = BN_num_bits(p);
+    Thin_DSA_get0_pqg(dsa, &p, nullptr, nullptr);
+    size_t L = Thin_BN_num_bits(p);
     const BIGNUM* q;
-    DSA_get0_pqg(dsa, nullptr, &q, nullptr);
-    size_t N = BN_num_bits(q);
+    Thin_DSA_get0_pqg(dsa, nullptr, &q, nullptr);
+    size_t N = Thin_BN_num_bits(q);
 
     return (L == 1024 && N == 160) ||
            (L == 2048 && N == 224) ||
@@ -57,13 +57,13 @@ bool ApplyRSAOptions(const ManagedEVPPKey& pkey,
                      EVP_PKEY_CTX* pkctx,
                      int padding,
                      const Maybe<int>& salt_len) {
-  if (EVP_PKEY_id(pkey.get()) == EVP_PKEY_RSA ||
-      EVP_PKEY_id(pkey.get()) == EVP_PKEY_RSA2 ||
-      EVP_PKEY_id(pkey.get()) == EVP_PKEY_RSA_PSS) {
-    if (EVP_PKEY_CTX_set_rsa_padding(pkctx, padding) <= 0)
+  if (Thin_EVP_PKEY_id(pkey.get()) == EVP_PKEY_RSA ||
+      Thin_EVP_PKEY_id(pkey.get()) == EVP_PKEY_RSA2 ||
+      Thin_EVP_PKEY_id(pkey.get()) == EVP_PKEY_RSA_PSS) {
+    if (Thin_EVP_PKEY_CTX_set_rsa_padding(pkctx, padding) <= 0)
       return false;
     if (padding == RSA_PKCS1_PSS_PADDING && salt_len.IsJust()) {
-      if (EVP_PKEY_CTX_set_rsa_pss_saltlen(pkctx, salt_len.FromJust()) <= 0)
+      if (Thin_EVP_PKEY_CTX_set_rsa_pss_saltlen(pkctx, salt_len.FromJust()) <= 0)
         return false;
     }
   }
@@ -79,10 +79,10 @@ std::unique_ptr<BackingStore> Node_SignFinal(Environment* env,
   unsigned char m[EVP_MAX_MD_SIZE];
   unsigned int m_len;
 
-  if (!EVP_DigestFinal_ex(mdctx.get(), m, &m_len))
+  if (!Thin_EVP_DigestFinal_ex(mdctx.get(), m, &m_len))
     return nullptr;
 
-  int signed_sig_len = EVP_PKEY_size(pkey.get());
+  int signed_sig_len = Thin_EVP_PKEY_size(pkey.get());
   CHECK_GE(signed_sig_len, 0);
   size_t sig_len = static_cast<size_t>(signed_sig_len);
   std::unique_ptr<BackingStore> sig;
@@ -90,12 +90,12 @@ std::unique_ptr<BackingStore> Node_SignFinal(Environment* env,
     NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
     sig = ArrayBuffer::NewBackingStore(env->isolate(), sig_len);
   }
-  EVPKeyCtxPointer pkctx(EVP_PKEY_CTX_new(pkey.get(), nullptr));
+  EVPKeyCtxPointer pkctx(Thin_EVP_PKEY_CTX_new(pkey.get(), nullptr));
   if (pkctx &&
-      EVP_PKEY_sign_init(pkctx.get()) &&
+      Thin_EVP_PKEY_sign_init(pkctx.get()) &&
       ApplyRSAOptions(pkey, pkctx.get(), padding, pss_salt_len) &&
-      EVP_PKEY_CTX_set_signature_md(pkctx.get(), EVP_MD_CTX_md(mdctx.get())) &&
-      EVP_PKEY_sign(pkctx.get(), static_cast<unsigned char*>(sig->Data()),
+      Thin_EVP_PKEY_CTX_set_signature_md(pkctx.get(), Thin_EVP_MD_CTX_md(mdctx.get())) &&
+      Thin_EVP_PKEY_sign(pkctx.get(), static_cast<unsigned char*>(sig->Data()),
                     &sig_len, m, m_len)) {
     CHECK_LE(sig_len, sig->ByteLength());
     if (sig_len == 0)
@@ -109,21 +109,21 @@ std::unique_ptr<BackingStore> Node_SignFinal(Environment* env,
 }
 
 int GetDefaultSignPadding(const ManagedEVPPKey& m_pkey) {
-  return EVP_PKEY_id(m_pkey.get()) == EVP_PKEY_RSA_PSS ? RSA_PKCS1_PSS_PADDING :
+  return Thin_EVP_PKEY_id(m_pkey.get()) == EVP_PKEY_RSA_PSS ? RSA_PKCS1_PSS_PADDING :
                                                          RSA_PKCS1_PADDING;
 }
 
 unsigned int GetBytesOfRS(const ManagedEVPPKey& pkey) {
-  int bits, base_id = EVP_PKEY_base_id(pkey.get());
+  int bits, base_id = Thin_EVP_PKEY_base_id(pkey.get());
 
   if (base_id == EVP_PKEY_DSA) {
-    const DSA* dsa_key = EVP_PKEY_get0_DSA(pkey.get());
+    const DSA* dsa_key = Thin_EVP_PKEY_get0_DSA(pkey.get());
     // Both r and s are computed mod q, so their width is limited by that of q.
-    bits = BN_num_bits(DSA_get0_q(dsa_key));
+    bits = Thin_BN_num_bits(Thin_DSA_get0_q(dsa_key));
   } else if (base_id == EVP_PKEY_EC) {
-    const EC_KEY* ec_key = EVP_PKEY_get0_EC_KEY(pkey.get());
-    const EC_GROUP* ec_group = EC_KEY_get0_group(ec_key);
-    bits = EC_GROUP_order_bits(ec_group);
+    const EC_KEY* ec_key = Thin_EVP_PKEY_get0_EC_KEY(pkey.get());
+    const EC_GROUP* ec_group = Thin_EC_KEY_get0_group(ec_key);
+    bits = Thin_EC_GROUP_order_bits(ec_group);
   } else {
     return kNoDsaSignature;
   }
@@ -136,14 +136,14 @@ bool ExtractP1363(
     unsigned char* out,
     size_t len,
     size_t n) {
-  ECDSASigPointer asn1_sig(d2i_ECDSA_SIG(nullptr, &sig_data, len));
+  ECDSASigPointer asn1_sig(Thin_d2i_ECDSA_SIG(nullptr, &sig_data, len));
   if (!asn1_sig)
     return false;
 
-  const BIGNUM* pr = ECDSA_SIG_get0_r(asn1_sig.get());
-  const BIGNUM* ps = ECDSA_SIG_get0_s(asn1_sig.get());
+  const BIGNUM* pr = Thin_ECDSA_SIG_get0_r(asn1_sig.get());
+  const BIGNUM* ps = Thin_ECDSA_SIG_get0_s(asn1_sig.get());
 
-  return BN_bn2binpad(pr, out, n) > 0 && BN_bn2binpad(ps, out + n, n) > 0;
+  return Thin_BN_bn2binpad(pr, out, n) > 0 && Thin_BN_bn2binpad(ps, out + n, n) > 0;
 }
 
 // Returns the maximum size of each of the integers (r, s) of the DSA signature.
@@ -198,18 +198,18 @@ ByteSource ConvertSignatureToDER(
   if (out.size() != 2 * n)
     return ByteSource();
 
-  ECDSASigPointer asn1_sig(ECDSA_SIG_new());
+  ECDSASigPointer asn1_sig(Thin_ECDSA_SIG_new());
   CHECK(asn1_sig);
-  BIGNUM* r = BN_new();
+  BIGNUM* r = Thin_BN_new();
   CHECK_NOT_NULL(r);
-  BIGNUM* s = BN_new();
+  BIGNUM* s = Thin_BN_new();
   CHECK_NOT_NULL(s);
-  CHECK_EQ(r, BN_bin2bn(sig_data, n, r));
-  CHECK_EQ(s, BN_bin2bn(sig_data + n, n, s));
-  CHECK_EQ(1, ECDSA_SIG_set0(asn1_sig.get(), r, s));
+  CHECK_EQ(r, Thin_BN_bin2bn(sig_data, n, r));
+  CHECK_EQ(s, Thin_BN_bin2bn(sig_data + n, n, s));
+  CHECK_EQ(1, Thin_ECDSA_SIG_set0(asn1_sig.get(), r, s));
 
   unsigned char* data = nullptr;
-  int len = i2d_ECDSA_SIG(asn1_sig.get(), &data);
+  int len = Thin_i2d_ECDSA_SIG(asn1_sig.get(), &data);
 
   if (len <= 0)
     return ByteSource();
@@ -237,7 +237,7 @@ void CheckThrow(Environment* env, SignBase::Error error) {
     case SignBase::Error::kSignPrivateKey:
     case SignBase::Error::kSignPublicKey:
       {
-        unsigned long err = ERR_get_error();  // NOLINT(runtime/int)
+        unsigned long err = Thin_ERR_get_error();  // NOLINT(runtime/int)
         if (err)
           return ThrowCryptoError(env, err);
         switch (error) {
@@ -249,7 +249,7 @@ void CheckThrow(Environment* env, SignBase::Error error) {
                 "EVP_SignUpdate failed");
           case SignBase::Error::kSignPrivateKey:
             return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
-                "PEM_read_bio_PrivateKey failed");
+                "Thin_PEM_read_bio_PrivateKey failed");
           case SignBase::Error::kSignPublicKey:
             return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
                 "PEM_read_bio_PUBKEY failed");
@@ -264,7 +264,7 @@ void CheckThrow(Environment* env, SignBase::Error error) {
 }
 
 bool IsOneShot(const ManagedEVPPKey& key) {
-  switch (EVP_PKEY_id(key.get())) {
+  switch (Thin_EVP_PKEY_id(key.get())) {
     case EVP_PKEY_ED25519:
     case EVP_PKEY_ED448:
       return true;
@@ -275,7 +275,7 @@ bool IsOneShot(const ManagedEVPPKey& key) {
 
 bool UseP1363Encoding(const ManagedEVPPKey& key,
                       const DSASigEnc& dsa_encoding) {
-  switch (EVP_PKEY_id(key.get())) {
+  switch (Thin_EVP_PKEY_id(key.get())) {
     case EVP_PKEY_EC:
     case EVP_PKEY_DSA:
       return dsa_encoding == kSigEncP1363;
@@ -291,14 +291,14 @@ SignBase::Error SignBase::Init(const char* sign_type) {
   // exposed through the public API.
   if (strcmp(sign_type, "dss1") == 0 ||
       strcmp(sign_type, "DSS1") == 0) {
-    sign_type = "SHA1";
+    sign_type = "Thin_SHA1";
   }
-  const EVP_MD* md = EVP_get_digestbyname(sign_type);
+  const EVP_MD* md = Thin_EVP_get_digestbyname(sign_type);
   if (md == nullptr)
     return kSignUnknownDigest;
 
-  mdctx_.reset(EVP_MD_CTX_new());
-  if (!mdctx_ || !EVP_DigestInit_ex(mdctx_.get(), md, nullptr)) {
+  mdctx_.reset(Thin_EVP_MD_CTX_new());
+  if (!mdctx_ || !Thin_EVP_DigestInit_ex(mdctx_.get(), md, nullptr)) {
     mdctx_.reset();
     return kSignInit;
   }
@@ -309,7 +309,7 @@ SignBase::Error SignBase::Init(const char* sign_type) {
 SignBase::Error SignBase::Update(const char* data, size_t len) {
   if (mdctx_ == nullptr)
     return kSignNotInitialised;
-  if (!EVP_DigestUpdate(mdctx_.get(), data, len))
+  if (!Thin_EVP_DigestUpdate(mdctx_.get(), data, len))
     return kSignUpdate;
   return kSignOk;
 }
@@ -516,17 +516,17 @@ SignBase::Error Verify::VerifyFinal(const ManagedEVPPKey& pkey,
   *verify_result = false;
   EVPMDPointer mdctx = std::move(mdctx_);
 
-  if (!EVP_DigestFinal_ex(mdctx.get(), m, &m_len))
+  if (!Thin_EVP_DigestFinal_ex(mdctx.get(), m, &m_len))
     return kSignPublicKey;
 
-  EVPKeyCtxPointer pkctx(EVP_PKEY_CTX_new(pkey.get(), nullptr));
+  EVPKeyCtxPointer pkctx(Thin_EVP_PKEY_CTX_new(pkey.get(), nullptr));
   if (pkctx &&
-      EVP_PKEY_verify_init(pkctx.get()) > 0 &&
+      Thin_EVP_PKEY_verify_init(pkctx.get()) > 0 &&
       ApplyRSAOptions(pkey, pkctx.get(), padding, saltlen) &&
-      EVP_PKEY_CTX_set_signature_md(pkctx.get(),
-                                    EVP_MD_CTX_md(mdctx.get())) > 0) {
+      Thin_EVP_PKEY_CTX_set_signature_md(pkctx.get(),
+                                    Thin_EVP_MD_CTX_md(mdctx.get())) > 0) {
     const unsigned char* s = sig.data<unsigned char>();
-    const int r = EVP_PKEY_verify(pkctx.get(), s, sig.size(), m, m_len);
+    const int r = Thin_EVP_PKEY_verify(pkctx.get(), s, sig.size(), m, m_len);
     *verify_result = r == 1;
   }
 
@@ -645,7 +645,7 @@ Maybe<bool> SignTraits::AdditionalConfig(
 
   if (args[offset + 6]->IsString()) {
     Utf8Value digest(env->isolate(), args[offset + 6]);
-    params->digest = EVP_get_digestbyname(*digest);
+    params->digest = Thin_EVP_get_digestbyname(*digest);
     if (params->digest == nullptr) {
       THROW_ERR_CRYPTO_INVALID_DIGEST(env, "Invalid digest: %s", *digest);
       return Nothing<bool>();
@@ -699,12 +699,12 @@ bool SignTraits::DeriveBits(
     const SignConfiguration& params,
     ByteSource* out) {
   ClearErrorOnReturn clear_error_on_return;
-  EVPMDPointer context(EVP_MD_CTX_new());
+  EVPMDPointer context(Thin_EVP_MD_CTX_new());
   EVP_PKEY_CTX* ctx = nullptr;
 
   switch (params.mode) {
     case SignConfiguration::kSign:
-      if (!EVP_DigestSignInit(
+      if (!Thin_EVP_DigestSignInit(
               context.get(),
               &ctx,
               params.digest,
@@ -715,7 +715,7 @@ bool SignTraits::DeriveBits(
       }
       break;
     case SignConfiguration::kVerify:
-      if (!EVP_DigestVerifyInit(
+      if (!Thin_EVP_DigestVerifyInit(
               context.get(),
               &ctx,
               params.digest,
@@ -747,7 +747,7 @@ bool SignTraits::DeriveBits(
     case SignConfiguration::kSign: {
       if (IsOneShot(params.key)) {
         size_t len;
-        if (!EVP_DigestSign(
+        if (!Thin_EVP_DigestSign(
             context.get(),
             nullptr,
             &len,
@@ -757,7 +757,7 @@ bool SignTraits::DeriveBits(
           return false;
         }
         ByteSource::Builder buf(len);
-        if (!EVP_DigestSign(context.get(),
+        if (!Thin_EVP_DigestSign(context.get(),
                             buf.data<unsigned char>(),
                             &len,
                             params.data.data<unsigned char>(),
@@ -768,16 +768,16 @@ bool SignTraits::DeriveBits(
         *out = std::move(buf).release(len);
       } else {
         size_t len;
-        if (!EVP_DigestSignUpdate(
+        if (!Thin_EVP_DigestSignUpdate(
                 context.get(),
                 params.data.data<unsigned char>(),
                 params.data.size()) ||
-            !EVP_DigestSignFinal(context.get(), nullptr, &len)) {
+            !Thin_EVP_DigestSignFinal(context.get(), nullptr, &len)) {
           crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
           return false;
         }
         ByteSource::Builder buf(len);
-        if (!EVP_DigestSignFinal(
+        if (!Thin_EVP_DigestSignFinal(
                 context.get(), buf.data<unsigned char>(), &len)) {
           crypto::CheckThrow(env, SignBase::Error::kSignPrivateKey);
           return false;
@@ -795,7 +795,7 @@ bool SignTraits::DeriveBits(
     case SignConfiguration::kVerify: {
       ByteSource::Builder buf(1);
       buf.data<char>()[0] = 0;
-      if (EVP_DigestVerify(
+      if (Thin_EVP_DigestVerify(
               context.get(),
               params.signature.data<unsigned char>(),
               params.signature.size(),
diff --git a/src/crypto/crypto_spkac.cc b/src/crypto/crypto_spkac.cc
index 92484847af..d7399f0ea9 100644
--- a/src/crypto/crypto_spkac.cc
+++ b/src/crypto/crypto_spkac.cc
@@ -25,15 +25,15 @@ bool VerifySpkac(const ArrayBufferOrViewContents<char>& input) {
   length = std::string(input.data()).find_last_not_of(" \n\r\t") + 1;
 #endif
   NetscapeSPKIPointer spki(
-      NETSCAPE_SPKI_b64_decode(input.data(), length));
+      Thin_NETSCAPE_SPKI_b64_decode(input.data(), length));
   if (!spki)
     return false;
 
-  EVPKeyPointer pkey(X509_PUBKEY_get(spki->spkac->pubkey));
+  EVPKeyPointer pkey(Thin_X509_PUBKEY_get(spki->spkac->pubkey));
   if (!pkey)
     return false;
 
-  return NETSCAPE_SPKI_verify(spki.get(), pkey.get()) > 0;
+  return Thin_NETSCAPE_SPKI_verify(spki.get(), pkey.get()) > 0;
 }
 
 void VerifySpkac(const FunctionCallbackInfo<Value>& args) {
@@ -50,7 +50,7 @@ void VerifySpkac(const FunctionCallbackInfo<Value>& args) {
 
 ByteSource ExportPublicKey(Environment* env,
                            const ArrayBufferOrViewContents<char>& input) {
-  BIOPointer bio(BIO_new(BIO_s_mem()));
+  BIOPointer bio(Thin_BIO_new(Thin_BIO_s_mem()));
   if (!bio) return ByteSource();
 
   size_t length = input.size();
@@ -61,13 +61,13 @@ ByteSource ExportPublicKey(Environment* env,
   length = std::string(input.data()).find_last_not_of(" \n\r\t") + 1;
 #endif
   NetscapeSPKIPointer spki(
-      NETSCAPE_SPKI_b64_decode(input.data(), length));
+      Thin_NETSCAPE_SPKI_b64_decode(input.data(), length));
   if (!spki) return ByteSource();
 
-  EVPKeyPointer pkey(NETSCAPE_SPKI_get_pubkey(spki.get()));
+  EVPKeyPointer pkey(Thin_NETSCAPE_SPKI_get_pubkey(spki.get()));
   if (!pkey) return ByteSource();
 
-  if (PEM_write_bio_PUBKEY(bio.get(), pkey.get()) <= 0) return ByteSource();
+  if (Thin_PEM_write_bio_PUBKEY(bio.get(), pkey.get()) <= 0) return ByteSource();
 
   return ByteSource::FromBIO(bio);
 }
@@ -96,12 +96,12 @@ ByteSource ExportChallenge(const ArrayBufferOrViewContents<char>& input) {
   length = std::string(input.data()).find_last_not_of(" \n\r\t") + 1;
 #endif
   NetscapeSPKIPointer sp(
-      NETSCAPE_SPKI_b64_decode(input.data(), length));
+      Thin_NETSCAPE_SPKI_b64_decode(input.data(), length));
   if (!sp)
     return ByteSource();
 
   unsigned char* buf = nullptr;
-  int buf_size = ASN1_STRING_to_UTF8(&buf, sp->spkac->challenge);
+  int buf_size = Thin_ASN1_STRING_to_UTF8(&buf, sp->spkac->challenge);
   return (buf_size >= 0) ? ByteSource::Allocated(buf, buf_size) : ByteSource();
 }
 
diff --git a/src/crypto/crypto_timing.cc b/src/crypto/crypto_timing.cc
index 8904f6b140..7150ae8ca6 100644
--- a/src/crypto/crypto_timing.cc
+++ b/src/crypto/crypto_timing.cc
@@ -43,7 +43,7 @@ void TimingSafeEqual(const FunctionCallbackInfo<Value>& args) {
   }
 
   return args.GetReturnValue().Set(
-      CRYPTO_memcmp(buf1.data(), buf2.data(), buf1.size()) == 0);
+      Thin_CRYPTO_memcmp(buf1.data(), buf2.data(), buf1.size()) == 0);
 }
 
 void Initialize(Environment* env, Local<Object> target) {
diff --git a/src/crypto/crypto_tls.cc b/src/crypto/crypto_tls.cc
index dd313371d4..8d5146182e 100644
--- a/src/crypto/crypto_tls.cc
+++ b/src/crypto/crypto_tls.cc
@@ -69,7 +69,7 @@ SSL_SESSION* GetSessionCallback(
     const unsigned char* key,
     int len,
     int* copy) {
-  TLSWrap* w = static_cast<TLSWrap*>(SSL_get_app_data(s));
+  TLSWrap* w = static_cast<TLSWrap*>(Thin_SSL_get_app_data(s));
   *copy = 0;
   return w->ReleaseSession();
 }
@@ -113,7 +113,7 @@ void OnClientHello(
 }
 
 void KeylogCallback(const SSL* s, const char* line) {
-  TLSWrap* w = static_cast<TLSWrap*>(SSL_get_app_data(s));
+  TLSWrap* w = static_cast<TLSWrap*>(Thin_SSL_get_app_data(s));
   Environment* env = w->env();
   HandleScope handle_scope(env->isolate());
   Context::Scope context_scope(env->context());
@@ -130,7 +130,7 @@ void KeylogCallback(const SSL* s, const char* line) {
 }
 
 int NewSessionCallback(SSL* s, SSL_SESSION* sess) {
-  TLSWrap* w = static_cast<TLSWrap*>(SSL_get_app_data(s));
+  TLSWrap* w = static_cast<TLSWrap*>(Thin_SSL_get_app_data(s));
   Environment* env = w->env();
   HandleScope handle_scope(env->isolate());
   Context::Scope context_scope(env->context());
@@ -139,7 +139,7 @@ int NewSessionCallback(SSL* s, SSL_SESSION* sess) {
     return 0;
 
   // Check if session is small enough to be stored
-  int size = i2d_SSL_SESSION(sess, nullptr);
+  int size = Thin_i2d_SSL_SESSION(sess, nullptr);
   if (UNLIKELY(size > SecureContext::kMaxSessionSize))
     return 0;
 
@@ -151,11 +151,11 @@ int NewSessionCallback(SSL* s, SSL_SESSION* sess) {
   unsigned char* session_data =
       reinterpret_cast<unsigned char*>(Buffer::Data(session));
 
-  CHECK_EQ(i2d_SSL_SESSION(sess, &session_data), size);
+  CHECK_EQ(Thin_i2d_SSL_SESSION(sess, &session_data), size);
 
   unsigned int session_id_length;
   const unsigned char* session_id_data =
-      SSL_SESSION_get_id(sess, &session_id_length);
+      Thin_SSL_SESSION_get_id(sess, &session_id_length);
 
   Local<Object> session_id = Buffer::Copy(
       env,
@@ -180,7 +180,7 @@ int NewSessionCallback(SSL* s, SSL_SESSION* sess) {
 }
 
 int SSLCertCallback(SSL* s, void* arg) {
-  TLSWrap* w = static_cast<TLSWrap*>(SSL_get_app_data(s));
+  TLSWrap* w = static_cast<TLSWrap*>(Thin_SSL_get_app_data(s));
 
   if (!w->is_server() || !w->is_waiting_cert_cb())
     return 1;
@@ -202,7 +202,7 @@ int SSLCertCallback(SSL* s, void* arg) {
       ? String::Empty(env->isolate())
       : OneByteString(env->isolate(), servername, strlen(servername));
 
-  Local<Value> ocsp = (SSL_get_tlsext_status_type(s) == TLSEXT_STATUSTYPE_ocsp)
+  Local<Value> ocsp = (Thin_SSL_get_tlsext_status_type(s) == TLSEXT_STATUSTYPE_ocsp)
       ? True(env->isolate())
       : False(env->isolate());
 
@@ -230,7 +230,7 @@ int SelectALPNCallback(
 
   if (alpn_protos.empty()) return SSL_TLSEXT_ERR_NOACK;
 
-  int status = SSL_select_next_proto(const_cast<unsigned char**>(out),
+  int status = Thin_SSL_select_next_proto(const_cast<unsigned char**>(out),
                                      outlen,
                                      alpn_protos.data(),
                                      alpn_protos.size(),
@@ -247,7 +247,7 @@ int SelectALPNCallback(
 }
 
 int TLSExtStatusCallback(SSL* s, void* arg) {
-  TLSWrap* w = static_cast<TLSWrap*>(SSL_get_app_data(s));
+  TLSWrap* w = static_cast<TLSWrap*>(Thin_SSL_get_app_data(s));
   Environment* env = w->env();
   HandleScope handle_scope(env->isolate());
 
@@ -276,8 +276,8 @@ int TLSExtStatusCallback(SSL* s, void* arg) {
   unsigned char* data = MallocOpenSSL<unsigned char>(len);
   obj->CopyContents(data, len);
 
-  if (!SSL_set_tlsext_status_ocsp_resp(s, data, len))
-    OPENSSL_free(data);
+  if (!Thin_SSL_set_tlsext_status_ocsp_resp(s, data, len))
+    Thin_OPENSSL_free(data);
 
   w->ClearOcspResponse();
 
@@ -286,8 +286,8 @@ int TLSExtStatusCallback(SSL* s, void* arg) {
 
 void ConfigureSecureContext(SecureContext* sc) {
   // OCSP stapling
-  SSL_CTX_set_tlsext_status_cb(sc->ctx().get(), TLSExtStatusCallback);
-  SSL_CTX_set_tlsext_status_arg(sc->ctx().get(), nullptr);
+  Thin_SSL_CTX_set_tlsext_status_cb(sc->ctx().get(), TLSExtStatusCallback);
+  Thin_SSL_CTX_set_tlsext_status_arg(sc->ctx().get(), nullptr);
 }
 
 inline bool Set(
@@ -307,7 +307,7 @@ inline bool Set(
 
 std::string GetBIOError() {
   std::string ret;
-  ERR_print_errors_cb(
+  Thin_ERR_print_errors_cb(
       [](const char* str, size_t len, void* opaque) {
         static_cast<std::string*>(opaque)->assign(str, len);
         return 0;
@@ -385,20 +385,20 @@ void TLSWrap::InitSSL() {
   enc_in_ = NodeBIO::New(env()).release();
   enc_out_ = NodeBIO::New(env()).release();
 
-  SSL_set_bio(ssl_.get(), enc_in_, enc_out_);
+  Thin_SSL_set_bio(ssl_.get(), enc_in_, enc_out_);
 
   // NOTE: This could be overridden in SetVerifyMode
-  SSL_set_verify(ssl_.get(), SSL_VERIFY_NONE, VerifyCallback);
+  Thin_SSL_set_verify(ssl_.get(), SSL_VERIFY_NONE, VerifyCallback);
 
 #ifdef SSL_MODE_RELEASE_BUFFERS
-  SSL_set_mode(ssl_.get(), SSL_MODE_RELEASE_BUFFERS);
+  Thin_SSL_set_mode(ssl_.get(), SSL_MODE_RELEASE_BUFFERS);
 #endif  // SSL_MODE_RELEASE_BUFFERS
 
   // This is default in 1.1.1, but set it anyway, Cycle() doesn't currently
-  // re-call ClearIn() if SSL_read() returns SSL_ERROR_WANT_READ, so data can be
+  // re-call ClearIn() if Thin_SSL_read() returns SSL_ERROR_WANT_READ, so data can be
   // left sitting in the incoming enc_in_ and never get processed.
   // - https://wiki.openssl.org/index.php/TLS1.3#Non-application_data_records
-  SSL_set_mode(ssl_.get(), SSL_MODE_AUTO_RETRY);
+  Thin_SSL_set_mode(ssl_.get(), SSL_MODE_AUTO_RETRY);
 
 #ifdef OPENSSL_IS_BORINGSSL
   // OpenSSL allows renegotiation by default, but BoringSSL disables it.
@@ -406,13 +406,13 @@ void TLSWrap::InitSSL() {
   SSL_set_renegotiate_mode(ssl_.get(), ssl_renegotiate_freely);
 #endif
 
-  SSL_set_app_data(ssl_.get(), this);
+  Thin_SSL_set_app_data(ssl_.get(), this);
   // Using InfoCallback isn't how we are supposed to check handshake progress:
   //   https://github.com/openssl/openssl/issues/7199#issuecomment-420915993
   //
   // Note on when this gets called on various openssl versions:
   //   https://github.com/openssl/openssl/issues/7199#issuecomment-420670544
-  SSL_set_info_callback(ssl_.get(), SSLInfoCallback);
+  Thin_SSL_set_info_callback(ssl_.get(), SSLInfoCallback);
 
   if (is_server())
     sc_->SetSelectSNIContextCallback(SelectSNIContextCallback);
@@ -423,14 +423,14 @@ void TLSWrap::InitSSL() {
 
   ConfigureSecureContext(sc_.get());
 
-  SSL_set_cert_cb(ssl_.get(), SSLCertCallback, this);
+  Thin_SSL_set_cert_cb(ssl_.get(), SSLCertCallback, this);
 
   if (is_server()) {
-    SSL_set_accept_state(ssl_.get());
+    Thin_SSL_set_accept_state(ssl_.get());
   } else if (is_client()) {
     // Enough space for server response (hello, cert)
     NodeBIO::FromBIO(enc_in_)->set_initial(kInitialClientBufferLength);
-    SSL_set_connect_state(ssl_.get());
+    Thin_SSL_set_connect_state(ssl_.get());
   } else {
     // Unexpected
     ABORT();
@@ -494,7 +494,7 @@ void TLSWrap::Start(const FunctionCallbackInfo<Value>& args) {
 
   // Send ClientHello handshake
   CHECK(wrap->is_client());
-  // Seems odd to read when when we want to send, but SSL_read() triggers a
+  // Seems odd to read when when we want to send, but Thin_SSL_read() triggers a
   // handshake if a session isn't established, and handshake will cause
   // encrypted data to become available for output.
   wrap->ClearOut();
@@ -505,9 +505,9 @@ void TLSWrap::SSLInfoCallback(const SSL* ssl_, int where, int ret) {
   if (!(where & (SSL_CB_HANDSHAKE_START | SSL_CB_HANDSHAKE_DONE)))
     return;
 
-  // SSL_renegotiate_pending() should take `const SSL*`, but it does not.
+  // Thin_SSL_renegotiate_pending() should take `const SSL*`, but it does not.
   SSL* ssl = const_cast<SSL*>(ssl_);
-  TLSWrap* c = static_cast<TLSWrap*>(SSL_get_app_data(ssl_));
+  TLSWrap* c = static_cast<TLSWrap*>(Thin_SSL_get_app_data(ssl_));
   Environment* env = c->env();
   HandleScope handle_scope(env->isolate());
   Context::Scope context_scope(env->context());
@@ -529,9 +529,9 @@ void TLSWrap::SSLInfoCallback(const SSL* ssl_, int where, int ret) {
   // SSL_CB_HANDSHAKE_START and SSL_CB_HANDSHAKE_DONE are called
   // sending HelloRequest in OpenSSL-1.1.1.
   // We need to check whether this is in a renegotiation state or not.
-  if (where & SSL_CB_HANDSHAKE_DONE && !SSL_renegotiate_pending(ssl)) {
+  if (where & SSL_CB_HANDSHAKE_DONE && !Thin_SSL_renegotiate_pending(ssl)) {
     Debug(c, "SSLInfoCallback(SSL_CB_HANDSHAKE_DONE);");
-    CHECK(!SSL_renegotiate_pending(ssl));
+    CHECK(!Thin_SSL_renegotiate_pending(ssl));
     Local<Value> callback;
 
     c->established_ = true;
@@ -576,7 +576,7 @@ void TLSWrap::EncOut() {
   }
 
   // No encrypted output ready to write to the underlying stream.
-  if (BIO_pending(enc_out_) == 0) {
+  if (Thin_BIO_pending(enc_out_) == 0) {
     Debug(this, "No pending encrypted output");
     if (!pending_cleartext_input_ ||
         pending_cleartext_input_->ByteLength() == 0) {
@@ -586,7 +586,7 @@ void TLSWrap::EncOut() {
       } else {
         Debug(this, "No pending cleartext input, inside DoWrite()");
         // TODO(@sam-github, @addaleax) If in_dowrite_ is true, appdata was
-        // passed to SSL_write().  If we are here, the data was not encrypted to
+        // passed to Thin_SSL_write().  If we are here, the data was not encrypted to
         // enc_out_ yet.  Calling Done() "works", but since the write is not
         // flushed, its too soon.  Just returning and letting the next EncOut()
         // call Done() passes the test suite, but without more careful analysis,
@@ -696,7 +696,7 @@ void TLSWrap::ClearOut() {
   char out[kClearOutChunkSize];
   int read;
   for (;;) {
-    read = SSL_read(ssl_.get(), out, sizeof(out));
+    read = Thin_SSL_read(ssl_.get(), out, sizeof(out));
     Debug(this, "Read %d bytes of cleartext output", read);
 
     if (read <= 0)
@@ -727,14 +727,14 @@ void TLSWrap::ClearOut() {
 
   // We need to check whether an error occurred or the connection was
   // shutdown cleanly (SSL_ERROR_ZERO_RETURN) even when read == 0.
-  // See node#1642 and SSL_read(3SSL) for details. SSL_get_error must be
-  // called immediately after SSL_read, without calling into JS, which may
+  // See node#1642 and Thin_SSL_read(3SSL) for details. Thin_SSL_get_error must be
+  // called immediately after Thin_SSL_read, without calling into JS, which may
   // change OpenSSL's error queue, modify ssl_, or even destroy ssl_
   // altogether.
   if (read <= 0) {
     HandleScope handle_scope(env()->isolate());
     Local<Value> error;
-    int err = SSL_get_error(ssl_.get(), read);
+    int err = Thin_SSL_get_error(ssl_.get(), read);
     switch (err) {
       case SSL_ERROR_ZERO_RETURN:
       case SSL_ERROR_WANT_X509_LOOKUP:
@@ -747,7 +747,7 @@ void TLSWrap::ClearOut() {
       case SSL_ERROR_SSL:
       case SSL_ERROR_SYSCALL:
         {
-          unsigned long ssl_err = ERR_peek_error();  // NOLINT(runtime/int)
+          unsigned long ssl_err = Thin_ERR_peek_error();  // NOLINT(runtime/int)
 
           Local<Context> context = env()->isolate()->GetCurrentContext();
           if (UNLIKELY(context.IsEmpty())) return;
@@ -760,9 +760,9 @@ void TLSWrap::ClearOut() {
           Local<Object> obj;
           if (UNLIKELY(!error->ToObject(context).ToLocal(&obj))) return;
 
-          const char* ls = ERR_lib_error_string(ssl_err);
-          const char* fs = ERR_func_error_string(ssl_err);
-          const char* rs = ERR_reason_error_string(ssl_err);
+          const char* ls = Thin_ERR_lib_error_string(ssl_err);
+          const char* fs = Thin_ERR_func_error_string(ssl_err);
+          const char* rs = Thin_ERR_reason_error_string(ssl_err);
           if (!Set(env(), obj, env()->library_string(), ls) ||
               !Set(env(), obj, env()->function_string(), fs) ||
               !Set(env(), obj, env()->reason_string(), rs, false)) return;
@@ -789,7 +789,7 @@ void TLSWrap::ClearOut() {
     Debug(this, "Got SSL error (%d), calling onerror", err);
     // When TLS Alert are stored in wbio,
     // it should be flushed to socket before destroyed.
-    if (BIO_pending(enc_out_) != 0)
+    if (Thin_BIO_pending(enc_out_) != 0)
       EncOut();
 
     MakeCallback(env()->onerror_string(), 1, &error);
@@ -819,7 +819,7 @@ void TLSWrap::ClearIn() {
   MarkPopErrorOnReturn mark_pop_error_on_return;
 
   NodeBIO::FromBIO(enc_out_)->set_allocate_tls_hint(bs->ByteLength());
-  int written = SSL_write(ssl_.get(), bs->Data(), bs->ByteLength());
+  int written = Thin_SSL_write(ssl_.get(), bs->Data(), bs->ByteLength());
   Debug(this, "Writing %zu bytes, written = %d", bs->ByteLength(), written);
   CHECK(written == -1 || written == static_cast<int>(bs->ByteLength()));
 
@@ -830,7 +830,7 @@ void TLSWrap::ClearIn() {
   }
 
   // Error or partial write
-  int err = SSL_get_error(ssl_.get(), written);
+  int err = Thin_SSL_get_error(ssl_.get(), written);
   if (err == SSL_ERROR_SSL || err == SSL_ERROR_SYSCALL) {
     Debug(this, "Got SSL error (%d)", err);
     write_callback_scheduled_ = true;
@@ -925,7 +925,7 @@ int TLSWrap::DoWrite(WriteWrap* w,
   // We want to trigger a Write() on the underlying stream to drive the stream
   // system, but don't want to encrypt empty buffers into a TLS frame, so see
   // if we can find something to Write().
-  // First, call ClearOut(). It does an SSL_read(), which might cause handshake
+  // First, call ClearOut(). It does an Thin_SSL_read(), which might cause handshake
   // or other internal messages to be encrypted. If it does, write them later
   // with EncOut().
   // If there is still no encrypted output, call Write(bufs) on the underlying
@@ -935,7 +935,7 @@ int TLSWrap::DoWrite(WriteWrap* w,
   if (length == 0) {
     Debug(this, "Empty write");
     ClearOut();
-    if (BIO_pending(enc_out_) == 0) {
+    if (Thin_BIO_pending(enc_out_) == 0) {
       Debug(this, "No pending encrypted output, writing to underlying stream");
       CHECK(!current_empty_write_);
       current_empty_write_.reset(w->GetAsyncWrap());
@@ -987,12 +987,12 @@ int TLSWrap::DoWrite(WriteWrap* w,
     }
 
     NodeBIO::FromBIO(enc_out_)->set_allocate_tls_hint(length);
-    written = SSL_write(ssl_.get(), bs->Data(), length);
+    written = Thin_SSL_write(ssl_.get(), bs->Data(), length);
   } else {
     // Only one buffer: try to write directly, only store if it fails
     uv_buf_t* buf = &bufs[nonempty_i];
     NodeBIO::FromBIO(enc_out_)->set_allocate_tls_hint(buf->len);
-    written = SSL_write(ssl_.get(), buf->base, buf->len);
+    written = Thin_SSL_write(ssl_.get(), buf->base, buf->len);
 
     if (written == -1) {
       NoArrayBufferZeroFillScope no_zero_fill_scope(env()->isolate_data());
@@ -1006,7 +1006,7 @@ int TLSWrap::DoWrite(WriteWrap* w,
 
   if (written == -1) {
     // If we stopped writing because of an error, it's fatal, discard the data.
-    int err = SSL_get_error(ssl_.get(), written);
+    int err = Thin_SSL_get_error(ssl_.get(), written);
     if (err == SSL_ERROR_SSL || err == SSL_ERROR_SYSCALL) {
       // TODO(@jasnell): What are we doing with the error?
       Debug(this, "Got SSL error (%d), returning UV_EPROTO", err);
@@ -1092,8 +1092,8 @@ int TLSWrap::DoShutdown(ShutdownWrap* req_wrap) {
   Debug(this, "DoShutdown()");
   MarkPopErrorOnReturn mark_pop_error_on_return;
 
-  if (ssl_ && SSL_shutdown(ssl_.get()) == 0)
-    SSL_shutdown(ssl_.get());
+  if (ssl_ && Thin_SSL_shutdown(ssl_.get()) == 0)
+    Thin_SSL_shutdown(ssl_.get());
 
   shutdown_ = true;
   EncOut();
@@ -1129,7 +1129,7 @@ void TLSWrap::SetVerifyMode(const FunctionCallbackInfo<Value>& args) {
   }
 
   // Always allow a connection. We'll reject in javascript.
-  SSL_set_verify(wrap->ssl_.get(), verify_mode, VerifyCallback);
+  Thin_SSL_set_verify(wrap->ssl_.get(), verify_mode, VerifyCallback);
 }
 
 void TLSWrap::EnableSessionCallbacks(const FunctionCallbackInfo<Value>& args) {
@@ -1156,8 +1156,8 @@ void TLSWrap::EnableKeylogCallback(const FunctionCallbackInfo<Value>& args) {
 }
 
 // Check required capabilities were not excluded from the OpenSSL build:
-// - OPENSSL_NO_SSL_TRACE excludes SSL_trace()
-// - OPENSSL_NO_STDIO excludes BIO_new_fp()
+// - OPENSSL_NO_SSL_TRACE excludes Thin_SSL_trace()
+// - OPENSSL_NO_STDIO excludes Thin_BIO_new_fp()
 // HAVE_SSL_TRACE is available on the internal tcp_wrap binding for the tests.
 #if defined(OPENSSL_NO_SSL_TRACE) || defined(OPENSSL_NO_STDIO)
 # define HAVE_SSL_TRACE 0
@@ -1171,19 +1171,19 @@ void TLSWrap::EnableTrace(const FunctionCallbackInfo<Value>& args) {
 
 #if HAVE_SSL_TRACE
   if (wrap->ssl_) {
-    wrap->bio_trace_.reset(BIO_new_fp(stderr,  BIO_NOCLOSE | BIO_FP_TEXT));
-    SSL_set_msg_callback(wrap->ssl_.get(), [](int write_p, int version, int
+    wrap->bio_trace_.reset(Thin_BIO_new_fp(stderr,  BIO_NOCLOSE | BIO_FP_TEXT));
+    Thin_SSL_set_msg_callback(wrap->ssl_.get(), [](int write_p, int version, int
           content_type, const void* buf, size_t len, SSL* ssl, void* arg)
         -> void {
-        // BIO_write(), etc., called by SSL_trace, may error. The error should
+        // Thin_BIO_write(), etc., called by Thin_SSL_trace, may error. The error should
         // be ignored, trace is a "best effort", and its usually because stderr
         // is a non-blocking pipe, and its buffer has overflowed. Leaving errors
         // on the stack that can get picked up by later SSL_ calls causes
         // unwanted failures in SSL_ calls, so keep the error stack unchanged.
         MarkPopErrorOnReturn mark_pop_error_on_return;
-        SSL_trace(write_p,  version, content_type, buf, len, ssl, arg);
+        Thin_SSL_trace(write_p,  version, content_type, buf, len, ssl, arg);
     });
-    SSL_set_msg_callback_arg(wrap->ssl_.get(), wrap->bio_trace_.get());
+    Thin_SSL_set_msg_callback_arg(wrap->ssl_.get(), wrap->bio_trace_.get());
   }
 #endif
 }
@@ -1264,11 +1264,11 @@ void TLSWrap::SetServername(const FunctionCallbackInfo<Value>& args) {
   CHECK(wrap->ssl_);
 
   Utf8Value servername(env->isolate(), args[0].As<String>());
-  SSL_set_tlsext_host_name(wrap->ssl_.get(), *servername);
+  Thin_SSL_set_tlsext_host_name(wrap->ssl_.get(), *servername);
 }
 
 int TLSWrap::SelectSNIContextCallback(SSL* s, int* ad, void* arg) {
-  TLSWrap* p = static_cast<TLSWrap*>(SSL_get_app_data(s));
+  TLSWrap* p = static_cast<TLSWrap*>(Thin_SSL_get_app_data(s));
   Environment* env = p->env();
   HandleScope handle_scope(env->isolate());
   Context::Scope context_scope(env->context());
@@ -1295,14 +1295,14 @@ int TLSWrap::SelectSNIContextCallback(SSL* s, int* ad, void* arg) {
   p->sni_context_ = BaseObjectPtr<SecureContext>(sc);
 
   ConfigureSecureContext(sc);
-  CHECK_EQ(SSL_set_SSL_CTX(p->ssl_.get(), sc->ctx().get()), sc->ctx().get());
+  CHECK_EQ(Thin_SSL_set_SSL_CTX(p->ssl_.get(), sc->ctx().get()), sc->ctx().get());
   p->SetCACerts(sc);
 
   return SSL_TLSEXT_ERR_OK;
 }
 
 int TLSWrap::SelectClientCertCallback(SSL* s, X509 **cert, EVP_PKEY ** key) {
-  TLSWrap* p = static_cast<TLSWrap*>(SSL_get_app_data(s));
+  TLSWrap* p = static_cast<TLSWrap*>(Thin_SSL_get_app_data(s));
   if (!p->is_client())
     return 0;
 
@@ -1318,12 +1318,12 @@ int TLSWrap::SelectClientCertCallback(SSL* s, X509 **cert, EVP_PKEY ** key) {
 
   Local<Array> distinguishedNames = Array::New(env->isolate());
   char buf[BUFSIZ];
-  STACK_OF(X509_NAME) * sk = SSL_get_client_CA_list(s);
+  STACK_OF(X509_NAME) * sk = Thin_SSL_get_client_CA_list(s);
   X509_NAME *name;
-  if (sk != NULL && (sk_X509_NAME_num(sk) > 0)) {
-    for (int i = 0; i < sk_X509_NAME_num(sk); i++) {
-      name = sk_X509_NAME_value(sk, i);
-      X509_NAME_oneline(name, buf, sizeof(buf));
+  if (sk != NULL && (Thin_sk_X509_NAME_num(sk) > 0)) {
+    for (int i = 0; i < Thin_sk_X509_NAME_num(sk); i++) {
+      name = Thin_sk_X509_NAME_value(sk, i);
+      Thin_X509_NAME_oneline(name, buf, sizeof(buf));
       distinguishedNames->Set(env->context(), i, OneByteString(env->isolate(), buf)).Check();
     }
   }
@@ -1340,16 +1340,16 @@ int TLSWrap::SelectClientCertCallback(SSL* s, X509 **cert, EVP_PKEY ** key) {
 }
 
 int TLSWrap::SetCACerts(SecureContext* sc) {
-  int err = SSL_set1_verify_cert_store(ssl_.get(),
-                                       SSL_CTX_get_cert_store(sc->ctx().get()));
+  int err = Thin_SSL_set1_verify_cert_store(ssl_.get(),
+                                       Thin_SSL_CTX_get_cert_store(sc->ctx().get()));
   if (err != 1)
     return err;
 
   STACK_OF(X509_NAME)* list =
-      SSL_dup_CA_list(SSL_CTX_get_client_CA_list(sc->ctx().get()));
+      Thin_SSL_dup_CA_list(Thin_SSL_CTX_get_client_CA_list(sc->ctx().get()));
 
-  // NOTE: `SSL_set_client_CA_list` takes the ownership of `list`
-  SSL_set_client_CA_list(ssl_.get(), list);
+  // NOTE: `Thin_SSL_set_client_CA_list` takes the ownership of `list`
+  Thin_SSL_set_client_CA_list(ssl_.get(), list);
   return 1;
 }
 
@@ -1366,7 +1366,7 @@ void TLSWrap::SetPskIdentityHint(const FunctionCallbackInfo<Value>& args) {
   CHECK(args[0]->IsString());
   Utf8Value hint(isolate, args[0].As<String>());
 
-  if (!SSL_use_psk_identity_hint(p->ssl_.get(), *hint)) {
+  if (!Thin_SSL_use_psk_identity_hint(p->ssl_.get(), *hint)) {
     Local<Value> err = node::ERR_TLS_PSK_SET_IDENTIY_HINT_FAILED(isolate);
     p->MakeCallback(env->onerror_string(), 1, &err);
   }
@@ -1377,8 +1377,8 @@ void TLSWrap::EnablePskCallback(const FunctionCallbackInfo<Value>& args) {
   ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
   CHECK_NOT_NULL(wrap->ssl_);
 
-  SSL_set_psk_server_callback(wrap->ssl_.get(), PskServerCallback);
-  SSL_set_psk_client_callback(wrap->ssl_.get(), PskClientCallback);
+  Thin_SSL_set_psk_server_callback(wrap->ssl_.get(), PskServerCallback);
+  Thin_SSL_set_psk_client_callback(wrap->ssl_.get(), PskClientCallback);
 }
 
 unsigned int TLSWrap::PskServerCallback(
@@ -1386,7 +1386,7 @@ unsigned int TLSWrap::PskServerCallback(
     const char* identity,
     unsigned char* psk,
     unsigned int max_psk_len) {
-  TLSWrap* p = static_cast<TLSWrap*>(SSL_get_app_data(s));
+  TLSWrap* p = static_cast<TLSWrap*>(Thin_SSL_get_app_data(s));
 
   Environment* env = p->env();
   HandleScope scope(env->isolate());
@@ -1428,7 +1428,7 @@ unsigned int TLSWrap::PskClientCallback(
     unsigned int max_identity_len,
     unsigned char* psk,
     unsigned int max_psk_len) {
-  TLSWrap* p = static_cast<TLSWrap*>(SSL_get_app_data(s));
+  TLSWrap* p = static_cast<TLSWrap*>(Thin_SSL_get_app_data(s));
 
   Environment* env = p->env();
   HandleScope scope(env->isolate());
@@ -1490,7 +1490,7 @@ void TLSWrap::GetWriteQueueSize(const FunctionCallbackInfo<Value>& info) {
   if (!wrap->ssl_)
     return info.GetReturnValue().Set(0);
 
-  uint32_t write_queue_size = BIO_pending(wrap->enc_out_);
+  uint32_t write_queue_size = Thin_BIO_pending(wrap->enc_out_);
   info.GetReturnValue().Set(write_queue_size);
 }
 
@@ -1529,7 +1529,7 @@ void TLSWrap::CertCbDone(const FunctionCallbackInfo<Value>& args) {
     if (UseSNIContext(w->ssl_, w->sni_context_) && !w->SetCACerts(sc)) {
       // Not clear why sometimes we throw error, and sometimes we call
       // onerror(). Both cause .destroy(), but onerror does a bit more.
-      unsigned long err = ERR_get_error();  // NOLINT(runtime/int)
+      unsigned long err = Thin_ERR_get_error();  // NOLINT(runtime/int)
       return ThrowCryptoError(env, err, "CertCbDone");
     }
   } else if (ctx->IsObject()) {
@@ -1562,11 +1562,11 @@ void TLSWrap::SetALPNProtocols(const FunctionCallbackInfo<Value>& args) {
   ArrayBufferViewContents<uint8_t> protos(args[0].As<ArrayBufferView>());
   SSL* ssl = w->ssl_.get();
   if (w->is_client()) {
-    CHECK_EQ(0, SSL_set_alpn_protos(ssl, protos.data(), protos.length()));
+    CHECK_EQ(0, Thin_SSL_set_alpn_protos(ssl, protos.data(), protos.length()));
   } else {
     w->alpn_protos_ = std::vector<unsigned char>(
         protos.data(), protos.data() + protos.length());
-    SSL_CTX_set_alpn_select_cb(SSL_get_SSL_CTX(ssl), SelectALPNCallback, w);
+    Thin_SSL_CTX_set_alpn_select_cb(Thin_SSL_get_SSL_CTX(ssl), SelectALPNCallback, w);
   }
 }
 
@@ -1625,13 +1625,13 @@ void TLSWrap::GetFinished(const FunctionCallbackInfo<Value>& args) {
   TLSWrap* w;
   ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
 
-  // We cannot just pass nullptr to SSL_get_finished()
+  // We cannot just pass nullptr to Thin_SSL_get_finished()
   // because it would further be propagated to memcpy(),
   // where the standard requirements as described in ISO/IEC 9899:2011
   // sections 7.21.2.1, 7.21.1.2, and 7.1.4, would be violated.
   // Thus, we use a dummy byte.
   char dummy[1];
-  size_t len = SSL_get_finished(w->ssl_.get(), dummy, sizeof dummy);
+  size_t len = Thin_SSL_get_finished(w->ssl_.get(), dummy, sizeof dummy);
   if (len == 0)
     return;
 
@@ -1642,7 +1642,7 @@ void TLSWrap::GetFinished(const FunctionCallbackInfo<Value>& args) {
   }
 
   CHECK_EQ(bs->ByteLength(),
-           SSL_get_finished(w->ssl_.get(), bs->Data(), bs->ByteLength()));
+           Thin_SSL_get_finished(w->ssl_.get(), bs->Data(), bs->ByteLength()));
 
   Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
   Local<Value> buffer;
@@ -1656,13 +1656,13 @@ void TLSWrap::GetPeerFinished(const FunctionCallbackInfo<Value>& args) {
   TLSWrap* w;
   ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
 
-  // We cannot just pass nullptr to SSL_get_peer_finished()
+  // We cannot just pass nullptr to Thin_SSL_get_peer_finished()
   // because it would further be propagated to memcpy(),
   // where the standard requirements as described in ISO/IEC 9899:2011
   // sections 7.21.2.1, 7.21.1.2, and 7.1.4, would be violated.
   // Thus, we use a dummy byte.
   char dummy[1];
-  size_t len = SSL_get_peer_finished(w->ssl_.get(), dummy, sizeof dummy);
+  size_t len = Thin_SSL_get_peer_finished(w->ssl_.get(), dummy, sizeof dummy);
   if (len == 0)
     return;
 
@@ -1673,7 +1673,7 @@ void TLSWrap::GetPeerFinished(const FunctionCallbackInfo<Value>& args) {
   }
 
   CHECK_EQ(bs->ByteLength(),
-           SSL_get_peer_finished(w->ssl_.get(), bs->Data(), bs->ByteLength()));
+           Thin_SSL_get_peer_finished(w->ssl_.get(), bs->Data(), bs->ByteLength()));
 
   Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
   Local<Value> buffer;
@@ -1687,11 +1687,11 @@ void TLSWrap::GetSession(const FunctionCallbackInfo<Value>& args) {
   TLSWrap* w;
   ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
 
-  SSL_SESSION* sess = SSL_get_session(w->ssl_.get());
+  SSL_SESSION* sess = Thin_SSL_get_session(w->ssl_.get());
   if (sess == nullptr)
     return;
 
-  int slen = i2d_SSL_SESSION(sess, nullptr);
+  int slen = Thin_i2d_SSL_SESSION(sess, nullptr);
   if (slen <= 0)
     return;  // Invalid or malformed session.
 
@@ -1702,7 +1702,7 @@ void TLSWrap::GetSession(const FunctionCallbackInfo<Value>& args) {
   }
 
   unsigned char* p = static_cast<unsigned char*>(bs->Data());
-  CHECK_LT(0, i2d_SSL_SESSION(sess, &p));
+  CHECK_LT(0, Thin_i2d_SSL_SESSION(sess, &p));
 
   Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
   Local<Value> buffer;
@@ -1726,13 +1726,13 @@ void TLSWrap::SetSession(const FunctionCallbackInfo<Value>& args) {
     return;  // TODO(tniessen): figure out error handling
 
   if (!SetTLSSession(w->ssl_, sess))
-    return env->ThrowError("SSL_set_session error");
+    return env->ThrowError("Thin_SSL_set_session error");
 }
 
 void TLSWrap::IsSessionReused(const FunctionCallbackInfo<Value>& args) {
   TLSWrap* w;
   ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
-  bool yes = SSL_session_reused(w->ssl_.get());
+  bool yes = Thin_SSL_session_reused(w->ssl_.get());
   args.GetReturnValue().Set(yes);
 }
 
@@ -1752,7 +1752,7 @@ void TLSWrap::VerifyError(const FunctionCallbackInfo<Value>& args) {
   if (x509_verify_error == X509_V_OK)
     return args.GetReturnValue().SetNull();
 
-  const char* reason = X509_verify_cert_error_string(x509_verify_error);
+  const char* reason = Thin_X509_verify_cert_error_string(x509_verify_error);
   const char* code = X509ErrorCode(x509_verify_error);
 
   Local<Object> error =
@@ -1781,7 +1781,7 @@ void TLSWrap::LoadSession(const FunctionCallbackInfo<Value>& args) {
     ArrayBufferViewContents<unsigned char> sbuf(args[0]);
 
     const unsigned char* p = sbuf.data();
-    SSL_SESSION* sess = d2i_SSL_SESSION(nullptr, &p, sbuf.length());
+    SSL_SESSION* sess = Thin_d2i_SSL_SESSION(nullptr, &p, sbuf.length());
 
     // Setup next session and move hello to the BIO buffer
     w->next_sess_.reset(sess);
@@ -1794,7 +1794,7 @@ void TLSWrap::GetSharedSigalgs(const FunctionCallbackInfo<Value>& args) {
   ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
 
   SSL* ssl = w->ssl_.get();
-  int nsig = SSL_get_shared_sigalgs(ssl, 0, nullptr, nullptr, nullptr, nullptr,
+  int nsig = Thin_SSL_get_shared_sigalgs(ssl, 0, nullptr, nullptr, nullptr, nullptr,
                                     nullptr);
   MaybeStackBuffer<Local<Value>, 16> ret_arr(nsig);
 
@@ -1803,7 +1803,7 @@ void TLSWrap::GetSharedSigalgs(const FunctionCallbackInfo<Value>& args) {
     int sign_nid;
     std::string sig_with_md;
 
-    SSL_get_shared_sigalgs(ssl, i, &sign_nid, &hash_nid, nullptr, nullptr,
+    Thin_SSL_get_shared_sigalgs(ssl, i, &sign_nid, &hash_nid, nullptr, nullptr,
                            nullptr);
 
     switch (sign_nid) {
@@ -1844,7 +1844,7 @@ void TLSWrap::GetSharedSigalgs(const FunctionCallbackInfo<Value>& args) {
         break;
 #endif  // !OPENSSL_NO_GOST
       default:
-        const char* sn = OBJ_nid2sn(sign_nid);
+        const char* sn = Thin_OBJ_nid2sn(sign_nid);
 
         if (sn != nullptr) {
           sig_with_md = std::string(sn) + "+";
@@ -1854,7 +1854,7 @@ void TLSWrap::GetSharedSigalgs(const FunctionCallbackInfo<Value>& args) {
         break;
     }
 
-    const char* sn_hash = OBJ_nid2sn(hash_nid);
+    const char* sn_hash = Thin_OBJ_nid2sn(hash_nid);
     if (sn_hash != nullptr) {
       sig_with_md += std::string(sn_hash);
     } else {
@@ -1889,7 +1889,7 @@ void TLSWrap::ExportKeyingMaterial(const FunctionCallbackInfo<Value>& args) {
   if (use_context)
     context = ByteSource::FromBuffer(args[2]);
 
-  if (SSL_export_keying_material(
+  if (Thin_SSL_export_keying_material(
           w->ssl_.get(),
           static_cast<unsigned char*>(bs->Data()),
           olen,
@@ -1900,8 +1900,8 @@ void TLSWrap::ExportKeyingMaterial(const FunctionCallbackInfo<Value>& args) {
           use_context) != 1) {
     return ThrowCryptoError(
          env,
-         ERR_get_error(),
-         "SSL_export_keying_material");
+         Thin_ERR_get_error(),
+         "Thin_SSL_export_keying_material");
   }
 
   Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
@@ -1920,8 +1920,8 @@ void TLSWrap::Renegotiate(const FunctionCallbackInfo<Value>& args) {
   TLSWrap* w;
   ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
   ClearErrorOnReturn clear_error_on_return;
-  if (SSL_renegotiate(w->ssl_.get()) != 1)
-    return ThrowCryptoError(w->env(), ERR_get_error());
+  if (Thin_SSL_renegotiate(w->ssl_.get()) != 1)
+    return ThrowCryptoError(w->env(), Thin_ERR_get_error());
 }
 
 void TLSWrap::GetTLSTicket(const FunctionCallbackInfo<Value>& args) {
@@ -1929,13 +1929,13 @@ void TLSWrap::GetTLSTicket(const FunctionCallbackInfo<Value>& args) {
   ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
   Environment* env = w->env();
 
-  SSL_SESSION* sess = SSL_get_session(w->ssl_.get());
+  SSL_SESSION* sess = Thin_SSL_get_session(w->ssl_.get());
   if (sess == nullptr)
     return;
 
   const unsigned char* ticket;
   size_t length;
-  SSL_SESSION_get0_ticket(sess, &ticket, &length);
+  Thin_SSL_SESSION_get0_ticket(sess, &ticket, &length);
 
   if (ticket != nullptr) {
     args.GetReturnValue().Set(
@@ -1968,7 +1968,7 @@ void TLSWrap::RequestOCSP(const FunctionCallbackInfo<Value>& args) {
   TLSWrap* w;
   ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
 
-  SSL_set_tlsext_status_type(w->ssl_.get(), TLSEXT_STATUSTYPE_ocsp);
+  Thin_SSL_set_tlsext_status_type(w->ssl_.get(), TLSEXT_STATUSTYPE_ocsp);
 }
 
 void TLSWrap::GetEphemeralKeyInfo(const FunctionCallbackInfo<Value>& args) {
@@ -1986,7 +1986,7 @@ void TLSWrap::GetEphemeralKeyInfo(const FunctionCallbackInfo<Value>& args) {
       .FromMaybe(Local<Value>()));
 
   // TODO(@sam-github) semver-major: else return ThrowCryptoError(env,
-  // ERR_get_error())
+  // Thin_ERR_get_error())
 }
 
 void TLSWrap::GetProtocol(const FunctionCallbackInfo<Value>& args) {
@@ -1994,7 +1994,7 @@ void TLSWrap::GetProtocol(const FunctionCallbackInfo<Value>& args) {
   TLSWrap* w;
   ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
   args.GetReturnValue().Set(
-      OneByteString(env->isolate(), SSL_get_version(w->ssl_.get())));
+      OneByteString(env->isolate(), Thin_SSL_get_version(w->ssl_.get())));
 }
 
 void TLSWrap::GetALPNNegotiatedProto(const FunctionCallbackInfo<Value>& args) {
@@ -2005,7 +2005,7 @@ void TLSWrap::GetALPNNegotiatedProto(const FunctionCallbackInfo<Value>& args) {
   const unsigned char* alpn_proto;
   unsigned int alpn_proto_len;
 
-  SSL_get0_alpn_selected(w->ssl_.get(), &alpn_proto, &alpn_proto_len);
+  Thin_SSL_get0_alpn_selected(w->ssl_.get(), &alpn_proto, &alpn_proto_len);
 
   Local<Value> result;
   if (alpn_proto_len == 0) {
@@ -2036,18 +2036,18 @@ void TLSWrap::Cycle() {
   }
 }
 
-#ifdef SSL_set_max_send_fragment
+#ifdef Thin_SSL_set_max_send_fragment
 void TLSWrap::SetMaxSendFragment(const FunctionCallbackInfo<Value>& args) {
   CHECK(args.Length() >= 1 && args[0]->IsNumber());
   Environment* env = Environment::GetCurrent(args);
   TLSWrap* w;
   ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
-  int rv = SSL_set_max_send_fragment(
+  int rv = Thin_SSL_set_max_send_fragment(
       w->ssl_.get(),
       args[0]->Int32Value(env->context()).FromJust());
   args.GetReturnValue().Set(rv);
 }
-#endif  // SSL_set_max_send_fragment
+#endif  // Thin_SSL_set_max_send_fragment
 
 void TLSWrap::Initialize(
     Local<Object> target,
@@ -2123,9 +2123,9 @@ void TLSWrap::Initialize(
   SetProtoMethodNoSideEffect(isolate, t, "getTLSTicket", GetTLSTicket);
   SetProtoMethodNoSideEffect(isolate, t, "verifyError", VerifyError);
 
-#ifdef SSL_set_max_send_fragment
+#ifdef Thin_SSL_set_max_send_fragment
   SetProtoMethod(isolate, t, "setMaxSendFragment", SetMaxSendFragment);
-#endif  // SSL_set_max_send_fragment
+#endif  // Thin_SSL_set_max_send_fragment
 
 #ifndef OPENSSL_NO_PSK
   SetProtoMethod(isolate, t, "enablePskCallback", EnablePskCallback);
@@ -2181,9 +2181,9 @@ void TLSWrap::RegisterExternalReferences(ExternalReferenceRegistry* registry) {
   registry->Register(GetTLSTicket);
   registry->Register(VerifyError);
 
-#ifdef SSL_set_max_send_fragment
+#ifdef Thin_SSL_set_max_send_fragment
   registry->Register(SetMaxSendFragment);
-#endif  // SSL_set_max_send_fragment
+#endif  // Thin_SSL_set_max_send_fragment
 
 #ifndef OPENSSL_NO_PSK
   registry->Register(EnablePskCallback);
diff --git a/src/crypto/crypto_tls.h b/src/crypto/crypto_tls.h
index b2c9a70e40..bc0bd637c5 100644
--- a/src/crypto/crypto_tls.h
+++ b/src/crypto/crypto_tls.h
@@ -147,15 +147,15 @@ class TLSWrap : public AsyncWrap,
   // EncIn() doesn't exist. Encrypted data is pushed from underlying stream into
   // enc_in_ via the stream listener's OnStreamAlloc()/OnStreamRead() interface.
   void EncOut();  // Write encrypted data from enc_out_ to underlying stream.
-  void ClearIn();  // SSL_write() clear data "in" to SSL.
-  void ClearOut();  // SSL_read() clear text "out" from SSL.
+  void ClearIn();  // Thin_SSL_write() clear data "in" to SSL.
+  void ClearOut();  // Thin_SSL_read() clear text "out" from SSL.
   void Destroy();
 
   // Call Done() on outstanding WriteWrap request.
   void InvokeQueued(int status, const char* error_str = nullptr);
 
-  // Drive the SSL state machine by attempting to SSL_read() and SSL_write() to
-  // it. Transparent handshakes mean SSL_read() might trigger I/O on the
+  // Drive the SSL state machine by attempting to Thin_SSL_read() and Thin_SSL_write() to
+  // it. Transparent handshakes mean Thin_SSL_read() might trigger I/O on the
   // underlying stream even if there is no clear text to read or write.
   void Cycle();
 
@@ -217,10 +217,10 @@ class TLSWrap : public AsyncWrap,
   static void VerifyError(const v8::FunctionCallbackInfo<v8::Value>& args);
   static void Wrap(const v8::FunctionCallbackInfo<v8::Value>& args);
 
-#ifdef SSL_set_max_send_fragment
+#ifdef Thin_SSL_set_max_send_fragment
   static void SetMaxSendFragment(
       const v8::FunctionCallbackInfo<v8::Value>& args);
-#endif  // SSL_set_max_send_fragment
+#endif  // Thin_SSL_set_max_send_fragment
 
 #ifndef OPENSSL_NO_PSK
   static void EnablePskCallback(
@@ -249,9 +249,9 @@ class TLSWrap : public AsyncWrap,
   BaseObjectPtr<SecureContext> sc_;
 
   // BIO buffers hold encrypted data.
-  BIO* enc_in_ = nullptr;   // StreamListener fills this for SSL_read().
-  BIO* enc_out_ = nullptr;  // SSL_write()/handshake fills this for EncOut().
-  // Waiting for ClearIn() to pass to SSL_write().
+  BIO* enc_in_ = nullptr;   // StreamListener fills this for Thin_SSL_read().
+  BIO* enc_out_ = nullptr;  // Thin_SSL_write()/handshake fills this for EncOut().
+  // Waiting for ClearIn() to pass to Thin_SSL_write().
   std::unique_ptr<v8::BackingStore> pending_cleartext_input_;
   size_t write_size_ = 0;
   BaseObjectPtr<AsyncWrap> current_write_;
@@ -277,7 +277,7 @@ class TLSWrap : public AsyncWrap,
 
   int cycle_depth_ = 0;
 
-  // SSL_set_cert_cb
+  // Thin_SSL_set_cert_cb
   CertCb cert_cb_ = nullptr;
   void* cert_cb_arg_ = nullptr;
 
diff --git a/src/crypto/crypto_util.cc b/src/crypto/crypto_util.cc
index 519c0a52b7..e13b04e351 100644
--- a/src/crypto/crypto_util.cc
+++ b/src/crypto/crypto_util.cc
@@ -50,7 +50,7 @@ int VerifyCallback(int preverify_ok, X509_STORE_CTX* ctx) {
   //   VerifyCallback always returns 1, the TLS/SSL handshake will not be
   //   terminated with respect to verification failures and the connection will
   //   be established. The calling process can however retrieve the error code
-  //   of the last verification error using SSL_get_verify_result(3) or by
+  //   of the last verification error using Thin_SSL_get_verify_result(3) or by
   //   maintaining its own error storage managed by VerifyCallback.
   //
   // Since we cannot perform I/O quickly enough with X509_STORE_CTX_ APIs in
@@ -62,13 +62,13 @@ int VerifyCallback(int preverify_ok, X509_STORE_CTX* ctx) {
 
 MUST_USE_RESULT CSPRNGResult CSPRNG(void* buffer, size_t length) {
   do {
-    if (1 == RAND_status())
-      if (1 == RAND_bytes(static_cast<unsigned char*>(buffer), length))
+    if (1 == Thin_RAND_status())
+      if (1 == Thin_RAND_bytes(static_cast<unsigned char*>(buffer), length))
         return {true};
 #if OPENSSL_VERSION_MAJOR >= 3
-    const auto code = ERR_peek_last_error();
-    // A misconfigured OpenSSL 3 installation may report 1 from RAND_poll()
-    // and RAND_status() but fail in RAND_bytes() if it cannot look up
+    const auto code = Thin_ERR_peek_last_error();
+    // A misconfigured OpenSSL 3 installation may report 1 from Thin_RAND_poll()
+    // and Thin_RAND_status() but fail in Thin_RAND_bytes() if it cannot look up
     // a matching algorithm for the CSPRNG.
     if (ERR_GET_LIB(code) == ERR_LIB_RAND) {
       const auto reason = ERR_GET_REASON(code);
@@ -79,7 +79,7 @@ MUST_USE_RESULT CSPRNGResult CSPRNG(void* buffer, size_t length) {
       }
     }
 #endif
-  } while (1 == RAND_poll());
+  } while (1 == Thin_RAND_poll());
 
   return {false};
 }
@@ -112,15 +112,15 @@ bool ProcessFipsOptions() {
   if (per_process::cli_options->enable_fips_crypto ||
       per_process::cli_options->force_fips_crypto) {
 #if OPENSSL_VERSION_MAJOR >= 3
-    OSSL_PROVIDER* fips_provider = OSSL_PROVIDER_load(nullptr, "fips");
+    OSSL_PROVIDER* fips_provider = Thin_OSSL_PROVIDER_load(nullptr, "fips");
     if (fips_provider == nullptr)
       return false;
-    OSSL_PROVIDER_unload(fips_provider);
+    Thin_OSSL_PROVIDER_unload(fips_provider);
 
-    return EVP_default_properties_enable_fips(nullptr, 1) &&
-           EVP_default_properties_is_fips_enabled(nullptr);
+    return Thin_EVP_default_properties_enable_fips(nullptr, 1) &&
+           Thin_EVP_default_properties_is_fips_enabled(nullptr);
 #else
-    if (FIPS_mode() == 0) return FIPS_mode_set(1);
+    if (Thin_FIPS_mode() == 0) return Thin_FIPS_mode_set(1);
 
 #endif
   }
@@ -146,33 +146,33 @@ void InitCryptoOnce() {
   Mutex::ScopedLock lock(per_process::cli_options_mutex);
   Mutex::ScopedLock fips_lock(fips_mutex);
 #ifndef OPENSSL_IS_BORINGSSL
-  OPENSSL_INIT_SETTINGS* settings = OPENSSL_INIT_new();
+  OPENSSL_INIT_SETTINGS* settings = Thin_OPENSSL_INIT_new();
 
 #if OPENSSL_VERSION_MAJOR < 3
   // --openssl-config=...
   if (!per_process::cli_options->openssl_config.empty()) {
     const char* conf = per_process::cli_options->openssl_config.c_str();
-    OPENSSL_INIT_set_config_filename(settings, conf);
+    Thin_OPENSSL_INIT_set_config_filename(settings, conf);
   }
 #endif
 
 #if OPENSSL_VERSION_MAJOR >= 3
   // --openssl-legacy-provider
   if (per_process::cli_options->openssl_legacy_provider) {
-    OSSL_PROVIDER* legacy_provider = OSSL_PROVIDER_load(nullptr, "legacy");
+    OSSL_PROVIDER* legacy_provider = Thin_OSSL_PROVIDER_load(nullptr, "legacy");
     if (legacy_provider == nullptr) {
       fprintf(stderr, "Unable to load legacy provider.\n");
     }
   }
 #endif
 
-  OPENSSL_init_ssl(0, settings);
-  OPENSSL_INIT_free(settings);
+  Thin_OPENSSL_init_ssl(0, settings);
+  Thin_OPENSSL_INIT_free(settings);
   settings = nullptr;
 
 #ifndef _WIN32
   if (per_process::cli_options->secure_heap != 0) {
-    switch (CRYPTO_secure_malloc_init(
+    switch (Thin_CRYPTO_secure_malloc_init(
                 per_process::cli_options->secure_heap,
                 static_cast<int>(per_process::cli_options->secure_heap_min))) {
       case 0:
@@ -193,11 +193,11 @@ void InitCryptoOnce() {
 
   // Turn off compression. Saves memory and protects against CRIME attacks.
   // No-op with OPENSSL_NO_COMP builds of OpenSSL.
-  sk_SSL_COMP_zero(SSL_COMP_get_compression_methods());
+  Thin_sk_SSL_COMP_zero(Thin_SSL_COMP_get_compression_methods());
 
 #ifndef OPENSSL_NO_ENGINE
-  ERR_load_ENGINE_strings();
-  ENGINE_load_builtin_engines();
+  Thin_ERR_load_ENGINE_strings();
+  Thin_ENGINE_load_builtin_engines();
 #endif  // !OPENSSL_NO_ENGINE
 }
 
@@ -206,10 +206,10 @@ void GetFipsCrypto(const FunctionCallbackInfo<Value>& args) {
   Mutex::ScopedLock fips_lock(fips_mutex);
 
 #if OPENSSL_VERSION_MAJOR >= 3
-  args.GetReturnValue().Set(EVP_default_properties_is_fips_enabled(nullptr) ?
+  args.GetReturnValue().Set(Thin_EVP_default_properties_is_fips_enabled(nullptr) ?
       1 : 0);
 #else
-  args.GetReturnValue().Set(FIPS_mode() ? 1 : 0);
+  args.GetReturnValue().Set(Thin_FIPS_mode() ? 1 : 0);
 #endif
 }
 
@@ -224,18 +224,18 @@ void SetFipsCrypto(const FunctionCallbackInfo<Value>& args) {
   bool enable = args[0]->BooleanValue(env->isolate());
 
 #if OPENSSL_VERSION_MAJOR >= 3
-  if (enable == EVP_default_properties_is_fips_enabled(nullptr))
+  if (enable == Thin_EVP_default_properties_is_fips_enabled(nullptr))
 #else
-  if (static_cast<int>(enable) == FIPS_mode())
+  if (static_cast<int>(enable) == Thin_FIPS_mode())
 #endif
     return;  // No action needed.
 
 #if OPENSSL_VERSION_MAJOR >= 3
-  if (!EVP_default_properties_enable_fips(nullptr, enable)) {
+  if (!Thin_EVP_default_properties_enable_fips(nullptr, enable)) {
 #else
-  if (!FIPS_mode_set(enable)) {
+  if (!Thin_FIPS_mode_set(enable)) {
 #endif
-    unsigned long err = ERR_get_error();  // NOLINT(runtime/int)
+    unsigned long err = Thin_ERR_get_error();  // NOLINT(runtime/int)
     return ThrowCryptoError(env, err);
   }
 }
@@ -248,7 +248,7 @@ void TestFipsCrypto(const v8::FunctionCallbackInfo<v8::Value>& args) {
 #if OPENSSL_VERSION_MAJOR >= 3
   OSSL_PROVIDER* fips_provider = nullptr;
   if (OSSL_PROVIDER_available(nullptr, "fips")) {
-    fips_provider = OSSL_PROVIDER_load(nullptr, "fips");
+    fips_provider = Thin_OSSL_PROVIDER_load(nullptr, "fips");
   }
   const auto enabled = fips_provider == nullptr ? 0 :
       OSSL_PROVIDER_self_test(fips_provider) ? 1 : 0;
@@ -264,9 +264,9 @@ void TestFipsCrypto(const v8::FunctionCallbackInfo<v8::Value>& args) {
 
 void CryptoErrorStore::Capture() {
   errors_.clear();
-  while (const uint32_t err = ERR_get_error()) {
+  while (const uint32_t err = Thin_ERR_get_error()) {
     char buf[256];
-    ERR_error_string_n(err, buf, sizeof(buf));
+    Thin_ERR_error_string_n(err, buf, sizeof(buf));
     errors_.emplace_back(buf);
   }
   std::reverse(std::begin(errors_), std::end(errors_));
@@ -325,12 +325,12 @@ ByteSource::ByteSource(ByteSource&& other) noexcept
 }
 
 ByteSource::~ByteSource() {
-  OPENSSL_clear_free(allocated_data_, size_);
+  Thin_OPENSSL_clear_free(allocated_data_, size_);
 }
 
 ByteSource& ByteSource::operator=(ByteSource&& other) noexcept {
   if (&other != this) {
-    OPENSSL_clear_free(allocated_data_, size_);
+    Thin_OPENSSL_clear_free(allocated_data_, size_);
     data_ = other.data_;
     allocated_data_ = other.allocated_data_;
     other.allocated_data_ = nullptr;
@@ -353,7 +353,7 @@ std::unique_ptr<BackingStore> ByteSource::ReleaseToBackingStore(Environment* env
   void* v8_data = allocator->Allocate(size());
   CHECK(v8_data);
   memcpy(v8_data, allocated_data_, size());
-  OPENSSL_clear_free(allocated_data_, size());
+  Thin_OPENSSL_clear_free(allocated_data_, size());
   std::unique_ptr<BackingStore> ptr = ArrayBuffer::NewBackingStore(
       v8_data,
       size(),
@@ -372,7 +372,7 @@ std::unique_ptr<BackingStore> ByteSource::ReleaseToBackingStore(Environment* env
       allocated_data_,
       size(),
       [](void* data, size_t length, void* deleter_data) {
-        OPENSSL_clear_free(deleter_data, length);
+        Thin_OPENSSL_clear_free(deleter_data, length);
       }, allocated_data_);
   CHECK(ptr);
   allocated_data_ = nullptr;
@@ -395,7 +395,7 @@ MaybeLocal<Uint8Array> ByteSource::ToBuffer(Environment* env) {
 ByteSource ByteSource::FromBIO(const BIOPointer& bio) {
   CHECK(bio);
   BUF_MEM* bptr;
-  BIO_get_mem_ptr(bio.get(), &bptr);
+  Thin_BIO_get_mem_ptr(bio.get(), &bptr);
   ByteSource::Builder out(bptr->length);
   memcpy(out.data<void>(), bptr->data, bptr->length);
   return std::move(out).release();
@@ -478,9 +478,9 @@ Maybe<bool> Decorate(Environment* env, Local<Object> obj,
               unsigned long err) {  // NOLINT(runtime/int)
   if (err == 0) return Just(true);  // No decoration necessary.
 
-  const char* ls = ERR_lib_error_string(err);
-  const char* fs = ERR_func_error_string(err);
-  const char* rs = ERR_reason_error_string(err);
+  const char* ls = Thin_ERR_lib_error_string(err);
+  const char* fs = Thin_ERR_func_error_string(err);
+  const char* rs = Thin_ERR_reason_error_string(err);
 
   Isolate* isolate = env->isolate();
   Local<Context> context = isolate->GetCurrentContext();
@@ -587,7 +587,7 @@ void ThrowCryptoError(Environment* env,
                       const char* message) {
   char message_buffer[128] = {0};
   if (err != 0 || message == nullptr) {
-    ERR_error_string_n(err, message_buffer, sizeof(message_buffer));
+    Thin_ERR_error_string_n(err, message_buffer, sizeof(message_buffer));
     message = message_buffer;
   }
   HandleScope scope(env->isolate());
@@ -610,13 +610,13 @@ void ThrowCryptoError(Environment* env,
 EnginePointer LoadEngineById(const char* id, CryptoErrorStore* errors) {
   MarkPopErrorOnReturn mark_pop_error_on_return;
 
-  EnginePointer engine(ENGINE_by_id(id));
+  EnginePointer engine(Thin_ENGINE_by_id(id));
   if (!engine) {
     // Engine not found, try loading dynamically.
-    engine = EnginePointer(ENGINE_by_id("dynamic"));
+    engine = EnginePointer(Thin_ENGINE_by_id("dynamic"));
     if (engine) {
-      if (!ENGINE_ctrl_cmd_string(engine.get(), "SO_PATH", id, 0) ||
-          !ENGINE_ctrl_cmd_string(engine.get(), "LOAD", nullptr, 0)) {
+      if (!Thin_ENGINE_ctrl_cmd_string(engine.get(), "SO_PATH", id, 0) ||
+          !Thin_ENGINE_ctrl_cmd_string(engine.get(), "LOAD", nullptr, 0)) {
         engine.reset();
       }
     }
@@ -638,7 +638,7 @@ bool SetEngine(const char* id, uint32_t flags, CryptoErrorStore* errors) {
   if (!engine)
     return false;
 
-  if (!ENGINE_set_default(engine.get(), flags)) {
+  if (!Thin_ENGINE_set_default(engine.get(), flags)) {
     if (errors != nullptr)
       errors->Capture();
     return false;
@@ -665,7 +665,7 @@ MaybeLocal<Value> EncodeBignum(
     int size,
     Local<Value>* error) {
   std::vector<uint8_t> buf(size);
-  CHECK_EQ(BN_bn2binpad(bn, buf.data(), size), size);
+  CHECK_EQ(Thin_BN_bn2binpad(bn, buf.data(), size), size);
   return StringBytes::Encode(
       env->isolate(),
       reinterpret_cast<const char*>(buf.data()),
@@ -684,7 +684,7 @@ Maybe<bool> SetEncodedValue(
   Local<Value> error;
   CHECK_NOT_NULL(bn);
   if (size == 0)
-    size = BN_num_bytes(bn);
+    size = Thin_BN_num_bytes(bn);
   if (!EncodeBignum(env, bn, size, &error).ToLocal(&value)) {
     if (!error.IsEmpty())
       env->isolate()->ThrowException(error);
@@ -696,12 +696,12 @@ Maybe<bool> SetEncodedValue(
 bool SetRsaOaepLabel(const EVPKeyCtxPointer& ctx, const ByteSource& label) {
   if (label.size() != 0) {
     // OpenSSL takes ownership of the label, so we need to create a copy.
-    void* label_copy = OPENSSL_memdup(label.data(), label.size());
+    void* label_copy = Thin_OPENSSL_memdup(label.data(), label.size());
     CHECK_NOT_NULL(label_copy);
-    int ret = EVP_PKEY_CTX_set0_rsa_oaep_label(
+    int ret = Thin_EVP_PKEY_CTX_set0_rsa_oaep_label(
         ctx.get(), static_cast<unsigned char*>(label_copy), label.size());
     if (ret <= 0) {
-      OPENSSL_free(label_copy);
+      Thin_OPENSSL_free(label_copy);
       return false;
     }
   }
@@ -716,10 +716,10 @@ CryptoJobMode GetCryptoJobMode(v8::Local<v8::Value> args) {
 }
 
 namespace {
-// SecureBuffer uses OPENSSL_secure_malloc to allocate a Uint8Array.
+// SecureBuffer uses Thin_OPENSSL_secure_malloc to allocate a Uint8Array.
 // Without --secure-heap, OpenSSL's secure heap is disabled,
 // in which case this has the same semantics as
-// using OPENSSL_malloc. However, if the secure heap is
+// using Thin_OPENSSL_malloc. However, if the secure heap is
 // initialized, SecureBuffer will automatically use it.
 #if defined(V8_ENABLE_SANDBOX)
 // When V8 sandboxed pointers are enabled, the secure heap cannot be used as
@@ -746,7 +746,7 @@ void SecureBuffer(const FunctionCallbackInfo<Value>& args) {
           data,
           len,
           [](void* data, size_t len, void* deleter_data) {
-            OPENSSL_secure_clear_free(data, len);
+            Thin_OPENSSL_secure_clear_free(data, len);
           },
           data);
   Local<ArrayBuffer> buffer = ArrayBuffer::New(env->isolate(), store);
@@ -756,9 +756,9 @@ void SecureBuffer(const FunctionCallbackInfo<Value>& args) {
 
 void SecureHeapUsed(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
-  if (CRYPTO_secure_malloc_initialized())
+  if (Thin_CRYPTO_secure_malloc_initialized())
     args.GetReturnValue().Set(
-        BigInt::New(env->isolate(), CRYPTO_secure_used()));
+        BigInt::New(env->isolate(), Thin_CRYPTO_secure_used()));
 }
 }  // namespace
 
diff --git a/src/crypto/crypto_util.h b/src/crypto/crypto_util.h
index 333039b3b7..e33f70d99d 100644
--- a/src/crypto/crypto_util.h
+++ b/src/crypto/crypto_util.h
@@ -37,6 +37,8 @@
 #include <string>
 #include <vector>
 
+#include "crypto_wrapper.h"
+
 namespace node {
 namespace crypto {
 // Currently known sizes of commonly used OpenSSL struct sizes.
@@ -54,30 +56,30 @@ constexpr size_t kSizeOf_EVP_PKEY_CTX = 80;
 constexpr size_t kSizeOf_HMAC_CTX = 32;
 
 // Define smart pointers for the most commonly used OpenSSL types:
-using X509Pointer = DeleteFnPtr<X509, X509_free>;
-using BIOPointer = DeleteFnPtr<BIO, BIO_free_all>;
-using SSLCtxPointer = DeleteFnPtr<SSL_CTX, SSL_CTX_free>;
-using SSLSessionPointer = DeleteFnPtr<SSL_SESSION, SSL_SESSION_free>;
-using SSLPointer = DeleteFnPtr<SSL, SSL_free>;
-using PKCS8Pointer = DeleteFnPtr<PKCS8_PRIV_KEY_INFO, PKCS8_PRIV_KEY_INFO_free>;
-using EVPKeyPointer = DeleteFnPtr<EVP_PKEY, EVP_PKEY_free>;
-using EVPKeyCtxPointer = DeleteFnPtr<EVP_PKEY_CTX, EVP_PKEY_CTX_free>;
-using EVPMDPointer = DeleteFnPtr<EVP_MD_CTX, EVP_MD_CTX_free>;
-using RSAPointer = DeleteFnPtr<RSA, RSA_free>;
-using ECPointer = DeleteFnPtr<EC_KEY, EC_KEY_free>;
-using BignumPointer = DeleteFnPtr<BIGNUM, BN_free>;
-using BignumCtxPointer = DeleteFnPtr<BN_CTX, BN_CTX_free>;
-using NetscapeSPKIPointer = DeleteFnPtr<NETSCAPE_SPKI, NETSCAPE_SPKI_free>;
-using ECGroupPointer = DeleteFnPtr<EC_GROUP, EC_GROUP_free>;
-using ECPointPointer = DeleteFnPtr<EC_POINT, EC_POINT_free>;
-using ECKeyPointer = DeleteFnPtr<EC_KEY, EC_KEY_free>;
-using DHPointer = DeleteFnPtr<DH, DH_free>;
-using ECDSASigPointer = DeleteFnPtr<ECDSA_SIG, ECDSA_SIG_free>;
-using HMACCtxPointer = DeleteFnPtr<HMAC_CTX, HMAC_CTX_free>;
-using CipherCtxPointer = DeleteFnPtr<EVP_CIPHER_CTX, EVP_CIPHER_CTX_free>;
-using RsaPointer = DeleteFnPtr<RSA, RSA_free>;
-using DsaPointer = DeleteFnPtr<DSA, DSA_free>;
-using DsaSigPointer = DeleteFnPtr<DSA_SIG, DSA_SIG_free>;
+using X509Pointer = DeleteFnPtr<X509, Thin_X509_free>;
+using BIOPointer = DeleteFnPtr<BIO, Thin_BIO_free_all>;
+using SSLCtxPointer = DeleteFnPtr<SSL_CTX, Thin_SSL_CTX_free>;
+using SSLSessionPointer = DeleteFnPtr<SSL_SESSION, Thin_SSL_SESSION_free>;
+using SSLPointer = DeleteFnPtr<SSL, Thin_SSL_free>;
+using PKCS8Pointer = DeleteFnPtr<PKCS8_PRIV_KEY_INFO, Thin_PKCS8_PRIV_KEY_INFO_free>;
+using EVPKeyPointer = DeleteFnPtr<EVP_PKEY, Thin_EVP_PKEY_free>;
+using EVPKeyCtxPointer = DeleteFnPtr<EVP_PKEY_CTX, Thin_EVP_PKEY_CTX_free>;
+using EVPMDPointer = DeleteFnPtr<EVP_MD_CTX, Thin_EVP_MD_CTX_free>;
+using RSAPointer = DeleteFnPtr<RSA, Thin_RSA_free>;
+using ECPointer = DeleteFnPtr<EC_KEY, Thin_EC_KEY_free>;
+using BignumPointer = DeleteFnPtr<BIGNUM, Thin_BN_free>;
+using BignumCtxPointer = DeleteFnPtr<BN_CTX, Thin_BN_CTX_free>;
+using NetscapeSPKIPointer = DeleteFnPtr<NETSCAPE_SPKI, Thin_NETSCAPE_SPKI_free>;
+using ECGroupPointer = DeleteFnPtr<EC_GROUP, Thin_EC_GROUP_free>;
+using ECPointPointer = DeleteFnPtr<EC_POINT, Thin_EC_POINT_free>;
+using ECKeyPointer = DeleteFnPtr<EC_KEY, Thin_EC_KEY_free>;
+using DHPointer = DeleteFnPtr<DH, Thin_DH_free>;
+using ECDSASigPointer = DeleteFnPtr<ECDSA_SIG, Thin_ECDSA_SIG_free>;
+using HMACCtxPointer = DeleteFnPtr<HMAC_CTX, Thin_HMAC_CTX_free>;
+using CipherCtxPointer = DeleteFnPtr<EVP_CIPHER_CTX, Thin_EVP_CIPHER_CTX_free>;
+using RsaPointer = DeleteFnPtr<RSA, Thin_RSA_free>;
+using DsaPointer = DeleteFnPtr<DSA, Thin_DSA_free>;
+using DsaSigPointer = DeleteFnPtr<DSA_SIG, Thin_DSA_SIG_free>;
 
 // Our custom implementation of the certificate verify callback
 // used when establishing a TLS handshake. Because we cannot perform
@@ -100,16 +102,16 @@ extern void UseExtraCaCerts(const std::string& file);
 // Forcibly clear OpenSSL's error stack on return. This stops stale errors
 // from popping up later in the lifecycle of crypto operations where they
 // would cause spurious failures. It's a rather blunt method, though.
-// ERR_clear_error() isn't necessarily cheap either.
+// Thin_ERR_clear_error() isn't necessarily cheap either.
 struct ClearErrorOnReturn {
-  ~ClearErrorOnReturn() { ERR_clear_error(); }
+  ~ClearErrorOnReturn() { Thin_ERR_clear_error(); }
 };
 
 // Pop errors from OpenSSL's error stack that were added
 // between when this was constructed and destructed.
 struct MarkPopErrorOnReturn {
-  MarkPopErrorOnReturn() { ERR_set_mark(); }
-  ~MarkPopErrorOnReturn() { ERR_pop_to_mark(); }
+  MarkPopErrorOnReturn() { Thin_ERR_set_mark(); }
+  ~MarkPopErrorOnReturn() { Thin_ERR_pop_to_mark(); }
 };
 
 struct CSPRNGResult {
@@ -202,7 +204,7 @@ void CryptoErrorStore::Insert(const NodeCryptoError error, Args&&... args) {
 
 template <typename T>
 T* MallocOpenSSL(size_t count) {
-  void* mem = OPENSSL_malloc(MultiplyWithOverflowCheck(count, sizeof(T)));
+  void* mem = Thin_OPENSSL_malloc(MultiplyWithOverflowCheck(count, sizeof(T)));
   CHECK_IMPLIES(mem == nullptr, count == 0);
   return static_cast<T*>(mem);
 }
@@ -222,7 +224,7 @@ class ByteSource {
     Builder(const Builder&) = delete;
     Builder& operator=(const Builder&) = delete;
 
-    ~Builder() { OPENSSL_clear_free(data_, size_); }
+    ~Builder() { Thin_OPENSSL_clear_free(data_, size_); }
 
     // Returns the underlying non-const pointer.
     template <typename T>
@@ -239,7 +241,7 @@ class ByteSource {
       if (resize) {
         CHECK_LE(*resize, size_);
         if (*resize == 0) {
-          OPENSSL_clear_free(data_, size_);
+          Thin_OPENSSL_clear_free(data_, size_);
           data_ = nullptr;
         }
         size_ = *resize;
@@ -274,7 +276,7 @@ class ByteSource {
   operator bool() const { return data_ != nullptr; }
 
   BignumPointer ToBN() const {
-    return BignumPointer(BN_bin2bn(data<unsigned char>(), size(), nullptr));
+    return BignumPointer(Thin_BN_bin2bn(data<unsigned char>(), size(), nullptr));
   }
 
   // Creates a v8::BackingStore that takes over responsibility for
@@ -579,10 +581,10 @@ struct EnginePointer {
   inline void reset(ENGINE* engine_ = nullptr, bool finish_on_exit_ = false) {
     if (engine != nullptr) {
       if (finish_on_exit) {
-        // This also does the equivalent of ENGINE_free.
-        CHECK_EQ(ENGINE_finish(engine), 1);
+        // This also does the equivalent of Thin_ENGINE_free.
+        CHECK_EQ(Thin_ENGINE_finish(engine), 1);
       } else {
-        CHECK_EQ(ENGINE_free(engine), 1);
+        CHECK_EQ(Thin_ENGINE_free(engine), 1);
       }
     }
     engine = engine_;
diff --git a/src/crypto/crypto_wrapper.cc b/src/crypto/crypto_wrapper.cc
new file mode 100644
index 0000000000..c2bb4edfe2
--- /dev/null
+++ b/src/crypto/crypto_wrapper.cc
@@ -0,0 +1,1827 @@
+#include <stdarg.h>
+
+#include <openssl/bn.h>
+#include <openssl/aes.h>
+#include <openssl/ssl.h>
+#include <openssl/err.h>
+#include <openssl/engine.h>
+#include <openssl/crypto.h>
+#include <openssl/evp.h>
+#include <openssl/tls1.h>
+#include <openssl/x509v3.h>
+#include <openssl/sha.h>
+
+#include "crypto_wrapper.h"
+
+# define NODE_CRYPTO_EXTERN __attribute__((visibility("default")))
+
+NODE_CRYPTO_EXTERN void Thin_X509_free(X509 *x) {
+    return X509_free(x);
+}
+
+NODE_CRYPTO_EXTERN void Thin_BIO_free_all(BIO *a) {
+    return BIO_free_all(a);
+}
+
+NODE_CRYPTO_EXTERN void Thin_SSL_CTX_free(SSL_CTX *ctx) {
+    return SSL_CTX_free(ctx);
+}
+
+NODE_CRYPTO_EXTERN void Thin_SSL_SESSION_free(SSL_SESSION *ses) {
+    return SSL_SESSION_free(ses);
+}
+
+NODE_CRYPTO_EXTERN void Thin_SSL_free(SSL *ssl) {
+    return SSL_free(ssl);
+}
+
+NODE_CRYPTO_EXTERN void Thin_PKCS8_PRIV_KEY_INFO_free(PKCS8_PRIV_KEY_INFO* p) {
+    return PKCS8_PRIV_KEY_INFO_free(p);
+}
+
+NODE_CRYPTO_EXTERN void Thin_EVP_PKEY_free(EVP_PKEY *pkey) {
+    return EVP_PKEY_free(pkey);
+}
+
+NODE_CRYPTO_EXTERN void Thin_EVP_PKEY_CTX_free(EVP_PKEY_CTX *ctx) {
+    return EVP_PKEY_CTX_free(ctx);
+}
+NODE_CRYPTO_EXTERN void Thin_EVP_MD_CTX_free(EVP_MD_CTX *ctx) {
+    return EVP_MD_CTX_free(ctx);
+}
+
+NODE_CRYPTO_EXTERN void Thin_RSA_free(RSA *rsa) {
+    return RSA_free(rsa);
+}
+NODE_CRYPTO_EXTERN void Thin_EC_KEY_free(EC_KEY *key) {
+    return EC_KEY_free(key);
+}
+
+NODE_CRYPTO_EXTERN BIGNUM *Thin_BN_new(void) {
+    return BN_new();
+}
+
+NODE_CRYPTO_EXTERN void Thin_BN_free(BIGNUM *bn) {
+    return BN_free(bn);
+}
+
+NODE_CRYPTO_EXTERN void Thin_BN_CTX_free(BN_CTX *ctx) {
+    return BN_CTX_free(ctx);
+}
+
+NODE_CRYPTO_EXTERN void Thin_NETSCAPE_SPKI_free(NETSCAPE_SPKI *spki) {
+    return NETSCAPE_SPKI_free(spki);
+}
+
+NODE_CRYPTO_EXTERN void Thin_EC_GROUP_free(EC_GROUP *group) {
+    return EC_GROUP_free(group);
+}
+NODE_CRYPTO_EXTERN void Thin_EC_POINT_free(EC_POINT *point) {
+    return EC_POINT_free(point);
+}
+
+NODE_CRYPTO_EXTERN void Thin_DH_free(DH *dh) {
+    return DH_free(dh);
+}
+NODE_CRYPTO_EXTERN void Thin_ECDSA_SIG_free(ECDSA_SIG *sig) {
+    return ECDSA_SIG_free(sig);
+}
+NODE_CRYPTO_EXTERN void Thin_HMAC_CTX_free(HMAC_CTX *ctx) {
+    return HMAC_CTX_free(ctx);
+}
+NODE_CRYPTO_EXTERN void Thin_EVP_CIPHER_CTX_free(EVP_CIPHER_CTX *ctx) {
+    return EVP_CIPHER_CTX_free(ctx);
+}
+
+NODE_CRYPTO_EXTERN void Thin_DSA_free(DSA *dsa) {
+    return DSA_free(dsa);
+}
+NODE_CRYPTO_EXTERN void Thin_DSA_SIG_free(DSA_SIG *sig) {
+    return DSA_SIG_free(sig);
+}
+
+NODE_CRYPTO_EXTERN void Thin_OPENSSL_free(void *addr) {
+    return OPENSSL_free(addr);
+}
+
+NODE_CRYPTO_EXTERN void Thin_ERR_clear_error(void) {
+    return ERR_clear_error();
+}
+NODE_CRYPTO_EXTERN int Thin_SSL_CTX_use_PrivateKey(SSL_CTX *ctx, EVP_PKEY *pkey) {
+    return SSL_CTX_use_PrivateKey(ctx, pkey);
+}
+
+NODE_CRYPTO_EXTERN int Thin_ERR_set_mark(void) {
+    return ERR_set_mark();
+}
+NODE_CRYPTO_EXTERN int Thin_ERR_pop_to_mark(void) {
+    return ERR_pop_to_mark();
+}
+NODE_CRYPTO_EXTERN unsigned long Thin_ERR_peek_error(void) {
+    return ERR_peek_error();
+}
+NODE_CRYPTO_EXTERN int Thin_SSL_CTX_set_ciphersuites(SSL_CTX *ctx, const char *str) {
+    return SSL_CTX_set_ciphersuites(ctx, str);
+}
+NODE_CRYPTO_EXTERN void Thin_CRYPTO_secure_free(void *ptr, const char *file, int line) {
+    return CRYPTO_secure_free(ptr, file, line);
+}
+NODE_CRYPTO_EXTERN void *Thin_CRYPTO_memdup(const void *str, size_t siz, const char *file, int line) {
+    return CRYPTO_memdup(str, siz, file, line);
+}
+NODE_CRYPTO_EXTERN int Thin_BIO_meth_set_write(BIO_METHOD *biom,
+                       int (*write) (BIO *, const char *, int)) {
+    return BIO_meth_set_write(biom, write);
+}
+NODE_CRYPTO_EXTERN int Thin_BIO_meth_set_read(BIO_METHOD *biom,
+                      int (*read) (BIO *, char *, int)) {
+    return BIO_meth_set_read(biom, read);
+}
+NODE_CRYPTO_EXTERN int Thin_BIO_meth_set_puts(BIO_METHOD *biom,
+                      int (*puts) (BIO *, const char *)) {
+    return BIO_meth_set_puts(biom, puts);
+}
+NODE_CRYPTO_EXTERN int Thin_BIO_meth_set_gets(BIO_METHOD *biom,
+                      int (*gets) (BIO *, char *, int)) {
+    return BIO_meth_set_gets(biom, gets);
+}
+NODE_CRYPTO_EXTERN int Thin_BIO_meth_set_ctrl(BIO_METHOD *biom,
+                      long (*ctrl) (BIO *, int, long, void *)) {
+    return BIO_meth_set_ctrl(biom, ctrl);
+}
+NODE_CRYPTO_EXTERN int Thin_BIO_meth_set_create(BIO_METHOD *biom, int (*create) (BIO *)) {
+    return BIO_meth_set_create(biom, create);
+}
+NODE_CRYPTO_EXTERN  int Thin_BIO_meth_set_destroy(BIO_METHOD *biom, int (*destroy) (BIO *)) {
+    return BIO_meth_set_destroy(biom, destroy);
+}
+NODE_CRYPTO_EXTERN const char *Thin_SSL_CIPHER_get_name(const SSL_CIPHER *c) {
+    return SSL_CIPHER_get_name(c);
+}
+NODE_CRYPTO_EXTERN SSL_CTX_keylog_cb_func Thin_SSL_CTX_get_keylog_callback(const SSL_CTX *ctx) {
+    return SSL_CTX_get_keylog_callback(ctx);
+}
+NODE_CRYPTO_EXTERN BIO_METHOD *Thin_BIO_meth_new(int type, const char *name) {
+    return BIO_meth_new(type, name);
+}
+
+NODE_CRYPTO_EXTERN int Thin_SSL_set_session(SSL *to, SSL_SESSION *session) {
+    return SSL_set_session(to, session);
+}
+
+NODE_CRYPTO_EXTERN int Thin_RSA_pkey_ctx_ctrl(EVP_PKEY_CTX *ctx, int optype, int cmd, int p1, void *p2) {
+    return RSA_pkey_ctx_ctrl(ctx, optype, cmd, p1, p2);
+}
+NODE_CRYPTO_EXTERN void Thin_CRYPTO_clear_free(void *ptr, size_t num, const char *file, int line) {
+    return CRYPTO_clear_free(ptr, num, file, line);
+}
+NODE_CRYPTO_EXTERN void Thin_SSL_CTX_set_keylog_callback(SSL_CTX *ctx, SSL_CTX_keylog_cb_func cb) {
+    return SSL_CTX_set_keylog_callback(ctx, cb);
+}
+NODE_CRYPTO_EXTERN void Thin_SSL_CTX_sess_set_new_cb(SSL_CTX *ctx,
+                             int (*new_session_cb) (struct ssl_st *ssl,
+                                                    SSL_SESSION *sess)) {
+    return SSL_CTX_sess_set_new_cb(ctx, new_session_cb);
+}
+NODE_CRYPTO_EXTERN void Thin_SSL_CTX_sess_set_get_cb(SSL_CTX *ctx,
+                             SSL_SESSION *(*get_session_cb) (struct ssl_st
+                                                             *ssl,
+                                                             const unsigned char
+                                                             *data, int len,
+                                                             int *copy)) {
+    return SSL_CTX_sess_set_get_cb(ctx, get_session_cb);
+}
+
+NODE_CRYPTO_EXTERN void Thin_SSL_set_bio(SSL *s, BIO *rbio, BIO *wbio) {
+    return SSL_set_bio(s, rbio, wbio);
+}
+NODE_CRYPTO_EXTERN void Thin_SSL_set_verify(SSL *s, int mode, SSL_verify_cb callback) {
+    return SSL_set_verify(s, mode, callback);
+}
+NODE_CRYPTO_EXTERN void Thin_SSL_set_msg_callback(SSL *ssl,
+                          void (*cb) (int write_p, int version,
+                                      int content_type, const void *buf,
+                                      size_t len, SSL *ssl, void *arg)) {
+    return SSL_set_msg_callback(ssl, cb);
+}
+NODE_CRYPTO_EXTERN void Thin_SSL_trace(int write_p, int version, int content_type,
+               const void *buf, size_t len, SSL *ssl, void *arg) {
+    // return SSL_trace(write_p, version, content_type, buf, len, ssl, arg);
+}
+NODE_CRYPTO_EXTERN SSL_CTX *Thin_SSL_set_SSL_CTX(SSL *ssl, SSL_CTX *ctx) {
+    return SSL_set_SSL_CTX(ssl, ctx);
+}
+NODE_CRYPTO_EXTERN STACK_OF(X509_NAME) *Thin_SSL_dup_CA_list(const STACK_OF(X509_NAME) *sk) {
+    return SSL_dup_CA_list(sk);
+}
+NODE_CRYPTO_EXTERN void Thin_SSL_set_client_CA_list(SSL *s, STACK_OF(X509_NAME) *name_list) {
+    return SSL_set_client_CA_list(s, name_list);
+}
+NODE_CRYPTO_EXTERN int Thin_SSL_use_psk_identity_hint(SSL *s, const char *identity_hint) {
+    return SSL_use_psk_identity_hint(s, identity_hint);
+}
+NODE_CRYPTO_EXTERN void Thin_SSL_set_psk_server_callback(SSL *ssl, SSL_psk_server_cb_func cb) {
+    return SSL_set_psk_server_callback(ssl, cb);
+}
+NODE_CRYPTO_EXTERN void Thin_SSL_set_psk_client_callback(SSL *ssl, SSL_psk_client_cb_func cb) {
+    return SSL_set_psk_client_callback(ssl, cb);
+}
+NODE_CRYPTO_EXTERN void Thin_SSL_CTX_set_alpn_select_cb(SSL_CTX *ctx,
+                                SSL_CTX_alpn_select_cb_func cb,
+                                void *arg) {
+    return SSL_CTX_set_alpn_select_cb(ctx, cb, arg);
+}
+NODE_CRYPTO_EXTERN const EVP_CIPHER *Thin_EVP_get_cipherbyname(const char *name) {
+    return EVP_get_cipherbyname(name);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_PKEY_CTX_ctrl(EVP_PKEY_CTX *ctx, int keytype, int optype,
+                      int cmd, int p1, void *p2) {
+    return EVP_PKEY_CTX_ctrl(ctx, keytype, optype, cmd, p1, p2);
+}
+NODE_CRYPTO_EXTERN int Thin_SSL_use_certificate(SSL *ssl, X509 *x) {
+    return SSL_use_certificate(ssl, x);
+}
+NODE_CRYPTO_EXTERN void Thin_sk_SSL_COMP_zero(STACK_OF(SSL_COMP) *sk) {
+    return sk_SSL_COMP_zero(sk);
+}
+NODE_CRYPTO_EXTERN STACK_OF(X509) *Thin_sk_X509_new(sk_X509_compfunc fn) {
+    return sk_X509_new(fn);
+}
+NODE_CRYPTO_EXTERN int Thin_sk_X509_num(const struct stack_st_X509 *sk) {
+    return sk_X509_num(sk);
+}
+NODE_CRYPTO_EXTERN int Thin_sk_SSL_CIPHER_num(STACK_OF(SSL_CIPHER)* ciphers) {
+    return sk_SSL_CIPHER_num(ciphers);
+}
+NODE_CRYPTO_EXTERN x509_st *Thin_sk_X509_delete(STACK_OF(X509) *sk, int i) {
+    return sk_X509_delete(sk, i);
+}
+NODE_CRYPTO_EXTERN int Thin_SSL_use_PrivateKey(SSL *ssl, EVP_PKEY *pkey) {
+    return SSL_use_PrivateKey(ssl, pkey);
+}
+NODE_CRYPTO_EXTERN X509 *Thin_SSL_CTX_get0_certificate(const SSL_CTX *ctx) {
+    return SSL_CTX_get0_certificate(ctx);
+}
+NODE_CRYPTO_EXTERN void Thin_EVP_CIPHER_do_all_sorted(void (*fn)
+                               (const EVP_CIPHER *ciph, const char *from,
+                                const char *to, void *x), void *arg) {
+    return EVP_CIPHER_do_all_sorted(fn, arg);
+}
+NODE_CRYPTO_EXTERN BN_ULONG Thin_BN_get_word(const BIGNUM *a) {
+    return BN_get_word(a);
+}
+NODE_CRYPTO_EXTERN int Thin_BN_lshift(BIGNUM *r, const BIGNUM *a, int n) {
+    return BN_lshift(r, a, n);
+}
+NODE_CRYPTO_EXTERN const char *Thin_OBJ_nid2sn(int n) {
+    return OBJ_nid2sn(n);
+}
+NODE_CRYPTO_EXTERN const BIGNUM *Thin_BN_value_one(void) {
+    return BN_value_one();
+}
+NODE_CRYPTO_EXTERN const EVP_MD *Thin_EVP_md5(void) {
+    return EVP_md5();
+}
+NODE_CRYPTO_EXTERN int Thin_EC_GROUP_order_bits(const EC_GROUP *group) {
+    return EC_GROUP_order_bits(group);
+}
+NODE_CRYPTO_EXTERN void Thin_X509V3_conf_free(CONF_VALUE *val) {
+    return X509V3_conf_free(val);
+}
+NODE_CRYPTO_EXTERN void Thin_GENERAL_NAME_free(GENERAL_NAME *p) {
+    return GENERAL_NAME_free(p);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *x, int keylen) {
+    return EVP_CIPHER_CTX_set_key_length(x, keylen);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_PKEY_verify_recover(EVP_PKEY_CTX *ctx,
+                            unsigned char *rout, size_t *routlen,
+                            const unsigned char *sig, size_t siglen) {
+    EVP_PKEY_verify_recover(ctx, rout, routlen, sig, siglen);
+}
+NODE_CRYPTO_EXTERN void Thin_X509_STORE_CTX_free(X509_STORE_CTX *ctx) {
+    return X509_STORE_CTX_free(ctx);
+}
+NODE_CRYPTO_EXTERN int Thin_BN_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b) {
+    return BN_sub(r, a, b);
+}
+NODE_CRYPTO_EXTERN const char *Thin_SSL_CIPHER_standard_name(const SSL_CIPHER *c) {
+    return SSL_CIPHER_standard_name(c);
+}
+
+NODE_CRYPTO_EXTERN void Thin_EVP_CIPHER_CTX_set_flags(EVP_CIPHER_CTX *ctx, int flags) {
+    return EVP_CIPHER_CTX_set_flags(ctx, flags);
+}
+NODE_CRYPTO_EXTERN const EVP_MD *Thin_EVP_sha1(void) {
+    return EVP_sha1();
+}
+NODE_CRYPTO_EXTERN const EVP_MD *Thin_EVP_sha224(void) {
+    return EVP_sha224();
+}
+NODE_CRYPTO_EXTERN const EVP_MD *Thin_EVP_sha256(void) {
+    return EVP_sha256();
+}
+NODE_CRYPTO_EXTERN const EVP_MD *Thin_EVP_sha384(void) {
+    return EVP_sha384();
+}
+NODE_CRYPTO_EXTERN const EVP_MD *Thin_EVP_sha512(void) {
+    return EVP_sha512();
+}
+NODE_CRYPTO_EXTERN const EVP_MD *Thin_EVP_sha512_224(void) {
+    return EVP_sha512_224();
+}
+NODE_CRYPTO_EXTERN const EVP_MD *Thin_EVP_sha512_256(void) {
+    return EVP_sha512_256();
+}
+NODE_CRYPTO_EXTERN const EVP_MD *Thin_EVP_sha3_224(void) {
+    return EVP_sha3_224();
+}
+NODE_CRYPTO_EXTERN const EVP_MD *Thin_EVP_sha3_256(void) {
+    return EVP_sha3_256();
+}
+NODE_CRYPTO_EXTERN const EVP_MD *Thin_EVP_sha3_384(void) {
+    return EVP_sha3_384();
+}
+NODE_CRYPTO_EXTERN const EVP_MD *Thin_EVP_sha3_512(void) {
+    return EVP_sha3_512();
+}
+NODE_CRYPTO_EXTERN const EVP_MD *Thin_EVP_shake128(void) {
+    return EVP_shake128();
+}
+NODE_CRYPTO_EXTERN const EVP_MD *Thin_EVP_shake256(void) {
+    return EVP_shake256();
+}
+
+NODE_CRYPTO_EXTERN EVP_PKEY *Thin_SSL_CTX_get0_privatekey(const SSL_CTX *ctx) {
+    return SSL_CTX_get0_privatekey(ctx);
+}
+NODE_CRYPTO_EXTERN int Thin_SSL_client_hello_get0_ext(SSL *s, unsigned int type,
+                              const unsigned char **out, size_t *outlen) {
+    return SSL_client_hello_get0_ext(s, type, out, outlen);
+}
+NODE_CRYPTO_EXTERN const char *Thin_X509_verify_cert_error_string(long n) {
+    return X509_verify_cert_error_string(n);
+}
+NODE_CRYPTO_EXTERN void Thin_CRYPTO_secure_clear_free(void *ptr, size_t num,
+                              const char *file, int line) {
+    return CRYPTO_secure_clear_free(ptr, num, file, line);
+}
+NODE_CRYPTO_EXTERN const char *Thin_SSL_get_servername(const SSL *s, const int type) {
+    return SSL_get_servername(s, type);
+}
+NODE_CRYPTO_EXTERN void *Thin_OPENSSL_sk_value(const OPENSSL_STACK *sk, int i) {
+    return OPENSSL_sk_value(sk, i);
+}
+NODE_CRYPTO_EXTERN void Thin_BIO_set_flags(BIO *b, int flags) {
+    return BIO_set_flags(b, flags);
+}
+NODE_CRYPTO_EXTERN void Thin_BIO_clear_flags(BIO *b, int flags) {
+    return BIO_clear_flags(b, flags);
+}
+NODE_CRYPTO_EXTERN int Thin_sk_ASN1_OBJECT_num(const struct stack_st_ASN1_OBJECT *sk) {
+    return sk_ASN1_OBJECT_num(sk);
+}
+NODE_CRYPTO_EXTERN const ASN1_OBJECT *Thin_sk_ASN1_OBJECT_value(const struct stack_st_ASN1_OBJECT *sk, int i) {
+    return sk_ASN1_OBJECT_value(sk, i);
+}
+NODE_CRYPTO_EXTERN x509_st *Thin_sk_X509_value(const struct stack_st_X509 *sk, int i) {
+    return sk_X509_value(sk, i);
+}
+NODE_CRYPTO_EXTERN GENERAL_NAME *Thin_sk_GENERAL_NAME_value(const struct stack_st_GENERAL_NAME *sk, int i) {
+    return sk_GENERAL_NAME_value(sk, i);
+}
+NODE_CRYPTO_EXTERN int Thin_i2t_ASN1_OBJECT(char *buf, int buf_len, const ASN1_OBJECT *a) {
+    return i2t_ASN1_OBJECT(buf, buf_len, a);
+}
+NODE_CRYPTO_EXTERN int Thin_sk_ACCESS_DESCRIPTION_num(STACK_OF(ACCESS_DESCRIPTION)* sk) {
+    return sk_ACCESS_DESCRIPTION_num(sk);
+}
+NODE_CRYPTO_EXTERN ACCESS_DESCRIPTION *Thin_sk_ACCESS_DESCRIPTION_value(const struct stack_st_ACCESS_DESCRIPTION *sk, int i) {
+    return sk_ACCESS_DESCRIPTION_value(sk, i);
+}
+NODE_CRYPTO_EXTERN void Thin_ACCESS_DESCRIPTION_free(ACCESS_DESCRIPTION *p) {
+    return ACCESS_DESCRIPTION_free(p);
+}
+NODE_CRYPTO_EXTERN void Thin_sk_ACCESS_DESCRIPTION_pop_free(STACK_OF(ACCESS_DESCRIPTION) *sk, void (*fn)(ACCESS_DESCRIPTION *))  {
+    return sk_ACCESS_DESCRIPTION_pop_free(sk, fn);
+}
+NODE_CRYPTO_EXTERN int Thin_sk_GENERAL_NAME_num(STACK_OF(GENERAL_NAME)* sk) {
+    return sk_GENERAL_NAME_num(sk);
+}
+NODE_CRYPTO_EXTERN int Thin_OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name) {
+    return OBJ_obj2txt(buf, buf_len, a, no_name);
+}
+NODE_CRYPTO_EXTERN const SSL_CIPHER *Thin_sk_SSL_CIPHER_value(const struct stack_st_SSL_CIPHER *sk, int i) {
+    return sk_SSL_CIPHER_value(sk, i);
+}
+NODE_CRYPTO_EXTERN void Thin_sk_GENERAL_NAME_pop_free(STACK_OF(GENERAL_NAME) *sk, void (*fn)(GENERAL_NAME *)) {
+    return sk_GENERAL_NAME_pop_free(sk, fn);
+}
+NODE_CRYPTO_EXTERN void Thin_X509V3_EXT_val_prn(BIO *out, STACK_OF(CONF_VALUE) *val, int indent, int ml) {
+    return X509V3_EXT_val_prn(out, val, indent, ml);
+}
+NODE_CRYPTO_EXTERN STACK_OF(CONF_VALUE) *Thin_i2v_GENERAL_NAME(X509V3_EXT_METHOD *method, GENERAL_NAME *gen, STACK_OF(CONF_VALUE) *ret) {
+    return i2v_GENERAL_NAME(method, gen, ret);
+}
+NODE_CRYPTO_EXTERN void Thin_sk_CONF_VALUE_pop_free(STACK_OF(CONF_VALUE) *sk, void (*fn)(CONF_VALUE *)) {
+    return sk_CONF_VALUE_pop_free(sk, fn);
+}
+NODE_CRYPTO_EXTERN int Thin_X509_STORE_add_cert(X509_STORE *ctx, X509 *x) {
+    return X509_STORE_add_cert(ctx, x);
+}
+NODE_CRYPTO_EXTERN void Thin_SSL_CTX_set_cert_store(SSL_CTX *ctx, X509_STORE *store) {
+    return SSL_CTX_set_cert_store(ctx, store);
+}
+NODE_CRYPTO_EXTERN int Thin_ENGINE_free(ENGINE *e) {
+    return ENGINE_free(e);
+}
+NODE_CRYPTO_EXTERN void Thin_sk_ASN1_OBJECT_pop_free(STACK_OF(ASN1_OBJECT)* sk, void (*fn)(asn1_object_st *)) {
+    return sk_ASN1_OBJECT_pop_free(sk, fn);
+}
+NODE_CRYPTO_EXTERN void Thin_sk_X509_pop_free(STACK_OF(X509) *sk, void (*fn)(x509_st *)) {
+    return sk_X509_pop_free(sk, fn);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_CIPHER_CTX_reset(EVP_CIPHER_CTX *c) {
+    return EVP_CIPHER_CTX_reset(c);
+}
+NODE_CRYPTO_EXTERN int Thin_PEM_write_bio_PUBKEY(BIO *bp, EVP_PKEY *x) {
+    return PEM_write_bio_PUBKEY(bp, x);
+}
+NODE_CRYPTO_EXTERN void *Thin_SSL_get_ex_data(const SSL *ssl, int idx) {
+    return SSL_get_ex_data(ssl, idx);
+}
+NODE_CRYPTO_EXTERN X509 *Thin_PEM_read_bio_X509_AUX(BIO *bp, X509 **x, pem_password_cb *cb, void *u) {
+    return PEM_read_bio_X509_AUX(bp, x, cb, u);
+}
+NODE_CRYPTO_EXTERN long Thin_BIO_ctrl(BIO *bp, int cmd, long larg, void *parg) {
+    return BIO_ctrl(bp, cmd, larg, parg);
+}
+NODE_CRYPTO_EXTERN void *Thin_OPENSSL_malloc(size_t num) {
+    return OPENSSL_malloc(num);
+}
+
+NODE_CRYPTO_EXTERN void *Thin_OPENSSL_realloc(void *addr, size_t num) {
+    return OPENSSL_realloc(addr, num);
+}
+
+NODE_CRYPTO_EXTERN int Thin_EVP_PKEY_keygen_init(EVP_PKEY_CTX *ctx) {
+    return EVP_PKEY_keygen_init(ctx);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_PKEY_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey) {
+    return EVP_PKEY_keygen(ctx, ppkey);
+}
+
+NODE_CRYPTO_EXTERN int Thin_FIPS_mode() {
+    return 0; //FIPS_mode();
+}
+
+NODE_CRYPTO_EXTERN int Thin_FIPS_mode_set(int r) {
+    return 0;// FIPS_mode_set(r);
+}
+
+NODE_CRYPTO_EXTERN BIGNUM *Thin_BN_bin2bn(const unsigned char *s, int len, BIGNUM *ret) {
+    return BN_bin2bn(s, len, ret);
+}
+
+NODE_CRYPTO_EXTERN void Thin_ERR_print_errors_fp(FILE *fp) {
+    return ERR_print_errors_fp(fp);
+}
+NODE_CRYPTO_EXTERN int Thin_OBJ_txt2nid(const char *s) {
+    return OBJ_txt2nid(s);
+}
+NODE_CRYPTO_EXTERN int Thin_X509_NAME_get_index_by_NID(X509_NAME *name, int nid, int lastpos) {
+    return X509_NAME_get_index_by_NID(name, nid, lastpos);
+}
+NODE_CRYPTO_EXTERN X509_NAME_ENTRY *Thin_X509_NAME_get_entry(const X509_NAME *name, int loc) {
+    return X509_NAME_get_entry(name, loc);
+}
+NODE_CRYPTO_EXTERN ASN1_STRING * Thin_X509_NAME_ENTRY_get_data(const X509_NAME_ENTRY *ne) {
+    return X509_NAME_ENTRY_get_data(ne);
+}
+NODE_CRYPTO_EXTERN const unsigned char *Thin_ASN1_STRING_get0_data(const ASN1_STRING *x) {
+    return ASN1_STRING_get0_data(x);
+}
+NODE_CRYPTO_EXTERN void Thin_BIO_set_shutdown(BIO *a, int shut) {
+    return BIO_set_shutdown(a, shut);
+}
+NODE_CRYPTO_EXTERN void Thin_SSL_get0_alpn_selected(const SSL *ssl, const unsigned char **data,
+                            unsigned int *len) {
+    return SSL_get0_alpn_selected(ssl, data, len);
+}
+NODE_CRYPTO_EXTERN int Thin_SSL_renegotiate(SSL *s) {
+    return SSL_renegotiate(s);
+}
+NODE_CRYPTO_EXTERN const char *Thin_SSL_get_version(const SSL *s) {
+    return SSL_get_version(s);
+}
+NODE_CRYPTO_EXTERN void Thin_OPENSSL_init(void) {
+    return OPENSSL_init();
+}
+NODE_CRYPTO_EXTERN int Thin_SSL_export_keying_material(SSL *s, unsigned char *out, size_t olen,
+                                      const char *label, size_t llen,
+                                      const unsigned char *context,
+                                      size_t contextlen, int use_context) {
+    return SSL_export_keying_material(s, out, olen, label, llen, context, contextlen, use_context);
+}
+NODE_CRYPTO_EXTERN int Thin_SSL_get_shared_sigalgs(SSL *s, int idx,
+                           int *psign, int *phash, int *psignandhash,
+                           unsigned char *rsig, unsigned char *rhash) {
+    return SSL_get_shared_sigalgs(s, idx, psign, phash, psignandhash, rsig, rhash);
+}
+NODE_CRYPTO_EXTERN size_t Thin_SSL_get_finished(const SSL *s, void *buf, size_t count) {
+    return SSL_get_finished(s, buf, count);
+}
+NODE_CRYPTO_EXTERN int Thin_SSL_renegotiate_pending(const SSL *s) {
+    return SSL_renegotiate_pending(s);
+}
+NODE_CRYPTO_EXTERN void Thin_SSL_set_connect_state(SSL *s) {
+    return SSL_set_connect_state(s);
+}
+NODE_CRYPTO_EXTERN int Thin_X509_verify(X509 *a, EVP_PKEY *r) {
+    return X509_verify(a, r);
+}
+NODE_CRYPTO_EXTERN int Thin_X509_check_private_key(const X509 *x509, const EVP_PKEY *pkey) {
+    return X509_check_private_key(x509, pkey);
+}
+NODE_CRYPTO_EXTERN int Thin_X509_check_host(X509 *x, const char *chk, size_t chklen,
+                    unsigned int flags, char **peername) {
+    return X509_check_host(x, chk, chklen, flags, peername);
+}
+NODE_CRYPTO_EXTERN int Thin_X509_check_email(X509 *x, const char *chk, size_t chklen,
+                     unsigned int flags) {
+    return X509_check_email(x, chk, chklen, flags);
+}
+NODE_CRYPTO_EXTERN int Thin_X509_check_ip(X509 *x, const unsigned char *chk, size_t chklen,
+                  unsigned int flags) {
+    return X509_check_ip(x, chk, chklen, flags);
+}
+NODE_CRYPTO_EXTERN EVP_PKEY *Thin_X509_PUBKEY_get(X509_PUBKEY *key) {
+    return X509_PUBKEY_get(key);
+}
+NODE_CRYPTO_EXTERN unsigned long Thin_OpenSSL_version_num(void) {
+    return OpenSSL_version_num();
+}
+NODE_CRYPTO_EXTERN int Thin_SSL_select_next_proto(unsigned char **out, unsigned char *outlen,
+                                 const unsigned char *in, unsigned int inlen,
+                                 const unsigned char *client,
+                                 unsigned int client_len) {
+    return SSL_select_next_proto(out, outlen, in, inlen, client, client_len);
+}
+NODE_CRYPTO_EXTERN int Thin_SSL_CTX_set_cipher_list(SSL_CTX *ctx, const char *str) {
+    return SSL_CTX_set_cipher_list(ctx, str);
+}
+NODE_CRYPTO_EXTERN int Thin_X509_digest(const X509 *data, const EVP_MD *type,
+                unsigned char *md, unsigned int *len) {
+    return X509_digest(data, type, md, len);
+}
+NODE_CRYPTO_EXTERN ASN1_INTEGER *Thin_X509_get_serialNumber(X509 *x) {
+    return X509_get_serialNumber(x);
+}
+NODE_CRYPTO_EXTERN  X509_CRL *Thin_PEM_read_bio_X509_CRL(BIO *bp, X509_CRL **x,
+                                 pem_password_cb *cb, void *u) {
+    return PEM_read_bio_X509_CRL(bp, x, cb, u);
+}
+
+NODE_CRYPTO_EXTERN const char *Thin_SSL_CIPHER_get_version(const SSL_CIPHER *c) {
+    return SSL_CIPHER_get_version(c);
+}
+NODE_CRYPTO_EXTERN int Thin_SSL_is_server(const SSL *s) {
+    return SSL_is_server(s);
+}
+NODE_CRYPTO_EXTERN const ASN1_TIME *Thin_X509_get0_notAfter(const X509 *x) {
+    return X509_get0_notAfter(x);
+}
+NODE_CRYPTO_EXTERN const ASN1_TIME * Thin_X509_get0_notBefore(const X509 *x) {
+    return X509_get0_notBefore(x);
+}
+NODE_CRYPTO_EXTERN int Thin_ASN1_TIME_print(BIO *fp, const ASN1_TIME *a) {
+    return ASN1_TIME_print(fp, a);
+}
+NODE_CRYPTO_EXTERN int Thin_X509_STORE_up_ref(X509_STORE *v) {
+    return X509_STORE_up_ref(v);
+}
+NODE_CRYPTO_EXTERN int Thin_X509_check_ca(X509 *x) {
+    return X509_check_ca(x);
+}
+NODE_CRYPTO_EXTERN int Thin_X509_check_ip_asc(X509 *x, const char *ipasc, unsigned int flags) {
+    return X509_check_ip_asc(x, ipasc, flags);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_PKEY_verify_recover_init(EVP_PKEY_CTX *ctx) {
+    return EVP_PKEY_verify_recover_init(ctx);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_PKEY_sign(EVP_PKEY_CTX *ctx,
+                  unsigned char *sig, size_t *siglen,
+                  const unsigned char *tbs, size_t tbslen) {
+    return EVP_PKEY_sign(ctx, sig, siglen, tbs, tbslen);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_BytesToKey(const EVP_CIPHER *type, const EVP_MD *md,
+                          const unsigned char *salt,
+                          const unsigned char *data, int datal, int count,
+                          unsigned char *key, unsigned char *iv) {
+    return EVP_BytesToKey(type, md, salt, data, datal, count, key, iv);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_CIPHER_block_size(const EVP_CIPHER *cipher) {
+    return EVP_CIPHER_block_size(cipher);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_CIPHER_impl_ctx_size(const EVP_CIPHER *cipher) {
+    return EVP_CIPHER_impl_ctx_size(cipher);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_CIPHER_key_length(const EVP_CIPHER *cipher) {
+    return EVP_CIPHER_key_length(cipher);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_CIPHER_iv_length(const EVP_CIPHER *cipher) {
+    return EVP_CIPHER_iv_length(cipher);
+}
+NODE_CRYPTO_EXTERN unsigned long Thin_EVP_CIPHER_flags(const EVP_CIPHER *cipher) {
+    return EVP_CIPHER_flags(cipher);
+}
+
+NODE_CRYPTO_EXTERN void Thin_SSL_set_accept_state(SSL *s) {
+    return SSL_set_accept_state(s);
+}
+NODE_CRYPTO_EXTERN void Thin_SSL_set_info_callback(SSL *ssl,
+                           void (*cb) (const SSL *ssl, int type, int val)) {
+    return SSL_set_info_callback(ssl, cb);
+}
+
+NODE_CRYPTO_EXTERN int Thin_SSL_set_ex_data(SSL *ssl, int idx, void *data) {
+    return SSL_set_ex_data(ssl, idx, data);
+}
+NODE_CRYPTO_EXTERN size_t Thin_SSL_get_peer_finished(const SSL *s, void *buf, size_t count) {
+    return SSL_get_peer_finished(s, buf, count);
+}
+
+NODE_CRYPTO_EXTERN const struct dsa_st *Thin_EVP_PKEY_get0_DSA(EVP_PKEY *pkey) {
+    return EVP_PKEY_get0_DSA(pkey);
+}
+
+NODE_CRYPTO_EXTERN void Thin_ASN1_OBJECT_free(ASN1_OBJECT *a) {
+    return ASN1_OBJECT_free(a);
+}
+
+NODE_CRYPTO_EXTERN DH *Thin_DH_new(void) {
+    return DH_new();
+}
+
+NODE_CRYPTO_EXTERN int Thin_BN_is_zero(const BIGNUM *a) {
+    return BN_is_zero(a);
+}
+
+NODE_CRYPTO_EXTERN int Thin_BN_is_one(const BIGNUM *a) {
+    return BN_is_one(a);
+}
+
+NODE_CRYPTO_EXTERN int Thin_DH_set0_pqg(DH *dh, BIGNUM *p, BIGNUM *q, BIGNUM *g) {
+    return DH_set0_pqg(dh, p, q, g);
+}
+
+NODE_CRYPTO_EXTERN const EVP_MD *Thin_EVP_get_digestbyname(const char *name) {
+    return EVP_get_digestbyname(name);
+}
+
+NODE_CRYPTO_EXTERN int Thin_EVP_MD_CTX_copy(EVP_MD_CTX *out, const EVP_MD_CTX *in) {
+    return EVP_MD_CTX_copy(out, in);
+}
+
+NODE_CRYPTO_EXTERN unsigned long Thin_ERR_get_error(void) {
+    return ERR_get_error();
+}
+
+NODE_CRYPTO_EXTERN int Thin_CRYPTO_memcmp(const void * in_a, const void * in_b, size_t len) {
+    return CRYPTO_memcmp(in_a, in_b, len);
+}
+
+NODE_CRYPTO_EXTERN int Thin_EVP_CipherInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
+                   const unsigned char *key, const unsigned char *iv,
+                   int enc) {
+    return EVP_CipherInit(ctx, cipher, key, iv, enc);
+}
+
+NODE_CRYPTO_EXTERN int Thin_EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx,
+                      const EVP_CIPHER *cipher, ENGINE *impl,
+                      const unsigned char *key,
+                      const unsigned char *iv, int enc) {
+    return EVP_CipherInit_ex(ctx, cipher, impl, key, iv, enc);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
+                     int *outl, const unsigned char *in, int inl) {
+    return EVP_CipherUpdate(ctx, out, outl, in, inl);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_CipherFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm,
+                    int *outl) {
+    return EVP_CipherFinal(ctx, outm, outl);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_CipherFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm,
+                       int *outl) {
+    return EVP_CipherFinal_ex(ctx, outm, outl);
+}
+
+NODE_CRYPTO_EXTERN BIO *Thin_BIO_new_mem_buf(const void *buf, int len) {
+    return BIO_new_mem_buf(buf, len);
+}
+NODE_CRYPTO_EXTERN HMAC_CTX *Thin_HMAC_CTX_new(void) {
+    return HMAC_CTX_new();
+}
+NODE_CRYPTO_EXTERN void *Thin_ASN1_SCTX_get_app_data(ASN1_SCTX *p) {
+    return ASN1_SCTX_get_app_data(p);
+}
+NODE_CRYPTO_EXTERN EVP_PKEY_CTX *Thin_EVP_PKEY_CTX_new(EVP_PKEY *pkey, ENGINE *e) {
+    return EVP_PKEY_CTX_new(pkey, e);
+}
+NODE_CRYPTO_EXTERN EVP_PKEY_CTX *Thin_EVP_PKEY_CTX_new_id(int id, ENGINE *e) {
+    return EVP_PKEY_CTX_new_id(id, e);
+}
+
+NODE_CRYPTO_EXTERN void Thin_BIO_set_init(BIO *a, int init) {
+    return BIO_set_init(a, init);
+}
+NODE_CRYPTO_EXTERN void *Thin_BIO_get_data(BIO *a) {
+    return BIO_get_data(a);
+}
+NODE_CRYPTO_EXTERN int Thin_BIO_get_shutdown(BIO *a) {
+    return BIO_get_shutdown(a);
+}
+NODE_CRYPTO_EXTERN void Thin_BIO_set_data(BIO *a, void *ptr) {
+    return BIO_set_data(a, ptr);
+}
+NODE_CRYPTO_EXTERN void Thin_ERR_error_string_n(unsigned long e, char *buf, size_t len) {
+    return ERR_error_string_n(e, buf, len);
+}
+NODE_CRYPTO_EXTERN const char *Thin_ERR_lib_error_string(unsigned long e) {
+    return ERR_lib_error_string(e);
+}
+
+NODE_CRYPTO_EXTERN long Thin_SSL_ctrl(SSL *ssl, int cmd, long larg, void *parg) {
+    return SSL_ctrl(ssl, cmd, larg, parg);
+}
+NODE_CRYPTO_EXTERN long Thin_SSL_callback_ctrl(SSL *ssl, int cmd, void (*fn)(void)) {
+    return SSL_callback_ctrl(ssl, cmd, fn);
+}
+NODE_CRYPTO_EXTERN long Thin_SSL_CTX_ctrl(SSL_CTX *ctx, int cmd, long larg, void *parg) {
+    return SSL_CTX_ctrl(ctx, cmd, larg, parg);
+}
+NODE_CRYPTO_EXTERN long Thin_SSL_CTX_callback_ctrl(SSL_CTX *ctx, int cmd, void (*fn)(void)) {
+    return SSL_CTX_callback_ctrl(ctx, cmd, fn);
+}
+
+NODE_CRYPTO_EXTERN int Thin_EVP_PKEY_encrypt_init(EVP_PKEY_CTX *ctx) {
+    return EVP_PKEY_encrypt_init(ctx);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_PKEY_encrypt(EVP_PKEY_CTX *ctx,
+                     unsigned char *out, size_t *outlen,
+                     const unsigned char *in, size_t inlen) {
+    return EVP_PKEY_encrypt(ctx, out, outlen, in, inlen);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_PKEY_decrypt_init(EVP_PKEY_CTX *ctx) {
+    return EVP_PKEY_decrypt_init(ctx);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_PKEY_decrypt(EVP_PKEY_CTX *ctx,
+                     unsigned char *out, size_t *outlen,
+                     const unsigned char *in, size_t inlen) {
+    return EVP_PKEY_decrypt(ctx, out, outlen, in, inlen);
+}
+NODE_CRYPTO_EXTERN void Thin_RSA_get0_key(const RSA *r,
+                  const BIGNUM **n, const BIGNUM **e, const BIGNUM **d) {
+    return RSA_get0_key(r, n, e, d);
+}
+NODE_CRYPTO_EXTERN const struct rsa_st *Thin_EVP_PKEY_get0_RSA(EVP_PKEY *pkey) {
+    return EVP_PKEY_get0_RSA(pkey);
+}
+NODE_CRYPTO_EXTERN struct rsa_st *Thin_EVP_PKEY_get1_RSA(EVP_PKEY *pkey) {
+    return EVP_PKEY_get1_RSA(pkey);
+}
+
+NODE_CRYPTO_EXTERN int Thin_SSL_CTX_set_ex_data(SSL_CTX *ssl, int idx, void *data) {
+    return SSL_CTX_set_ex_data(ssl, idx, data);
+}
+NODE_CRYPTO_EXTERN void *Thin_SSL_CTX_get_ex_data(const SSL_CTX *ssl, int idx) {
+    return SSL_CTX_get_ex_data(ssl, idx);
+}
+
+NODE_CRYPTO_EXTERN void *Thin_CRYPTO_secure_malloc(size_t num, const char *file, int line) {
+    return CRYPTO_secure_malloc(num, file, line);
+}
+
+NODE_CRYPTO_EXTERN int Thin_CRYPTO_secure_malloc_init(size_t sz, int minsize) {
+    return CRYPTO_secure_malloc_init(sz, minsize);
+}
+NODE_CRYPTO_EXTERN int Thin_CRYPTO_secure_malloc_initialized(void) {
+    return CRYPTO_secure_malloc_initialized();
+}
+NODE_CRYPTO_EXTERN void Thin_ENGINE_load_builtin_engines(void) {
+    return ENGINE_load_builtin_engines();
+}
+NODE_CRYPTO_EXTERN int Thin_ERR_load_ENGINE_strings(void) {
+    return ERR_load_ENGINE_strings();
+}
+NODE_CRYPTO_EXTERN int Thin_OPENSSL_init_ssl(uint64_t opts, const OPENSSL_INIT_SETTINGS *settings) {
+    return OPENSSL_init_ssl(opts, settings);
+}
+NODE_CRYPTO_EXTERN int Thin_RAND_bytes(unsigned char *buf, int num) {
+    return RAND_bytes(buf, num);
+}
+NODE_CRYPTO_EXTERN int Thin_BN_set_word(BIGNUM *a, BN_ULONG w) {
+    return BN_set_word(a, w);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_CIPHER_CTX_block_size(const EVP_CIPHER_CTX *ctx) {
+    return EVP_CIPHER_CTX_block_size(ctx);
+}
+NODE_CRYPTO_EXTERN EVP_CIPHER_CTX *Thin_EVP_CIPHER_CTX_new(void) {
+    return EVP_CIPHER_CTX_new();
+}
+NODE_CRYPTO_EXTERN NETSCAPE_SPKI *Thin_NETSCAPE_SPKI_b64_decode(const char *str, int len) {
+    return NETSCAPE_SPKI_b64_decode(str, len);
+}
+NODE_CRYPTO_EXTERN int Thin_NETSCAPE_SPKI_verify(NETSCAPE_SPKI *a, EVP_PKEY *r) {
+    return NETSCAPE_SPKI_verify(a, r);
+}
+NODE_CRYPTO_EXTERN int Thin_X509V3_EXT_print(BIO *out, X509_EXTENSION *ext, unsigned long flag, int indent) {
+    return X509V3_EXT_print(out, ext, flag, indent);
+}
+NODE_CRYPTO_EXTERN int Thin_X509_get_ext_by_NID(const X509 *x, int nid, int lastpos) {
+    return X509_get_ext_by_NID(x, nid, lastpos);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_PKEY_derive(EVP_PKEY_CTX *ctx, unsigned char *key, size_t *keylen) {
+    return EVP_PKEY_derive(ctx, key, keylen);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_MD_size(const EVP_MD *md) {
+    return EVP_MD_size(md);
+}
+NODE_CRYPTO_EXTERN X509_STORE *Thin_SSL_CTX_get_cert_store(const SSL_CTX *ctx) {
+    return SSL_CTX_get_cert_store(ctx);
+}
+NODE_CRYPTO_EXTERN int Thin_X509_STORE_add_crl(X509_STORE *ctx, X509_CRL *x) {
+    return X509_STORE_add_crl(ctx, x);
+}
+NODE_CRYPTO_EXTERN int Thin_X509_STORE_set_flags(X509_STORE *ctx, unsigned long flags) {
+    return X509_STORE_set_flags(ctx, flags);
+}
+NODE_CRYPTO_EXTERN unsigned long Thin_ERR_peek_last_error(void) {
+    return ERR_peek_last_error();
+}
+NODE_CRYPTO_EXTERN int Thin_sk_X509_push(STACK_OF(X509) *sk, X509 *x) {
+    return sk_X509_push(sk, x);
+}
+NODE_CRYPTO_EXTERN STACK_OF(X509) *Thin_sk_X509_new_null() {
+    return sk_X509_new_null();
+}
+NODE_CRYPTO_EXTERN const EC_POINT *Thin_EC_KEY_get0_public_key(const EC_KEY *key) {
+    return EC_KEY_get0_public_key(key);
+}
+NODE_CRYPTO_EXTERN X509 *Thin_PEM_read_bio_X509(BIO *bp, X509 **x, pem_password_cb *cb, void *u) {
+    return PEM_read_bio_X509(bp, x, cb, u);
+}
+NODE_CRYPTO_EXTERN int Thin_PKCS12_parse(PKCS12 *p12, const char *pass, EVP_PKEY **pkey, X509 **cert, STACK_OF(X509) **ca) {
+    return PKCS12_parse(p12, pass, pkey, cert, ca);
+}
+NODE_CRYPTO_EXTERN const EC_GROUP *Thin_EC_KEY_get0_group(const EC_KEY *key) {
+    return EC_KEY_get0_group(key);
+}
+NODE_CRYPTO_EXTERN const char *Thin_ERR_reason_error_string(unsigned long e) {
+    return ERR_reason_error_string(e);
+}
+NODE_CRYPTO_EXTERN int Thin_SSL_CTX_add_client_CA(SSL_CTX *ctx, X509 *x) {
+    return SSL_CTX_add_client_CA(ctx, x);
+}
+NODE_CRYPTO_EXTERN const unsigned char *Thin_SSL_SESSION_get_id(const SSL_SESSION *s, unsigned int *len) {
+    return SSL_SESSION_get_id(s, len);
+}
+NODE_CRYPTO_EXTERN int Thin_i2d_SSL_SESSION(SSL_SESSION *in, unsigned char **pp) {
+    return i2d_SSL_SESSION(in, pp);
+}
+NODE_CRYPTO_EXTERN SSL_SESSION *Thin_d2i_SSL_SESSION(SSL_SESSION **a, const unsigned char **pp, long length) {
+    return d2i_SSL_SESSION(a, pp, length);
+}
+NODE_CRYPTO_EXTERN const X509V3_EXT_METHOD *Thin_X509V3_EXT_get(X509_EXTENSION *ext) {
+    return X509V3_EXT_get(ext);
+}
+NODE_CRYPTO_EXTERN const X509V3_EXT_METHOD *Thin_X509V3_EXT_get_nid(int nid) {
+    return X509V3_EXT_get_nid(nid);
+}
+NODE_CRYPTO_EXTERN void *Thin_X509V3_EXT_d2i(X509_EXTENSION *ext) {
+    return X509V3_EXT_d2i(ext);
+}
+NODE_CRYPTO_EXTERN X509_NAME *Thin_X509_get_issuer_name(const X509 *a) {
+    return X509_get_issuer_name(a);
+}
+NODE_CRYPTO_EXTERN int Thin_X509_NAME_print_ex(BIO *out, const X509_NAME *nm, int indent,
+                       unsigned long flags) {
+    return X509_NAME_print_ex(out, nm, indent, flags);
+}
+NODE_CRYPTO_EXTERN const SSL_CIPHER *Thin_SSL_get_current_cipher(const SSL *s) {
+    return SSL_get_current_cipher(s);
+}
+NODE_CRYPTO_EXTERN const SSL_METHOD *Thin_TLS_server_method(void) {
+    return TLS_server_method();
+}
+NODE_CRYPTO_EXTERN const SSL_METHOD *Thin_TLS_client_method(void) {
+    return TLS_client_method();
+}
+NODE_CRYPTO_EXTERN EVP_PKEY *Thin_PEM_read_bio_PrivateKey(BIO *bp, EVP_PKEY **x,
+                                   pem_password_cb *cb, void *u) {
+    return PEM_read_bio_PrivateKey(bp, x, cb, u);
+}
+NODE_CRYPTO_EXTERN int Thin_X509_STORE_CTX_init(X509_STORE_CTX *ctx, X509_STORE *store,
+                        X509 *x509, STACK_OF(X509) *chain) {
+    return X509_STORE_CTX_init(ctx, store, x509, chain);
+}
+NODE_CRYPTO_EXTERN int Thin_X509_STORE_CTX_get1_issuer(X509 **issuer, X509_STORE_CTX *ctx, X509 *x) {
+    return X509_STORE_CTX_get1_issuer(issuer, ctx, x);
+}
+NODE_CRYPTO_EXTERN long Thin_SSL_get_verify_result(const SSL *ssl) {
+    return SSL_get_verify_result(ssl);
+}
+NODE_CRYPTO_EXTERN SSL_SESSION *Thin_SSL_get_session(const SSL *ssl) {
+    return SSL_get_session(ssl);
+}
+NODE_CRYPTO_EXTERN void Thin_SSL_SESSION_get0_ticket(const SSL_SESSION *s, const unsigned char **tick,
+                             size_t *len) {
+    return SSL_SESSION_get0_ticket(s, tick, len);
+}
+NODE_CRYPTO_EXTERN int Thin_SSL_CIPHER_get_auth_nid(const SSL_CIPHER *c) {
+    return SSL_CIPHER_get_auth_nid(c);
+}
+NODE_CRYPTO_EXTERN int Thin_SSL_SESSION_get_protocol_version(const SSL_SESSION *s) {
+    return SSL_SESSION_get_protocol_version(s);
+}
+NODE_CRYPTO_EXTERN int Thin_SSL_session_reused(const SSL *s) {
+    return SSL_session_reused(s);
+}
+NODE_CRYPTO_EXTERN X509_STORE *Thin_X509_STORE_new(void) {
+    return X509_STORE_new();
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_PKEY_bits(const EVP_PKEY *pkey) {
+    return EVP_PKEY_bits(pkey);
+}
+NODE_CRYPTO_EXTERN int Thin_X509_STORE_load_locations(X509_STORE *ctx,
+                              const char *file, const char *dir) {
+    return X509_STORE_load_locations(ctx, file, dir);
+}
+NODE_CRYPTO_EXTERN int Thin_X509_STORE_set_default_paths(X509_STORE *ctx) {
+    return X509_STORE_set_default_paths(ctx);
+}
+NODE_CRYPTO_EXTERN void Thin_SSL_set_cert_cb(SSL *s, int (*cb) (SSL *ssl, void *arg), void *arg) {
+    return SSL_set_cert_cb(s, cb, arg);
+}
+NODE_CRYPTO_EXTERN int Thin_SSL_read(SSL *ssl, void *buf, int num) {
+    return SSL_read(ssl, buf, num);
+}
+NODE_CRYPTO_EXTERN int Thin_SSL_write(SSL *ssl, const void *buf, int num) {
+    return SSL_write(ssl, buf, num);
+}
+NODE_CRYPTO_EXTERN int Thin_SSL_shutdown(SSL *s) {
+    return SSL_shutdown(s);
+}
+NODE_CRYPTO_EXTERN const char *Thin_ERR_func_error_string(unsigned long e) {
+    return ERR_func_error_string(e);
+}
+NODE_CRYPTO_EXTERN int Thin_SSL_get_shutdown(const SSL *ssl) {
+    return SSL_get_shutdown(ssl);
+}
+NODE_CRYPTO_EXTERN void Thin_ERR_print_errors(BIO *bp) {
+    return ERR_print_errors(bp);
+}
+NODE_CRYPTO_EXTERN int Thin_SSL_get_error(const SSL *s, int ret_code) {
+    return SSL_get_error(s, ret_code);
+}
+NODE_CRYPTO_EXTERN X509_NAME *Thin_X509_get_subject_name(const X509 *a) {
+    return X509_get_subject_name(a);
+}
+NODE_CRYPTO_EXTERN int Thin_PKCS5_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,
+                            ASN1_TYPE *param, const EVP_CIPHER *cipher,
+                            const EVP_MD *md, int en_de) {
+    return PKCS5_PBE_keyivgen(ctx, pass, passlen, param, cipher, md, en_de);
+}
+NODE_CRYPTO_EXTERN int Thin_PKCS5_PBKDF2_HMAC_SHA1(const char *pass, int passlen,
+                                const unsigned char *salt, int saltlen, int iter,
+                                int keylen, unsigned char *out) {
+    return PKCS5_PBKDF2_HMAC_SHA1(pass, passlen, salt, saltlen, iter, keylen, out);
+}
+NODE_CRYPTO_EXTERN int Thin_PKCS5_PBKDF2_HMAC(const char *pass, int passlen,
+                           const unsigned char *salt, int saltlen, int iter,
+                           const EVP_MD *digest, int keylen, unsigned char *out) {
+    return PKCS5_PBKDF2_HMAC(pass, passlen, salt, saltlen, iter, digest, keylen, out);
+}
+NODE_CRYPTO_EXTERN int Thin_PKCS5_v2_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,
+                               ASN1_TYPE *param, const EVP_CIPHER *cipher,
+                               const EVP_MD *md, int en_de) {
+    return PKCS5_v2_PBE_keyivgen(ctx, pass, passlen, param, cipher, md, en_de);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_PBE_scrypt(const char *pass, size_t passlen,
+                        const unsigned char *salt, size_t saltlen,
+                        uint64_t N, uint64_t r, uint64_t p, uint64_t maxmem,
+                        unsigned char *key, size_t keylen) {
+    return EVP_PBE_scrypt(pass, passlen, salt, saltlen, N, r, p, maxmem, key, keylen);
+}
+NODE_CRYPTO_EXTERN int Thin_DH_generate_key(DH *dh) {
+    return DH_generate_key(dh);
+}
+
+NODE_CRYPTO_EXTERN void Thin_DH_get0_key(const DH *dh, const BIGNUM **pub_key, const BIGNUM **priv_key) {
+    return DH_get0_key(dh, pub_key, priv_key);
+}
+NODE_CRYPTO_EXTERN int Thin_DH_set0_key(DH *dh, BIGNUM *pub_key, BIGNUM *priv_key) {
+    return DH_set0_key(dh, pub_key, priv_key);
+}
+
+NODE_CRYPTO_EXTERN int Thin_EVP_PKEY_derive_init(EVP_PKEY_CTX *ctx) {
+    return EVP_PKEY_derive_init(ctx);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_PKEY_base_id(const EVP_PKEY *pkey) {
+    return EVP_PKEY_base_id(pkey);
+}
+
+NODE_CRYPTO_EXTERN void Thin_DSA_get0_pqg(const DSA *d, const BIGNUM **p, const BIGNUM **q, const BIGNUM **g) {
+    return DSA_get0_pqg(d, p, q, g);
+}
+NODE_CRYPTO_EXTERN int Thin_DSA_set0_pqg(DSA *d, BIGNUM *p, BIGNUM *q, BIGNUM *g) {
+    return DSA_set0_pqg(d, p, q, g);
+}
+NODE_CRYPTO_EXTERN void Thin_DSA_get0_key(const DSA *d, const BIGNUM **pub_key, const BIGNUM **priv_key) {
+    return DSA_get0_key(d, pub_key, priv_key);
+}
+NODE_CRYPTO_EXTERN int Thin_DSA_set0_key(DSA *d, BIGNUM *pub_key, BIGNUM *priv_key) {
+    return DSA_set0_key(d, pub_key, priv_key);
+}
+NODE_CRYPTO_EXTERN const BIGNUM *Thin_DSA_get0_p(const DSA *d) {
+    return DSA_get0_p(d);
+}
+NODE_CRYPTO_EXTERN const BIGNUM *Thin_DSA_get0_q(const DSA *d) {
+    return DSA_get0_q(d);
+}
+NODE_CRYPTO_EXTERN const BIGNUM *Thin_DSA_get0_g(const DSA *d) {
+    return DSA_get0_g(d);
+}
+NODE_CRYPTO_EXTERN const BIGNUM *Thin_DSA_get0_pub_key(const DSA *d) {
+    return DSA_get0_pub_key(d);
+}
+NODE_CRYPTO_EXTERN const BIGNUM *Thin_DSA_get0_priv_key(const DSA *d) {
+    return DSA_get0_priv_key(d);
+}
+NODE_CRYPTO_EXTERN int Thin_BN_num_bits(const BIGNUM *a) {
+    return BN_num_bits(a);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_PKEY_id(const EVP_PKEY *pkey) {
+    return EVP_PKEY_id(pkey);
+}
+
+NODE_CRYPTO_EXTERN EVP_MD_CTX *Thin_EVP_MD_CTX_new(void) {
+    return EVP_MD_CTX_new();
+}
+NODE_CRYPTO_EXTERN SSL_CTX *Thin_SSL_get_SSL_CTX(const SSL *ssl) {
+    return SSL_get_SSL_CTX(ssl);
+}
+NODE_CRYPTO_EXTERN const BIO_METHOD *Thin_BIO_s_mem(void) {
+    return BIO_s_mem();
+}
+NODE_CRYPTO_EXTERN X509_EXTENSION *Thin_X509_get_ext(const X509 *x, int loc) {
+    return X509_get_ext(x, loc);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_PKEY_paramgen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey) {
+    return EVP_PKEY_paramgen(ctx, ppkey);
+}
+
+NODE_CRYPTO_EXTERN int Thin_HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len, const EVP_MD *md, ENGINE *impl) {
+    return HMAC_Init_ex(ctx, key, len, md, impl);
+}
+NODE_CRYPTO_EXTERN int Thin_HMAC_Update(HMAC_CTX *ctx, const unsigned char *data, size_t len) {
+    return HMAC_Update(ctx, data, len);
+}
+NODE_CRYPTO_EXTERN int Thin_HMAC_Final(HMAC_CTX *ctx, unsigned char *md, unsigned int *len) {
+    return HMAC_Final(ctx, md, len);
+}
+NODE_CRYPTO_EXTERN unsigned char *Thin_HMAC(const EVP_MD *evp_md, const void *key, int key_len,
+                         const unsigned char *d, size_t n, unsigned char *md,
+                         unsigned int *md_len) {
+    return HMAC(evp_md, key, key_len, d, n, md, md_len);
+}
+
+
+NODE_CRYPTO_EXTERN int Thin_BN_cmp(const BIGNUM *a, const BIGNUM *b) {
+    return BN_cmp(a, b);
+}
+NODE_CRYPTO_EXTERN BN_CTX *Thin_BN_CTX_new(void) {
+    return BN_CTX_new();
+}
+NODE_CRYPTO_EXTERN int Thin_BN_is_prime_ex(const BIGNUM *p, int nchecks, BN_CTX *ctx, BN_GENCB *cb) {
+    return BN_is_prime_ex(p, nchecks, ctx, cb);
+}
+NODE_CRYPTO_EXTERN int Thin_SSL_CTX_use_certificate(SSL_CTX *ctx, X509 *x) {
+    return SSL_CTX_use_certificate(ctx, x);
+}
+NODE_CRYPTO_EXTERN int Thin_X509_check_issued(X509 *issuer, X509 *subject) {
+    return X509_check_issued(issuer, subject);
+}
+NODE_CRYPTO_EXTERN X509 *Thin_X509_dup(X509 *x509) {
+    return X509_dup(x509);
+}
+NODE_CRYPTO_EXTERN BIO *Thin_BIO_new(const BIO_METHOD *type) {
+    return BIO_new(type);
+}
+NODE_CRYPTO_EXTERN EVP_PKEY *Thin_d2i_PUBKEY(EVP_PKEY **a, const unsigned char **pp, long length) {
+    return d2i_PUBKEY(a, pp, length);
+}
+NODE_CRYPTO_EXTERN int Thin_PEM_bytes_read_bio(unsigned char **pdata, long *plen, char **pnm,
+                            const char *name, BIO *bp, pem_password_cb *cb,
+                            void *u) {
+    return PEM_bytes_read_bio(pdata, plen, pnm, name, bp, cb, u);
+}
+
+NODE_CRYPTO_EXTERN int Thin_BN_generate_prime_ex(BIGNUM *ret, int bits, int safe, const BIGNUM *add, const BIGNUM *rem, BN_GENCB *cb) {
+    return BN_generate_prime_ex(ret, bits, safe, add, rem, cb);
+}
+
+NODE_CRYPTO_EXTERN int Thin_EVP_PKEY_paramgen_init(EVP_PKEY_CTX *ctx) {
+    return EVP_PKEY_paramgen_init(ctx);
+}
+NODE_CRYPTO_EXTERN EVP_PKEY *Thin_NETSCAPE_SPKI_get_pubkey(NETSCAPE_SPKI *x) {
+    return NETSCAPE_SPKI_get_pubkey(x);
+}
+NODE_CRYPTO_EXTERN int Thin_BIO_write(BIO *b, const void *data, int dlen) {
+    return BIO_write(b, data, dlen);
+}
+NODE_CRYPTO_EXTERN void Thin_DH_get0_pqg(const DH *dh, const BIGNUM **p, const BIGNUM **q, const BIGNUM **g) {
+    return DH_get0_pqg(dh, p, q, g);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_PKEY_derive_set_peer(EVP_PKEY_CTX *ctx, EVP_PKEY *peer) {
+    return EVP_PKEY_derive_set_peer(ctx, peer);
+}
+NODE_CRYPTO_EXTERN int Thin_BN_bn2binpad(const BIGNUM *a, unsigned char *to, int tolen) {
+    return BN_bn2binpad(a, to, tolen);
+}
+
+NODE_CRYPTO_EXTERN int Thin_EVP_DigestInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl) {
+    return EVP_DigestInit_ex(ctx, type, impl);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_DigestUpdate(EVP_MD_CTX *ctx, const void *d, size_t cnt) {
+    return EVP_DigestUpdate(ctx, d, cnt);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_DigestFinal_ex(EVP_MD_CTX *ctx, unsigned char *md, unsigned int *s) {
+    return EVP_DigestFinal_ex(ctx, md, s);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_Digest(const void *data, size_t count,
+                    unsigned char *md, unsigned int *size,
+                    const EVP_MD *type, ENGINE *impl) {
+    return EVP_Digest(data, count, md, size, type, impl);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_DigestFinalXOF(EVP_MD_CTX *ctx, unsigned char *md, size_t len) {
+    return EVP_DigestFinalXOF(ctx, md, len);
+}
+
+NODE_CRYPTO_EXTERN int Thin_EVP_PKEY_size(const EVP_PKEY *pkey) {
+    return EVP_PKEY_size(pkey);
+}
+NODE_CRYPTO_EXTERN const EVP_MD *Thin_EVP_MD_CTX_md(const EVP_MD_CTX *ctx) {
+    return EVP_MD_CTX_md(ctx);
+}
+
+NODE_CRYPTO_EXTERN unsigned long Thin_EVP_MD_flags(const EVP_MD *md) {
+    return EVP_MD_flags(md);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_PKEY_sign_init(EVP_PKEY_CTX *ctx) {
+    return EVP_PKEY_sign_init(ctx);
+}
+NODE_CRYPTO_EXTERN void Thin_EVP_MD_do_all_sorted(void (*fn)(const EVP_MD *ciph, const char *from, const char *to, void *x), void *arg) {
+    return EVP_MD_do_all_sorted(fn, arg);
+}
+
+NODE_CRYPTO_EXTERN int Thin_SSL_set_alpn_protos(SSL *ssl, const unsigned char *protos, unsigned int protos_len) {
+    return SSL_set_alpn_protos(ssl, protos, protos_len);
+}
+NODE_CRYPTO_EXTERN X509 *Thin_SSL_get_peer_certificate(const SSL *s) {
+    return SSL_get_peer_certificate(s);
+}
+
+NODE_CRYPTO_EXTERN void *Thin_X509_get_ext_d2i(const X509 *x, int nid, int *crit, int *idx) {
+    return X509_get_ext_d2i(x, nid, crit, idx);
+}
+NODE_CRYPTO_EXTERN EVP_PKEY *Thin_X509_get_pubkey(X509 *x) {
+    return X509_get_pubkey(x);
+}
+
+NODE_CRYPTO_EXTERN BIGNUM *Thin_BN_secure_new(void) {
+    return BN_secure_new();
+}
+
+NODE_CRYPTO_EXTERN EVP_PKEY *Thin_EVP_PKEY_new(void) {
+    return EVP_PKEY_new();
+}
+NODE_CRYPTO_EXTERN EVP_PKEY *Thin_EVP_PKEY_new_mac_key(int type, ENGINE *e, const unsigned char *key, int keylen) {
+    return EVP_PKEY_new_mac_key(type, e, key, keylen);
+}
+NODE_CRYPTO_EXTERN EVP_PKEY *Thin_EVP_PKEY_new_raw_private_key(int type, ENGINE *e,
+                                            const unsigned char *priv,
+                                            size_t len) {
+    return EVP_PKEY_new_raw_private_key(type, e, priv, len);
+}
+NODE_CRYPTO_EXTERN EVP_PKEY *Thin_EVP_PKEY_new_raw_public_key(int type, ENGINE *e,
+                                           const unsigned char *pub,
+                                           size_t len) {
+    return EVP_PKEY_new_raw_public_key(type, e, pub, len);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_PKEY_get_raw_private_key(const EVP_PKEY *pkey, unsigned char *priv, size_t *len) {
+    return EVP_PKEY_get_raw_private_key(pkey, priv, len);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_PKEY_get_raw_public_key(const EVP_PKEY *pkey, unsigned char *pub, size_t *len) {
+    return EVP_PKEY_get_raw_public_key(pkey, pub, len);
+}
+
+NODE_CRYPTO_EXTERN size_t Thin_CRYPTO_secure_used(void) {
+    return CRYPTO_secure_used();
+}
+
+NODE_CRYPTO_EXTERN int Thin_RAND_status(void) {
+    return RAND_status();
+}
+NODE_CRYPTO_EXTERN int Thin_RAND_poll(void) {
+    return RAND_poll();
+}
+NODE_CRYPTO_EXTERN int Thin_X509_up_ref(X509 *x) {
+    return X509_up_ref(x);
+}
+NODE_CRYPTO_EXTERN BIO *Thin_BIO_new_fp(FILE *stream, int close_flag) {
+    return BIO_new_fp(stream, close_flag);
+}
+
+NODE_CRYPTO_EXTERN BIO *Thin_BIO_new_file(const char *filename, const char *mode) {
+    return BIO_new_file(filename, mode);
+}
+
+NODE_CRYPTO_EXTERN OPENSSL_INIT_SETTINGS *Thin_OPENSSL_INIT_new(void) {
+    return OPENSSL_INIT_new();
+}
+NODE_CRYPTO_EXTERN void Thin_OPENSSL_INIT_set_config_file_flags(OPENSSL_INIT_SETTINGS *settings, unsigned long flags) {
+    return OPENSSL_INIT_set_config_file_flags(settings, flags);
+}
+NODE_CRYPTO_EXTERN int Thin_OPENSSL_INIT_set_config_appname(OPENSSL_INIT_SETTINGS *settings, const char *config_appname) {
+    return OPENSSL_INIT_set_config_appname(settings, config_appname);
+}
+
+NODE_CRYPTO_EXTERN void Thin_OPENSSL_INIT_free(OPENSSL_INIT_SETTINGS *settings) {
+    return OPENSSL_INIT_free(settings);
+}
+NODE_CRYPTO_EXTERN int Thin_BIO_get_init(BIO *a) {
+    return BIO_get_init(a);
+}
+
+NODE_CRYPTO_EXTERN X509_STORE_CTX *Thin_X509_STORE_CTX_new(void) {
+    return X509_STORE_CTX_new();
+}
+NODE_CRYPTO_EXTERN X509 *Thin_SSL_get_certificate(const SSL *ssl) {
+    return SSL_get_certificate(ssl);
+}
+
+NODE_CRYPTO_EXTERN STACK_OF(X509) *Thin_SSL_get_peer_cert_chain(const SSL *s) {
+    return SSL_get_peer_cert_chain(s);
+}
+NODE_CRYPTO_EXTERN STACK_OF(SSL_COMP) *Thin_SSL_COMP_get_compression_methods(void) {
+    return SSL_COMP_get_compression_methods();
+}
+
+NODE_CRYPTO_EXTERN int Thin_EC_KEY_generate_key(EC_KEY *key) {
+    return EC_KEY_generate_key(key);
+}
+
+NODE_CRYPTO_EXTERN int Thin_EC_KEY_set_public_key(EC_KEY *key, const EC_POINT *pub) {
+    return EC_KEY_set_public_key(key, pub);
+}
+
+NODE_CRYPTO_EXTERN const BIGNUM *Thin_EC_KEY_get0_private_key(const EC_KEY *key) {
+    return EC_KEY_get0_private_key(key);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_CIPHER_nid(const EVP_CIPHER *cipher) {
+    return EVP_CIPHER_nid(cipher);
+}
+NODE_CRYPTO_EXTERN const EVP_CIPHER *Thin_EVP_CIPHER_CTX_cipher(const EVP_CIPHER_CTX *ctx) {
+    return EVP_CIPHER_CTX_cipher(ctx);
+}
+
+NODE_CRYPTO_EXTERN size_t Thin_SSL_get_client_random(const SSL *ssl, unsigned char *out, size_t outlen) {
+    return SSL_get_client_random(ssl, out, outlen);
+}
+
+NODE_CRYPTO_EXTERN void Thin_ERR_put_error(int lib, int func, int reason, const char *file, int line) {
+    return ERR_put_error(lib, func, reason, file, line);
+}
+
+NODE_CRYPTO_EXTERN int Thin_ASN1_INTEGER_get_int64(int64_t *pr, const ASN1_INTEGER *a) {
+    return ASN1_INTEGER_get_int64(pr, a);
+}
+
+NODE_CRYPTO_EXTERN size_t Thin_SSL_client_hello_get0_ciphers(SSL *s, const unsigned char **out) {
+    return SSL_client_hello_get0_ciphers(s, out);
+}
+NODE_CRYPTO_EXTERN const SSL_CIPHER *Thin_SSL_CIPHER_find(SSL *ssl, const unsigned char *ptr) {
+    return SSL_CIPHER_find(ssl, ptr);
+}
+
+NODE_CRYPTO_EXTERN EVP_PKEY *Thin_ENGINE_load_private_key(ENGINE *e, const char *key_id,
+                                  UI_METHOD *ui_method, void *callback_data) {
+    return ENGINE_load_private_key(e, key_id, ui_method, callback_data);
+}
+NODE_CRYPTO_EXTERN EVP_PKEY *Thin_ENGINE_load_public_key(ENGINE *e, const char *key_id,
+                                 UI_METHOD *ui_method, void *callback_data) {
+    return ENGINE_load_public_key(e, key_id, ui_method, callback_data);
+}
+NODE_CRYPTO_EXTERN SSL_CTX *Thin_SSL_CTX_new(const SSL_METHOD *meth) {
+    return SSL_CTX_new(meth);
+}
+NODE_CRYPTO_EXTERN const SSL_METHOD *Thin_TLS_method(void) {
+    return TLS_method();
+}
+NODE_CRYPTO_EXTERN long Thin_SSL_CTX_set_timeout(SSL_CTX *ctx, long t) {
+    return SSL_CTX_set_timeout(ctx, t);
+}
+NODE_CRYPTO_EXTERN int Thin_SSL_CTX_set_session_id_context(SSL_CTX *ctx,
+                                          const unsigned char *sid_ctx,
+                                          unsigned int sid_ctx_len) {
+    return SSL_CTX_set_session_id_context(ctx, sid_ctx, sid_ctx_len);
+}
+
+NODE_CRYPTO_EXTERN unsigned long Thin_SSL_CTX_set_options(SSL_CTX *ctx, unsigned long op) {
+    return SSL_CTX_set_options(ctx, op);
+}
+NODE_CRYPTO_EXTERN STACK_OF(SSL_CIPHER) *Thin_SSL_get_ciphers(const SSL *s) {
+    return SSL_get_ciphers(s);
+}
+NODE_CRYPTO_EXTERN SSL *Thin_SSL_new(SSL_CTX *ctx) {
+    return SSL_new(ctx);
+}
+NODE_CRYPTO_EXTERN int Thin_ENGINE_init(ENGINE *e) {
+    return ENGINE_init(e);
+}
+NODE_CRYPTO_EXTERN int Thin_ENGINE_finish(ENGINE *e) {
+    return ENGINE_finish(e);
+}
+NODE_CRYPTO_EXTERN int Thin_SSL_CTX_set_client_cert_engine(SSL_CTX *ctx, ENGINE *e) {
+    return SSL_CTX_set_client_cert_engine(ctx, e);
+}
+NODE_CRYPTO_EXTERN ENGINE *Thin_ENGINE_by_id(const char *id) {
+    return ENGINE_by_id(id);
+}
+
+NODE_CRYPTO_EXTERN int Thin_OPENSSL_INIT_set_config_filename(OPENSSL_INIT_SETTINGS *settings, const char *config_filename) {
+    return OPENSSL_INIT_set_config_filename(settings, config_filename);
+}
+
+NODE_CRYPTO_EXTERN int Thin_ENGINE_ctrl_cmd_string(ENGINE *e, const char *cmd_name, const char *arg, int cmd_optional) {
+    return ENGINE_ctrl_cmd_string(e, cmd_name, arg, cmd_optional);
+}
+NODE_CRYPTO_EXTERN int Thin_OPENSSL_init_crypto(uint64_t opts, const OPENSSL_INIT_SETTINGS *settings) {
+    return OPENSSL_init_crypto(opts, settings);
+}
+NODE_CRYPTO_EXTERN int Thin_ENGINE_set_default(ENGINE *e, unsigned int flags) {
+    return ENGINE_set_default(e, flags);
+}
+
+NODE_CRYPTO_EXTERN const EVP_CIPHER *Thin_EVP_aes_128_cbc(void) {
+    return EVP_aes_128_cbc();
+}
+
+NODE_CRYPTO_EXTERN void Thin_X509_CRL_free(X509_CRL *ctx) {
+    return X509_CRL_free(ctx);
+}
+
+NODE_CRYPTO_EXTERN void Thin_PKCS12_free(PKCS12 *ctx) {
+    return PKCS12_free(ctx);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_DecryptInit_ex(EVP_CIPHER_CTX *ctx,
+                                  const EVP_CIPHER *cipher, ENGINE *impl,
+                                  const unsigned char *key,
+                                  const unsigned char *iv) {
+    return EVP_DecryptInit_ex(ctx, cipher, impl, key, iv);
+}
+NODE_CRYPTO_EXTERN DH *Thin_PEM_read_bio_DHparams(BIO *bp, DH **x, pem_password_cb *cb, void *u) {
+    return PEM_read_bio_DHparams(bp, x, cb, u);
+}
+NODE_CRYPTO_EXTERN char *Thin_ERR_error_string(unsigned long e, char *buf) {
+    return ERR_error_string(e, buf);
+}
+NODE_CRYPTO_EXTERN int Thin_DH_generate_parameters_ex(DH *dh, int prime_len, int generator, BN_GENCB *cb) {
+    return DH_generate_parameters_ex(dh, prime_len,generator, cb);
+}
+NODE_CRYPTO_EXTERN int Thin_DH_check(const DH *dh, int *codes) {
+    return DH_check(dh, codes);
+}
+NODE_CRYPTO_EXTERN int Thin_DH_size(const DH *dh) {
+    return DH_size(dh);
+}
+
+NODE_CRYPTO_EXTERN int Thin_DH_compute_key(unsigned char *key, const BIGNUM *pub_key, DH *dh) {
+    return DH_compute_key(key, pub_key, dh);
+}
+
+NODE_CRYPTO_EXTERN int Thin_EVP_PKEY_assign(EVP_PKEY *pkey, int type, void *key) {
+    return EVP_PKEY_assign(pkey, type, key);
+}
+
+NODE_CRYPTO_EXTERN char *Thin_BN_bn2hex(const BIGNUM *a) {
+    return BN_bn2hex(a);
+}
+NODE_CRYPTO_EXTERN char *Thin_BN_bn2dec(const BIGNUM *a) {
+    return BN_bn2dec(a);
+}
+
+NODE_CRYPTO_EXTERN int Thin_OBJ_sn2nid(const char *s) {
+    return OBJ_sn2nid(s);
+}
+
+NODE_CRYPTO_EXTERN int Thin_DH_check_pub_key(const DH *dh, const BIGNUM *pub_key, int *codes) {
+    return DH_check_pub_key(dh, pub_key, codes);
+}
+
+NODE_CRYPTO_EXTERN int Thin_EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr) {
+    return EVP_CIPHER_CTX_ctrl(ctx, type, arg, ptr);
+}
+
+NODE_CRYPTO_EXTERN int Thin_EC_KEY_check_key(const EC_KEY *key) {
+    return EC_KEY_check_key(key);
+}
+
+NODE_CRYPTO_EXTERN int Thin_EC_GROUP_get_degree(const EC_GROUP *group) {
+    return EC_GROUP_get_degree(group);
+}
+
+NODE_CRYPTO_EXTERN int Thin_ECDH_compute_key(void *out, size_t outlen, const EC_POINT *pub_key,
+                     const EC_KEY *ecdh,
+                     void *(*KDF) (const void *in, size_t inlen,
+                                   void *out, size_t *outlen)) {
+    return ECDH_compute_key(out, outlen, pub_key, ecdh, KDF);
+}
+
+NODE_CRYPTO_EXTERN EC_KEY *Thin_EC_KEY_new_by_curve_name(int nid) {
+    return EC_KEY_new_by_curve_name(nid);
+}
+
+NODE_CRYPTO_EXTERN EC_KEY *Thin_EC_KEY_dup(const EC_KEY *src) {
+    return EC_KEY_dup(src);
+}
+NODE_CRYPTO_EXTERN  int Thin_EC_KEY_set_private_key(EC_KEY *key, const BIGNUM *prv) {
+    return EC_KEY_set_private_key(key, prv);
+}
+
+NODE_CRYPTO_EXTERN size_t Thin_EC_POINT_point2oct(const EC_GROUP *group, const EC_POINT *p,
+                          point_conversion_form_t form,
+                          unsigned char *buf, size_t len, BN_CTX *ctx) {
+    return EC_POINT_point2oct(group, p, form, buf, len, ctx);
+}
+
+NODE_CRYPTO_EXTERN int Thin_EC_POINT_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *n,
+                 const EC_POINT *q, const BIGNUM *m, BN_CTX *ctx) {
+    return EC_POINT_mul(group, r, n, q, m, ctx);
+}
+
+NODE_CRYPTO_EXTERN EC_POINT *Thin_EC_POINT_new(const EC_GROUP *group) {
+    return EC_POINT_new(group);
+}
+
+NODE_CRYPTO_EXTERN int Thin_EVP_EncryptInit_ex(EVP_CIPHER_CTX *ctx,
+                                  const EVP_CIPHER *cipher, ENGINE *impl,
+                                  const unsigned char *key,
+                                  const unsigned char *iv) {
+    return EVP_EncryptInit_ex(ctx, cipher, impl, key, iv);
+}
+
+NODE_CRYPTO_EXTERN int Thin_EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *c, int pad) {
+    return EVP_CIPHER_CTX_set_padding(c, pad);
+}
+
+NODE_CRYPTO_EXTERN int Thin_EC_curve_nist2nid(const char *name) {
+    return EC_curve_nist2nid(name);
+}
+
+NODE_CRYPTO_EXTERN const struct ec_key_st *Thin_EVP_PKEY_get0_EC_KEY(EVP_PKEY *pkey) {
+    return EVP_PKEY_get0_EC_KEY(pkey);
+}
+NODE_CRYPTO_EXTERN struct ec_key_st *Thin_EVP_PKEY_get1_EC_KEY(EVP_PKEY *pkey) {
+    return EVP_PKEY_get1_EC_KEY(pkey);
+}
+
+NODE_CRYPTO_EXTERN int Thin_EC_POINT_get_affine_coordinates(const EC_GROUP *group, const EC_POINT *p,
+                                    BIGNUM *x, BIGNUM *y, BN_CTX *ctx) {
+    return EC_POINT_get_affine_coordinates(group, p, x, y, ctx);
+}
+
+NODE_CRYPTO_EXTERN size_t Thin_EC_get_builtin_curves(EC_builtin_curve *r, size_t nitems) {
+    return EC_get_builtin_curves(r, nitems);
+}
+NODE_CRYPTO_EXTERN int Thin_i2d_RSA_PUBKEY(RSA *a, unsigned char **pp) {
+    return i2d_RSA_PUBKEY(a, pp);
+}
+NODE_CRYPTO_EXTERN RSA *Thin_d2i_RSA_PUBKEY(RSA **a, const unsigned char **pp, long length) {
+    return d2i_RSA_PUBKEY(a, pp, length);
+}
+NODE_CRYPTO_EXTERN int Thin_EC_GROUP_get_order(const EC_GROUP *group, BIGNUM *order, BN_CTX *ctx) {
+    return EC_GROUP_get_order(group, order, ctx);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_PKEY_set1_EC_KEY(EVP_PKEY *pkey, struct ec_key_st *key) {
+    return EVP_PKEY_set1_EC_KEY(pkey, key);
+}
+NODE_CRYPTO_EXTERN int Thin_EC_KEY_set_public_key_affine_coordinates(EC_KEY *key, BIGNUM *x,
+                                             BIGNUM *y) {
+    return EC_KEY_set_public_key_affine_coordinates(key, x, y);
+}
+
+NODE_CRYPTO_EXTERN int Thin_i2d_RSAPublicKey_bio(BIO *bp, RSA *rsa) {
+    return i2d_RSAPublicKey_bio(bp, rsa);
+}
+NODE_CRYPTO_EXTERN int Thin_i2d_PUBKEY_bio(BIO *bp, EVP_PKEY *pkey) {
+    return i2d_PUBKEY_bio(bp, pkey);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_PKEY_up_ref(EVP_PKEY *pkey) {
+    return EVP_PKEY_up_ref(pkey);
+}
+NODE_CRYPTO_EXTERN int Thin_PEM_write_bio_RSAPublicKey(BIO *bp, RSA *x) {
+    return PEM_write_bio_RSAPublicKey(bp, x);
+}
+NODE_CRYPTO_EXTERN int Thin_PEM_write_bio_RSAPrivateKey(BIO *bp, RSA *x, const EVP_CIPHER *enc,
+                                 unsigned char *kstr, int klen,
+                                 pem_password_cb *cb, void *u) {
+    return PEM_write_bio_RSAPrivateKey(bp, x, enc, kstr, klen, cb, u);
+}
+NODE_CRYPTO_EXTERN int Thin_PEM_write_bio_PKCS8PrivateKey(BIO *bp, EVP_PKEY *pkey, const EVP_CIPHER *chipher,
+                                  char *kstr, int klen, pem_password_cb *cb, void *u) {
+    return PEM_write_bio_PKCS8PrivateKey(bp, pkey, chipher, kstr, klen, cb, u);
+}
+NODE_CRYPTO_EXTERN EVP_PKEY *Thin_d2i_PrivateKey(int type, EVP_PKEY **a, const unsigned char **pp,
+                         long length) {
+    return d2i_PrivateKey(type, a, pp, length);
+}
+NODE_CRYPTO_EXTERN PKCS8_PRIV_KEY_INFO *Thin_d2i_PKCS8_PRIV_KEY_INFO_bio(BIO *bp,
+                                                 PKCS8_PRIV_KEY_INFO **p8inf) {
+    return d2i_PKCS8_PRIV_KEY_INFO_bio(bp, p8inf);
+}
+NODE_CRYPTO_EXTERN int Thin_i2d_ECPrivateKey_bio(BIO *bp, EC_KEY *eckey) {
+    return i2d_ECPrivateKey_bio(bp, eckey);
+}
+NODE_CRYPTO_EXTERN int Thin_EC_POINT_oct2point(const EC_GROUP *group, EC_POINT *p,
+                       const unsigned char *buf, size_t len, BN_CTX *ctx) {
+    return EC_POINT_oct2point(group, p, buf, len, ctx);
+}
+
+NODE_CRYPTO_EXTERN EC_GROUP *Thin_EC_GROUP_new_by_curve_name(int nid) {
+    return EC_GROUP_new_by_curve_name(nid);
+}
+NODE_CRYPTO_EXTERN ASN1_INTEGER *Thin_BN_to_ASN1_INTEGER(const BIGNUM *bn, ASN1_INTEGER *ai) {
+    return BN_to_ASN1_INTEGER(bn, ai);
+}
+NODE_CRYPTO_EXTERN BIGNUM *Thin_ASN1_INTEGER_to_BN(const ASN1_INTEGER *ai, BIGNUM *bn) {
+    return ASN1_INTEGER_to_BN(ai, bn);
+}
+
+NODE_CRYPTO_EXTERN PKCS12 *Thin_d2i_PKCS12_bio(BIO *bp, PKCS12 **p12) {
+    return d2i_PKCS12_bio(bp, p12);
+}
+
+NODE_CRYPTO_EXTERN void Thin_RSA_get0_factors(const RSA *r, const BIGNUM **p, const BIGNUM **q) {
+    return RSA_get0_factors(r, p, q);
+}
+NODE_CRYPTO_EXTERN void *Thin_EVP_PKEY_get0(const EVP_PKEY *pkey) {
+    return EVP_PKEY_get0(pkey);
+}
+NODE_CRYPTO_EXTERN X509 *Thin_d2i_X509(X509 **p, const unsigned char **in, long len) {
+    return d2i_X509(p, in, len);
+}
+
+NODE_CRYPTO_EXTERN RSA *Thin_RSA_new(void) {
+    return RSA_new();
+}
+
+NODE_CRYPTO_EXTERN int Thin_OBJ_obj2nid(const ASN1_OBJECT *o) {
+    return OBJ_obj2nid(o);
+}
+NODE_CRYPTO_EXTERN void Thin_RSA_get0_crt_params(const RSA *r,
+                         const BIGNUM **dmp1, const BIGNUM **dmq1,
+                         const BIGNUM **iqmp) {
+    return RSA_get0_crt_params(r, dmp1, dmq1, iqmp);
+}
+NODE_CRYPTO_EXTERN int Thin_RSA_set0_key(RSA *r, BIGNUM *n, BIGNUM *e, BIGNUM *d) {
+    return RSA_set0_key(r, n, e, d);
+}
+NODE_CRYPTO_EXTERN int Thin_RSA_set0_factors(RSA *r, BIGNUM *p, BIGNUM *q) {
+    return RSA_set0_factors(r, p, q);
+}
+
+NODE_CRYPTO_EXTERN int Thin_EVP_PKEY_set1_RSA(EVP_PKEY *pkey, struct rsa_st *key) {
+    return EVP_PKEY_set1_RSA(pkey, key);
+}
+NODE_CRYPTO_EXTERN const RSA_PSS_PARAMS *Thin_RSA_get0_pss_params(const RSA *r) {
+    return RSA_get0_pss_params(r);
+}
+NODE_CRYPTO_EXTERN int Thin_RSA_set0_crt_params(RSA *r,BIGNUM *dmp1, BIGNUM *dmq1, BIGNUM *iqmp) {
+    return RSA_set0_crt_params(r, dmp1, dmq1, iqmp);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_PKEY_verify_init(EVP_PKEY_CTX *ctx) {
+    return EVP_PKEY_verify_init(ctx);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_PKEY_verify(EVP_PKEY_CTX *ctx,
+                    const unsigned char *sig, size_t siglen,
+                    const unsigned char *tbs, size_t tbslen) {
+    return EVP_PKEY_verify(ctx, sig, siglen, tbs, tbslen);
+}
+
+NODE_CRYPTO_EXTERN PKCS8_PRIV_KEY_INFO *Thin_EVP_PKEY2PKCS8(EVP_PKEY *pkey) {
+    return EVP_PKEY2PKCS8(pkey);
+}
+
+NODE_CRYPTO_EXTERN const char *Thin_OBJ_nid2ln(int n) {
+    return OBJ_nid2ln(n);
+}
+
+NODE_CRYPTO_EXTERN int Thin_i2d_PKCS8_PRIV_KEY_INFO_bio(BIO *bp, PKCS8_PRIV_KEY_INFO *p8inf) {
+    return i2d_PKCS8_PRIV_KEY_INFO_bio(bp, p8inf);
+}
+
+NODE_CRYPTO_EXTERN ECDSA_SIG *Thin_ECDSA_SIG_new(void) {
+    return ECDSA_SIG_new();
+}
+NODE_CRYPTO_EXTERN int Thin_i2d_ECDSA_SIG(const ECDSA_SIG *sig, unsigned char **pp) {
+    return i2d_ECDSA_SIG(sig, pp);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_DigestSignInit(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,
+                                  const EVP_MD *type, ENGINE *e,
+                                  EVP_PKEY *pkey) {
+    return EVP_DigestSignInit(ctx, pctx, type, e, pkey);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_DigestVerifyInit(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,
+                                const EVP_MD *type, ENGINE *e,
+                                EVP_PKEY *pkey) {
+    return EVP_DigestVerifyInit(ctx, pctx, type, e, pkey);
+}
+NODE_CRYPTO_EXTERN int Thin_i2d_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,
+                            char *kstr, int klen,
+                            pem_password_cb *cb, void *u) {
+    return i2d_PKCS8PrivateKey_bio(bp, x, enc, kstr, klen, cb, u);
+}
+NODE_CRYPTO_EXTERN EVP_PKEY *Thin_d2i_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY **x, pem_password_cb *cb,
+                                  void *u) {
+    return d2i_PKCS8PrivateKey_bio(bp, x, cb, u);
+}
+
+NODE_CRYPTO_EXTERN EVP_PKEY *Thin_EVP_PKCS82PKEY(const PKCS8_PRIV_KEY_INFO *p8) {
+    return EVP_PKCS82PKEY(p8);
+}
+
+NODE_CRYPTO_EXTERN int Thin_i2d_RSAPrivateKey_bio(BIO *bp, RSA *rsa) {
+    return i2d_RSAPrivateKey_bio(bp, rsa);
+}
+
+NODE_CRYPTO_EXTERN EVP_PKEY *Thin_d2i_PublicKey(int type, EVP_PKEY **a, const unsigned char **pp,
+                        long length) {
+    return d2i_PublicKey(type, a, pp, length);
+}
+NODE_CRYPTO_EXTERN int Thin_PEM_write_bio_ECPrivateKey(BIO *bp, ec_key_st *x, const EVP_CIPHER *enc,
+                              unsigned char *kstr, int klen,
+                              pem_password_cb *cb, void *u) {
+    return PEM_write_bio_ECPrivateKey(bp, x, enc, kstr, klen, cb, u);
+}
+
+NODE_CRYPTO_EXTERN int Thin_EVP_DigestSign(EVP_MD_CTX *ctx, unsigned char *sigret,
+                          size_t *siglen, const unsigned char *tbs,
+                          size_t tbslen) {
+    return EVP_DigestSign(ctx, sigret, siglen, tbs, tbslen);
+}
+
+NODE_CRYPTO_EXTERN int Thin_EVP_DigestVerify(EVP_MD_CTX *ctx, const unsigned char *sigret,
+                            size_t siglen, const unsigned char *tbs,
+                            size_t tbslen) {
+    return EVP_DigestVerify(ctx, sigret, siglen, tbs, tbslen);
+}
+NODE_CRYPTO_EXTERN point_conversion_form_t Thin_EC_KEY_get_conv_form(const EC_KEY *key) {
+    return EC_KEY_get_conv_form(key);
+}
+NODE_CRYPTO_EXTERN int Thin_PEM_write_bio_X509(BIO *bp, X509 *x) {
+    return PEM_write_bio_X509(bp, x);
+}
+NODE_CRYPTO_EXTERN int Thin_PEM_write_X509(FILE *fp, X509 *x) {
+    return PEM_write_X509(fp, x);
+}
+
+NODE_CRYPTO_EXTERN ECDSA_SIG *Thin_d2i_ECDSA_SIG(ECDSA_SIG **sig, const unsigned char **pp, long len) {
+    return d2i_ECDSA_SIG(sig, pp, len);
+}
+NODE_CRYPTO_EXTERN void Thin_ECDSA_SIG_get0(const ECDSA_SIG *sig, const BIGNUM **pr, const BIGNUM **ps) {
+    return ECDSA_SIG_get0(sig, pr, ps);
+}
+NODE_CRYPTO_EXTERN const BIGNUM *Thin_ECDSA_SIG_get0_r(const ECDSA_SIG *sig) {
+    return ECDSA_SIG_get0_r(sig);
+}
+NODE_CRYPTO_EXTERN const BIGNUM *Thin_ECDSA_SIG_get0_s(const ECDSA_SIG *sig) {
+    return ECDSA_SIG_get0_s(sig);
+}
+NODE_CRYPTO_EXTERN int Thin_ECDSA_SIG_set0(ECDSA_SIG *sig, BIGNUM *r, BIGNUM *s) {
+    return ECDSA_SIG_set0(sig, r, s);
+}
+NODE_CRYPTO_EXTERN STACK_OF(X509_NAME) *Thin_SSL_CTX_get_client_CA_list(const SSL_CTX *s) {
+    return SSL_CTX_get_client_CA_list(s);
+}
+NODE_CRYPTO_EXTERN int Thin_ASN1_STRING_to_UTF8(unsigned char **out, const ASN1_STRING *in) {
+    return ASN1_STRING_to_UTF8(out, in);
+}
+
+NODE_CRYPTO_EXTERN int Thin_EVP_DigestSignFinal(EVP_MD_CTX *ctx, unsigned char *sigret, size_t *siglen) {
+    return EVP_DigestSignFinal(ctx, sigret, siglen);
+}
+
+NODE_CRYPTO_EXTERN int Thin_i2d_X509(X509 *x, unsigned char **buf) {
+    return i2d_X509(x, buf);
+}
+
+NODE_CRYPTO_EXTERN const char *Thin_EC_curve_nid2nist(int nid) {
+    return EC_curve_nid2nist(nid);
+}
+
+NODE_CRYPTO_EXTERN int Thin_EC_GROUP_get_curve_name(const EC_GROUP *group) {
+    return EC_GROUP_get_curve_name(group);
+}
+NODE_CRYPTO_EXTERN void Thin_SSL_CTX_set_client_cert_cb(SSL_CTX *ctx,
+                                int (*client_cert_cb) (SSL *ssl, X509 **x509,
+                                                       EVP_PKEY **pkey))
+{
+    return SSL_CTX_set_client_cert_cb(ctx, client_cert_cb);
+}
+NODE_CRYPTO_EXTERN unsigned char *Thin_SHA1(const unsigned char *d, size_t n, unsigned char *md) {
+    return SHA1(d, n, md);
+}
+
+NODE_CRYPTO_EXTERN int Thin_sk_X509_NAME_num(STACK_OF(X509_NAME)* sk) {
+    return sk_X509_NAME_num(sk);
+}
+NODE_CRYPTO_EXTERN X509_NAME *Thin_sk_X509_NAME_value(const stack_st_X509_NAME *sk, int i) {
+    return sk_X509_NAME_value(sk, i);
+}
+NODE_CRYPTO_EXTERN STACK_OF(X509_NAME) *Thin_SSL_get_client_CA_list(const SSL *s) {
+    return SSL_get_client_CA_list(s);
+}
+NODE_CRYPTO_EXTERN char *Thin_X509_NAME_oneline(const X509_NAME *a, char *buf, int size) {
+    return X509_NAME_oneline(a, buf, size);
+}
+NODE_CRYPTO_EXTERN int Thin_BN_print(BIO *bio, const BIGNUM *a) {
+    return BN_print(bio, a);
+}
+
+NODE_CRYPTO_EXTERN int Thin_BIO_printf(BIO *bio, const char *format, ...) {
+    int ret;
+    va_list args;
+    va_start(args, format);
+    ret = BIO_vprintf(bio, format, args);
+    va_end(args);
+    return ret;
+}
+NODE_CRYPTO_EXTERN void Thin_ERR_print_errors_cb(int (*cb) (const char *str, size_t len, void *u), void *u) {
+    return ERR_print_errors_cb(cb, u);
+}
+
+NODE_CRYPTO_EXTERN OSSL_PROVIDER *Thin_OSSL_PROVIDER_load(OSSL_LIB_CTX *libctx, const char *name) {
+    return OSSL_PROVIDER_load(libctx, name);
+}
+NODE_CRYPTO_EXTERN int Thin_OSSL_PROVIDER_unload(OSSL_PROVIDER *prov) {
+    return OSSL_PROVIDER_unload(prov);
+}
+
+NODE_CRYPTO_EXTERN int Thin_EVP_default_properties_is_fips_enabled(OSSL_LIB_CTX *libctx) {
+    return EVP_default_properties_is_fips_enabled(libctx);
+}
+
+NODE_CRYPTO_EXTERN BIGNUM *Thin_BN_get_rfc2409_prime_768(BIGNUM *bn) {
+    return BN_get_rfc2409_prime_768(bn);
+}
+
+NODE_CRYPTO_EXTERN BIGNUM *Thin_BN_get_rfc2409_prime_1024(BIGNUM *bn) {
+    return BN_get_rfc2409_prime_1024(bn);
+}
+
+NODE_CRYPTO_EXTERN void Thin_EVP_MD_free(EVP_MD *md) {
+    return EVP_MD_free(md);
+}
+
+NODE_CRYPTO_EXTERN int Thin_EVP_PKEY_eq(const EVP_PKEY *a, const EVP_PKEY *b) {
+    return EVP_PKEY_eq(a, b);
+}
+
+NODE_CRYPTO_EXTERN EVP_CIPHER *Thin_EVP_CIPHER_fetch(OSSL_LIB_CTX *ctx, const char *algorithm, const char *properties) {
+    return EVP_CIPHER_fetch(ctx, algorithm, properties);
+}
+
+NODE_CRYPTO_EXTERN const char *Thin_EVP_CIPHER_get0_name(const EVP_CIPHER *cipher) {
+    return EVP_CIPHER_get0_name(cipher);
+}
+
+NODE_CRYPTO_EXTERN EVP_MD *Thin_EVP_MD_fetch(OSSL_LIB_CTX *ctx, const char *algorithm, const char *properties) {
+    return EVP_MD_fetch(ctx, algorithm, properties);
+}
+
+NODE_CRYPTO_EXTERN const char *Thin_EVP_MD_get0_name(const EVP_MD *md) {
+    return EVP_MD_get0_name(md);
+}
+
+NODE_CRYPTO_EXTERN int Thin_EVP_default_properties_enable_fips(OSSL_LIB_CTX *libctx, int enable) {
+    return EVP_default_properties_enable_fips(libctx, enable);
+}
+
+NODE_CRYPTO_EXTERN void Thin_EVP_CIPHER_free(EVP_CIPHER *cipher) {
+    return EVP_CIPHER_free(cipher);
+}
+NODE_CRYPTO_EXTERN int Thin_EVP_CIPHER_CTX_get_nid(const EVP_CIPHER_CTX *ctx) {
+    return EVP_CIPHER_CTX_get_nid(ctx);
+}
\ No newline at end of file
diff --git a/src/crypto/crypto_wrapper.h b/src/crypto/crypto_wrapper.h
new file mode 100644
index 0000000000..71ab040e7b
--- /dev/null
+++ b/src/crypto/crypto_wrapper.h
@@ -0,0 +1,1141 @@
+
+#ifndef SRC_CRYPTO_CRYPTO_INL_H_
+#define SRC_CRYPTO_CRYPTO_INL_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <openssl/ossl_typ.h>
+#include <openssl/bn.h>
+#include <openssl/aes.h>
+#include <openssl/ssl.h>
+#include <openssl/err.h>
+#include <openssl/engine.h>
+#include <openssl/crypto.h>
+#include <openssl/evp.h>
+#include <openssl/tls1.h>
+#include <openssl/rand.h>
+#include <openssl/x509.h>
+#include <openssl/x509v3.h>
+#include <openssl/dh.h>
+#include <openssl/pkcs12.h>
+#include <openssl/ec.h>
+#include <openssl/safestack.h>
+#include <openssl/provider.h>
+
+
+// #ifndef OPENSSL_IS_BORINGSSL
+ #include <openssl/kdf.h>
+// #endif
+
+#include <openssl/rsa.h>
+#include <openssl/dsa.h>
+
+#ifndef OPENSSL_NO_ENGINE
+#  include <openssl/engine.h>
+#endif  // !OPENSSL_NO_ENGINE
+
+// // The FIPS-related functions are only available
+// // when the OpenSSL itself was compiled with FIPS support.
+#if defined(OPENSSL_FIPS) && OPENSSL_VERSION_MAJOR < 3
+#  include <openssl/fips.h>
+#endif  // OPENSSL_FIPS
+
+# ifdef  __cplusplus
+}
+# endif
+
+#define Thin_EVP_DigestSignUpdate(a,b,c)     Thin_EVP_DigestUpdate(a,b,c)
+
+#define Thin_EVP_CIPHER_mode(e)              (Thin_EVP_CIPHER_flags(e) & EVP_CIPH_MODE)
+#define Thin_EVP_CIPHER_CTX_mode(c)         Thin_EVP_CIPHER_mode(Thin_EVP_CIPHER_CTX_cipher(c))
+
+#define Thin_EVP_PKEY_CTX_hkdf_mode(pctx, mode) \
+        Thin_EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_DERIVE, \
+                              EVP_PKEY_CTRL_HKDF_MODE, mode, NULL)
+
+#define Thin_EVP_PKEY_assign_EC_KEY(pkey,eckey) \
+        Thin_EVP_PKEY_assign((pkey),EVP_PKEY_EC, (char *)(eckey))
+
+#define Thin_EVP_PKEY_CTX_set_ec_param_enc(ctx, flag) \
+        Thin_EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_EC, \
+                                EVP_PKEY_OP_PARAMGEN|EVP_PKEY_OP_KEYGEN, \
+                                EVP_PKEY_CTRL_EC_PARAM_ENC, flag, NULL)
+
+#define Thin_EVP_PKEY_CTX_set_signature_md(ctx, md) \
+        Thin_EVP_PKEY_CTX_ctrl(ctx, -1, EVP_PKEY_OP_TYPE_SIG,  \
+                                        EVP_PKEY_CTRL_MD, 0, (void *)(md))
+#define Thin_EVP_PKEY_CTX_add1_hkdf_info(pctx, info, infolen) \
+        Thin_EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_DERIVE, \
+                              EVP_PKEY_CTRL_HKDF_INFO, infolen, (void *)(info))
+
+#define Thin_EVP_PKEY_CTX_set_ec_paramgen_curve_nid(ctx, nid) \
+        Thin_EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_EC, \
+                                EVP_PKEY_OP_PARAMGEN|EVP_PKEY_OP_KEYGEN, \
+                                EVP_PKEY_CTRL_EC_PARAMGEN_CURVE_NID, nid, NULL)
+#define Thin_EVP_PKEY_CTX_set1_hkdf_key(pctx, key, keylen) \
+        Thin_EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_DERIVE, \
+                              EVP_PKEY_CTRL_HKDF_KEY, keylen, (void *)(key))
+
+#define Thin_EVP_PKEY_CTX_set1_hkdf_salt(pctx, salt, saltlen) \
+        Thin_EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_DERIVE, \
+                              EVP_PKEY_CTRL_HKDF_SALT, saltlen, (void *)(salt))
+
+#define Thin_EVPerr(f,r)       Thin_ERR_put_error(ERR_LIB_EVP,(f),(r),OPENSSL_FILE,OPENSSL_LINE)
+#define Thin_EVP_PKEY_CTX_set_ec_param_enc(ctx, flag) \
+        Thin_EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_EC, \
+                                EVP_PKEY_OP_PARAMGEN|EVP_PKEY_OP_KEYGEN, \
+                                EVP_PKEY_CTRL_EC_PARAM_ENC, flag, NULL)
+
+#define Thin_BIO_reset(b)            (int)Thin_BIO_ctrl(b,BIO_CTRL_RESET,0,NULL)
+#define Thin_BIO_eof(b)              (int)Thin_BIO_ctrl(b,BIO_CTRL_EOF,0,NULL)
+#define Thin_BIO_set_close(b,c)      (int)Thin_BIO_ctrl(b,BIO_CTRL_SET_CLOSE,(c),NULL)
+#define Thin_BIO_get_close(b)        (int)Thin_BIO_ctrl(b,BIO_CTRL_GET_CLOSE,0,NULL)
+#define Thin_BIO_pending(b)          (int)Thin_BIO_ctrl(b,BIO_CTRL_PENDING,0,NULL)
+#define Thin_BIO_wpending(b)         (int)Thin_BIO_ctrl(b,BIO_CTRL_WPENDING,0,NULL)
+
+#define Thin_EVP_PKEY_assign_DH(pkey,dh) \
+        Thin_EVP_PKEY_assign((pkey),EVP_PKEY_DH, (char *)(dh))
+
+#define Thin_EVP_PKEY_CTX_set_dsa_paramgen_bits(ctx, nbits) \
+        Thin_EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_DSA, EVP_PKEY_OP_PARAMGEN, \
+                                EVP_PKEY_CTRL_DSA_PARAMGEN_BITS, nbits, NULL)
+
+#define Thin_SSL_set_app_data(s,arg) \
+        (Thin_SSL_set_ex_data(s,0,(char *)(arg)))
+#define Thin_EVP_PKEY_CTX_set_rsa_pss_saltlen(ctx, len) \
+        Thin_RSA_pkey_ctx_ctrl(ctx, (EVP_PKEY_OP_SIGN|EVP_PKEY_OP_VERIFY), \
+                          EVP_PKEY_CTRL_RSA_PSS_SALTLEN, len, NULL)
+
+#define Thin_SSL_CTX_set1_groups_list(ctx, s) \
+        Thin_SSL_CTX_ctrl(ctx,SSL_CTRL_SET_GROUPS_LIST,0,(char *)(s))
+#define Thin_SSL_CTX_get0_chain_certs(ctx,px509) \
+        Thin_SSL_CTX_ctrl(ctx,SSL_CTRL_GET_CHAIN_CERTS,0,px509)
+
+#define Thin_SSL_CTX_get_min_proto_version(ctx) \
+        Thin_SSL_CTX_ctrl(ctx, SSL_CTRL_GET_MIN_PROTO_VERSION, 0, NULL)
+
+#define Thin_SSL_CTX_set1_curves_list(ctx, s) \
+        Thin_SSL_CTX_ctrl(ctx,SSL_CTRL_SET_GROUPS_LIST,0,(char *)(s))
+
+#define Thin_SSL_set1_verify_cert_store(s,st) \
+        Thin_SSL_ctrl(s,SSL_CTRL_SET_VERIFY_CERT_STORE,1,(char *)(st))
+
+#define Thin_SSL_CTX_set_tmp_dh(ctx,dh) \
+        Thin_SSL_CTX_ctrl(ctx,SSL_CTRL_SET_TMP_DH,0,(char *)(dh))
+
+#define Thin_SSL_set_tlsext_host_name(s,name) \
+        Thin_SSL_ctrl(s,SSL_CTRL_SET_TLSEXT_HOSTNAME,TLSEXT_NAMETYPE_host_name,\
+                (void *)name)
+#define Thin_SSL_CTX_get_max_proto_version(ctx) \
+        Thin_SSL_CTX_ctrl(ctx, SSL_CTRL_GET_MAX_PROTO_VERSION, 0, NULL)
+
+#define Thin_SSL_set_msg_callback_arg(ssl, arg) \
+        Thin_SSL_ctrl((ssl), SSL_CTRL_SET_MSG_CALLBACK_ARG, 0, (arg))
+
+#define Thin_SSL_set_mode(ssl,op) \
+        Thin_SSL_ctrl((ssl),SSL_CTRL_MODE,(op),NULL)
+
+# define Thin_SSL_CTX_get_tlsext_status_cb(ssl, cb) \
+        Thin_SSL_CTX_ctrl(ssl,SSL_CTRL_GET_TLSEXT_STATUS_REQ_CB,0,(void *)cb)
+# define Thin_SSL_CTX_set_tlsext_status_cb(ssl, cb) \
+        Thin_SSL_CTX_callback_ctrl(ssl,SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB,\
+                (void (*)(void))cb)
+
+# define Thin_SSL_CTX_get_tlsext_status_arg(ssl, arg) \
+        Thin_SSL_CTX_ctrl(ssl,SSL_CTRL_GET_TLSEXT_STATUS_REQ_CB_ARG,0,arg)
+# define Thin_SSL_CTX_set_tlsext_status_arg(ssl, arg) \
+        Thin_SSL_CTX_ctrl(ssl,SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB_ARG,0,arg)
+
+#define Thin_SSL_get_server_tmp_key(s, pk) \
+        Thin_SSL_ctrl(s,SSL_CTRL_GET_PEER_TMP_KEY,0,pk)
+
+#define Thin_SSL_set1_chain(s,sk) \
+        Thin_SSL_ctrl(s,SSL_CTRL_CHAIN,1,(char *)(sk))
+#define Thin_SSL_CTX_set_session_cache_mode(ctx,m) \
+        Thin_SSL_CTX_ctrl(ctx,SSL_CTRL_SET_SESS_CACHE_MODE,m,NULL)
+
+#define Thin_SSL_get_tlsext_status_ocsp_resp(ssl, arg) \
+        Thin_SSL_ctrl(ssl,SSL_CTRL_GET_TLSEXT_STATUS_REQ_OCSP_RESP,0,arg)
+
+#define Thin_SSL_CTX_set_tlsext_ticket_key_cb(ssl, cb) \
+        Thin_SSL_CTX_callback_ctrl(ssl,SSL_CTRL_SET_TLSEXT_TICKET_KEY_CB,\
+                (void (*)(void))cb)
+#define Thin_SSL_set_tlsext_status_ocsp_resp(ssl, arg, arglen) \
+        Thin_SSL_ctrl(ssl,SSL_CTRL_SET_TLSEXT_STATUS_REQ_OCSP_RESP,arglen,arg)
+
+#define Thin_SSL_CTX_set_min_proto_version(ctx, version) \
+        Thin_SSL_CTX_ctrl(ctx, SSL_CTRL_SET_MIN_PROTO_VERSION, version, NULL)
+#define Thin_SSL_CTX_set_max_proto_version(ctx, version) \
+        Thin_SSL_CTX_ctrl(ctx, SSL_CTRL_SET_MAX_PROTO_VERSION, version, NULL)
+#define Thin_SSL_CTX_set1_sigalgs_list(ctx, s) \
+        Thin_SSL_CTX_ctrl(ctx,SSL_CTRL_SET_SIGALGS_LIST,0,(char *)(s))
+#define Thin_SSL_CTX_set_tlsext_servername_callback(ctx, cb) \
+        Thin_SSL_CTX_callback_ctrl(ctx,SSL_CTRL_SET_TLSEXT_SERVERNAME_CB,\
+                (void (*)(void))cb)
+
+#define Thin_SSL_CTX_clear_mode(ctx,op) \
+        Thin_SSL_CTX_ctrl((ctx),SSL_CTRL_CLEAR_MODE,(op),NULL)
+
+#define Thin_SSL_CTX_get_app_data(ctx) \
+        (Thin_SSL_CTX_get_ex_data(ctx,0))
+#define Thin_SSL_CTX_set_app_data(ctx,arg) \
+        (Thin_SSL_CTX_set_ex_data(ctx,0, (char *)(arg)))
+#define Thin_OPENSSL_secure_clear_free(addr, num) \
+        Thin_CRYPTO_secure_clear_free(addr, num, OPENSSL_FILE, OPENSSL_LINE)
+
+#define Thin_OPENSSL_secure_malloc(num) \
+        Thin_CRYPTO_secure_malloc(num, OPENSSL_FILE, OPENSSL_LINE)
+
+#define Thin_EVP_PKEY_CTX_set_rsa_pss_keygen_mgf1_md(ctx, md) \
+        Thin_EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA_PSS, EVP_PKEY_OP_KEYGEN, \
+                          EVP_PKEY_CTRL_RSA_MGF1_MD, 0, (void *)(md))
+#define Thin_EVP_PKEY_CTX_set_rsa_pss_keygen_md(ctx, md) \
+        Thin_EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA_PSS,  \
+                          EVP_PKEY_OP_KEYGEN, EVP_PKEY_CTRL_MD,  \
+                          0, (void *)(md))
+#define Thin_BIO_set_retry_read(b) \
+        Thin_BIO_set_flags(b, (BIO_FLAGS_READ|BIO_FLAGS_SHOULD_RETRY))
+
+#define Thin_SSL_get_tlsext_status_type(ssl) \
+        Thin_SSL_ctrl(ssl,SSL_CTRL_GET_TLSEXT_STATUS_REQ_TYPE,0,NULL)
+#define Thin_SSL_set_tlsext_status_type(ssl, type) \
+        Thin_SSL_ctrl(ssl,SSL_CTRL_SET_TLSEXT_STATUS_REQ_TYPE,type,NULL)
+#define Thin_SSL_set_max_send_fragment(ssl,m) \
+        Thin_SSL_ctrl(ssl,SSL_CTRL_SET_MAX_SEND_FRAGMENT,m,NULL)
+
+#define Thin_EVP_PKEY_CTX_set_rsa_mgf1_md(ctx, md) \
+        Thin_RSA_pkey_ctx_ctrl(ctx, EVP_PKEY_OP_TYPE_SIG | EVP_PKEY_OP_TYPE_CRYPT, \
+                          EVP_PKEY_CTRL_RSA_MGF1_MD, 0, (void *)(md))
+#define Thin_EVP_PKEY_CTX_set_rsa_pss_keygen_saltlen(ctx, len) \
+        Thin_EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA_PSS, EVP_PKEY_OP_KEYGEN, \
+                          EVP_PKEY_CTRL_RSA_PSS_SALTLEN, len, NULL)
+#define Thin_EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, bits) \
+        Thin_RSA_pkey_ctx_ctrl(ctx, EVP_PKEY_OP_KEYGEN, \
+                          EVP_PKEY_CTRL_RSA_KEYGEN_BITS, bits, NULL)
+
+
+#define Thin_OPENSSL_clear_free(addr, num) \
+        Thin_CRYPTO_clear_free(addr, num, OPENSSL_FILE, OPENSSL_LINE)
+
+#define Thin_SSL_CTX_add1_chain_cert(ctx,x509) \
+        Thin_SSL_CTX_ctrl(ctx,SSL_CTRL_CHAIN_CERT,1,(char *)(x509))
+#define Thin_SSL_CTX_clear_extra_chain_certs(ctx) \
+        Thin_SSL_CTX_ctrl(ctx,SSL_CTRL_CLEAR_EXTRA_CHAIN_CERTS,0,NULL)
+#define Thin_EVP_PKEY_CTX_set_rsa_keygen_pubexp(ctx, pubexp) \
+        Thin_RSA_pkey_ctx_ctrl(ctx, EVP_PKEY_OP_KEYGEN, \
+                          EVP_PKEY_CTRL_RSA_KEYGEN_PUBEXP, 0, pubexp)
+#define Thin_EVP_PKEY_CTX_set_rsa_oaep_md(ctx, md) \
+        Thin_EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA, EVP_PKEY_OP_TYPE_CRYPT,  \
+                          EVP_PKEY_CTRL_RSA_OAEP_MD, 0, (void *)(md))
+#define Thin_OPENSSL_memdup(str, s) \
+        Thin_CRYPTO_memdup((str), s, OPENSSL_FILE, OPENSSL_LINE)
+#define Thin_EVP_PKEY_CTX_set0_rsa_oaep_label(ctx, l, llen) \
+        Thin_EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA, EVP_PKEY_OP_TYPE_CRYPT,  \
+                          EVP_PKEY_CTRL_RSA_OAEP_LABEL, llen, (void *)(l))
+
+#define Thin_EVP_CIPHER_mode(e) \
+        (Thin_EVP_CIPHER_flags(e) & EVP_CIPH_MODE)
+#define Thin_EVP_MD_CTX_size(e) \
+        Thin_EVP_MD_size(Thin_EVP_MD_CTX_md(e))
+
+#define Thin_BIO_clear_retry_flags(b) \
+        Thin_BIO_clear_flags(b, (BIO_FLAGS_RWS|BIO_FLAGS_SHOULD_RETRY))
+
+#if OPENSSL_API_COMPAT < 0x10100000L
+# define Thin_EVP_CIPHER_CTX_init(c) Thin_EVP_CIPHER_CTX_reset(c)
+# endif
+
+#define Thin_EVP_get_cipherbynid(a) \
+        Thin_EVP_get_cipherbyname(Thin_OBJ_nid2sn(a))
+
+#define Thin_BIO_set_mem_eof_return(b,v) \
+        Thin_BIO_ctrl(b,BIO_C_SET_BUF_MEM_EOF_RETURN,v,NULL)
+
+
+#define Thin_EVP_PKEY_CTX_set_hkdf_md(pctx, md) \
+        Thin_EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_DERIVE, \
+                            EVP_PKEY_CTRL_HKDF_MD, 0, (void *)(md))
+
+#define Thin_EVP_PKEY_CTX_set_rsa_padding(ctx, pad) \
+        Thin_RSA_pkey_ctx_ctrl(ctx, -1, EVP_PKEY_CTRL_RSA_PADDING, pad, NULL)
+
+#define Thin_SSL_get_app_data(s)    (Thin_SSL_get_ex_data(s,0))
+
+#define Thin_BIO_reset(b)            (int)Thin_BIO_ctrl(b,BIO_CTRL_RESET,0,NULL)
+#define Thin_BN_num_bytes(a)   ((Thin_BN_num_bits(a)+7)/8)
+
+#define Thin_BIO_get_mem_ptr(b,pp) \
+        Thin_BIO_ctrl(b,BIO_C_GET_BUF_MEM_PTR,0, (char *)(pp))
+
+#define Thin_EVP_PKEY_CTX_set_dh_paramgen_prime_len(ctx, len) \
+        Thin_EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_DH, EVP_PKEY_OP_PARAMGEN, \
+                        EVP_PKEY_CTRL_DH_PARAMGEN_PRIME_LEN, len, NULL)
+
+#define Thin_EVP_PKEY_CTX_set_dh_paramgen_generator(ctx, gen) \
+        Thin_EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_DH, EVP_PKEY_OP_PARAMGEN, \
+                        EVP_PKEY_CTRL_DH_PARAMGEN_GENERATOR, gen, NULL)
+
+# define Thin_EVP_CIPHER_CTX_nid Thin_EVP_CIPHER_CTX_get_nid
+
+# define Thin_SSL_CTX_set_dh_auto(ctx, onoff) \
+        Thin_SSL_CTX_ctrl(ctx,SSL_CTRL_SET_DH_AUTO,onoff,NULL)
+
+// # define STACK_OF(type) struct stack_st_##type
+// # define EVP_GCM_TLS_TAG_LEN                             16
+// # define TLS1_3_VERSION                  0x0304
+
+// # define ERR_GET_REASON(l)       (int)( (l)         & 0xFFFL)
+
+void Thin_X509_free(X509 *x);
+void Thin_BIO_free_all(BIO *a);
+void Thin_SSL_CTX_free(SSL_CTX *);
+void Thin_SSL_SESSION_free(SSL_SESSION *ses);
+
+void Thin_SSL_free(SSL *ssl);
+
+void Thin_PKCS8_PRIV_KEY_INFO_free(PKCS8_PRIV_KEY_INFO*);
+
+void Thin_EVP_PKEY_free(EVP_PKEY *pkey);
+
+
+void Thin_EVP_PKEY_CTX_free(EVP_PKEY_CTX *ctx);
+void Thin_EVP_MD_CTX_free(EVP_MD_CTX *ctx);
+
+void Thin_EC_KEY_free(EC_KEY *key);
+
+BIGNUM *Thin_BN_new(void);
+void Thin_BN_free(BIGNUM *bn);
+
+void Thin_BN_CTX_free(BN_CTX *ctx);
+void Thin_NETSCAPE_SPKI_free(NETSCAPE_SPKI *spki);
+
+void Thin_EC_GROUP_free(EC_GROUP *group);
+void Thin_EC_POINT_free(EC_POINT *point);
+
+void Thin_DH_free(DH *dh);
+void Thin_ECDSA_SIG_free(ECDSA_SIG *sig);
+void Thin_HMAC_CTX_free(HMAC_CTX *ctx);
+void Thin_EVP_CIPHER_CTX_free(EVP_CIPHER_CTX *ctx);
+void Thin_RSA_free(RSA *rsa);
+
+void Thin_DSA_free(DSA *dsa);
+void Thin_DSA_SIG_free(DSA_SIG *sig);
+
+
+void Thin_OPENSSL_free(void *addr);
+int Thin_SSL_CTX_use_PrivateKey(SSL_CTX *ctx, EVP_PKEY *pkey);
+
+void Thin_ERR_clear_error(void);
+void Thin_SSL_CTX_set_cert_store(SSL_CTX *, X509_STORE *);
+int Thin_X509_STORE_add_cert(X509_STORE *ctx, X509 *x);
+int Thin_ERR_pop_to_mark(void);
+int Thin_ERR_set_mark(void);
+
+int Thin_ENGINE_free(ENGINE *e);
+
+void *Thin_OPENSSL_malloc(size_t num);
+void *Thin_OPENSSL_realloc(void *addr, size_t num);
+
+
+int Thin_EVP_PKEY_keygen_init(EVP_PKEY_CTX *ctx);
+int Thin_EVP_PKEY_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey);
+
+int Thin_FIPS_mode(void);
+int Thin_FIPS_mode_set(int r);
+
+BIGNUM *Thin_BN_bin2bn(const unsigned char *s, int len, BIGNUM *ret);
+
+void Thin_ERR_print_errors_fp(FILE *fp);
+
+unsigned long Thin_ERR_peek_error(void);
+
+const struct dsa_st *Thin_EVP_PKEY_get0_DSA(EVP_PKEY *pkey);
+
+void Thin_ASN1_OBJECT_free(ASN1_OBJECT *a);
+
+DH *Thin_DH_new(void);
+int Thin_BN_is_zero(const BIGNUM *a);
+
+int Thin_BN_is_one(const BIGNUM *a);
+
+int Thin_DH_set0_pqg(DH *dh, BIGNUM *p, BIGNUM *q, BIGNUM *g);
+
+const EVP_MD *Thin_EVP_get_digestbyname(const char *name);
+
+int Thin_EVP_MD_CTX_copy(EVP_MD_CTX *out, const EVP_MD_CTX *in);
+
+unsigned long Thin_ERR_get_error(void);
+
+int Thin_CRYPTO_memcmp(const void * in_a, const void * in_b, size_t len);
+
+//
+int Thin_EVP_CipherInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
+                   const unsigned char *key, const unsigned char *iv,
+                   int enc);
+int Thin_EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx,
+                      const EVP_CIPHER *cipher, ENGINE *impl,
+                      const unsigned char *key,
+                      const unsigned char *iv, int enc);
+int Thin_EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
+                     int *outl, const unsigned char *in, int inl);
+int Thin_EVP_CipherFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm,
+                    int *outl);
+int Thin_EVP_CipherFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm,
+                       int *outl);
+
+BIO *Thin_BIO_new_mem_buf(const void *buf, int len);
+HMAC_CTX *Thin_HMAC_CTX_new(void);
+void *Thin_ASN1_SCTX_get_app_data(ASN1_SCTX *p);
+EVP_PKEY_CTX *Thin_EVP_PKEY_CTX_new(EVP_PKEY *pkey, ENGINE *e);
+EVP_PKEY_CTX *Thin_EVP_PKEY_CTX_new_id(int id, ENGINE *e);
+
+long Thin_SSL_ctrl(SSL *ssl, int cmd, long larg, void *parg);
+long Thin_SSL_callback_ctrl(SSL *, int, void (*)(void));
+long Thin_SSL_CTX_ctrl(SSL_CTX *ctx, int cmd, long larg, void *parg);
+long Thin_SSL_CTX_callback_ctrl(SSL_CTX *, int, void (*)(void));
+
+int Thin_EVP_PKEY_encrypt_init(EVP_PKEY_CTX *ctx);
+int Thin_EVP_PKEY_encrypt(EVP_PKEY_CTX *ctx,
+                     unsigned char *out, size_t *outlen,
+                     const unsigned char *in, size_t inlen);
+int Thin_EVP_PKEY_decrypt_init(EVP_PKEY_CTX *ctx);
+int Thin_EVP_PKEY_decrypt(EVP_PKEY_CTX *ctx,
+                     unsigned char *out, size_t *outlen,
+                     const unsigned char *in, size_t inlen);
+void Thin_RSA_get0_key(const RSA *r,
+                  const BIGNUM **n, const BIGNUM **e, const BIGNUM **d);
+const struct rsa_st *Thin_EVP_PKEY_get0_RSA(EVP_PKEY *pkey);
+struct rsa_st *Thin_EVP_PKEY_get1_RSA(EVP_PKEY *pkey);
+
+
+BIO_METHOD *Thin_BIO_meth_new(int type, const char *name);
+int Thin_BIO_meth_set_write(BIO_METHOD *biom,
+                       int (*write) (BIO *, const char *, int));
+int Thin_BIO_meth_set_read(BIO_METHOD *biom,
+                      int (*read) (BIO *, char *, int));
+int Thin_BIO_meth_set_puts(BIO_METHOD *biom,
+                      int (*puts) (BIO *, const char *));
+int Thin_BIO_meth_set_gets(BIO_METHOD *biom,
+                      int (*gets) (BIO *, char *, int));
+int Thin_BIO_meth_set_ctrl(BIO_METHOD *biom,
+                      long (*ctrl) (BIO *, int, long, void *));
+int Thin_BIO_meth_set_create(BIO_METHOD *biom, int (*create) (BIO *));
+int Thin_BIO_meth_set_destroy(BIO_METHOD *biom, int (*destroy) (BIO *));
+const char *Thin_SSL_CIPHER_get_name(const SSL_CIPHER *c);
+SSL_CTX_keylog_cb_func Thin_SSL_CTX_get_keylog_callback(const SSL_CTX *ctx);
+
+int Thin_SSL_set_session(SSL *to, SSL_SESSION *session);
+SSL_SESSION *Thin_d2i_SSL_SESSION(SSL_SESSION **a, const unsigned char **pp,
+                             long length);
+const X509V3_EXT_METHOD *Thin_X509V3_EXT_get(X509_EXTENSION *ext);
+const X509V3_EXT_METHOD *Thin_X509V3_EXT_get_nid(int nid);
+int Thin_X509_NAME_print_ex(BIO *out, const X509_NAME *nm, int indent,
+                       unsigned long flags);
+X509_NAME *Thin_X509_get_subject_name(const X509 *a);
+const SSL_CIPHER *Thin_SSL_get_current_cipher(const SSL *s);
+void *Thin_X509V3_EXT_d2i(X509_EXTENSION *ext);
+X509_NAME *Thin_X509_get_issuer_name(const X509 *a);
+SSL_SESSION *Thin_SSL_get_session(const SSL *ssl);
+long Thin_SSL_get_verify_result(const SSL *ssl);
+void Thin_SSL_SESSION_get0_ticket(const SSL_SESSION *s, const unsigned char **tick,
+                             size_t *len);
+int Thin_SSL_CIPHER_get_auth_nid(const SSL_CIPHER *c);
+int Thin_SSL_session_reused(const SSL *s);
+int Thin_SSL_SESSION_get_protocol_version(const SSL_SESSION *s);
+X509_STORE *Thin_X509_STORE_new(void);
+int Thin_X509_STORE_load_locations(X509_STORE *ctx,
+                              const char *file, const char *dir);
+int Thin_X509_STORE_set_default_paths(X509_STORE *ctx);
+void Thin_SSL_set_cert_cb(SSL *s, int (*cb) (SSL *ssl, void *arg), void *arg);
+int Thin_SSL_read(SSL *ssl, void *buf, int num);
+int Thin_SSL_write(SSL *ssl, const void *buf, int num);
+int Thin_SSL_shutdown(SSL *s);
+int Thin_SSL_get_shutdown(const SSL *ssl);
+int Thin_SSL_get_error(const SSL *s, int ret_code);
+void Thin_ERR_print_errors(BIO *bp);
+const char *Thin_ERR_func_error_string(unsigned long e);
+const SSL_METHOD *Thin_TLS_server_method(void);
+const SSL_METHOD *Thin_TLS_client_method(void);
+EVP_PKEY *Thin_PEM_read_bio_PrivateKey(BIO *bp, EVP_PKEY **x,
+                                   pem_password_cb *cb, void *u);
+int Thin_X509_STORE_CTX_init(X509_STORE_CTX *ctx, X509_STORE *store,
+                        X509 *x509, STACK_OF(X509) *chain);
+int Thin_X509_STORE_CTX_get1_issuer(X509 **issuer, X509_STORE_CTX *ctx, X509 *x);
+int Thin_EVP_PKEY_bits(const EVP_PKEY *pkey);
+void Thin_BIO_set_init(BIO *a, int init);
+void *Thin_BIO_get_data(BIO *a);
+int Thin_BIO_get_shutdown(BIO *a);
+void Thin_BIO_set_data(BIO *a, void *ptr);
+void Thin_ERR_error_string_n(unsigned long e, char *buf, size_t len);
+const char *Thin_ERR_lib_error_string(unsigned long e);
+void *Thin_CRYPTO_secure_malloc(size_t num, const char *file, int line);
+int Thin_CRYPTO_secure_malloc_init(size_t sz, int minsize);
+int Thin_CRYPTO_secure_malloc_initialized(void);
+void Thin_ENGINE_load_builtin_engines(void);
+int Thin_ERR_load_ENGINE_strings(void);
+int Thin_OPENSSL_init_ssl(uint64_t opts, const OPENSSL_INIT_SETTINGS *settings);
+int Thin_RAND_bytes(unsigned char *buf, int num);
+int Thin_BN_set_word(BIGNUM *a, BN_ULONG w);
+int Thin_EVP_CIPHER_CTX_block_size(const EVP_CIPHER_CTX *ctx);
+EVP_CIPHER_CTX *Thin_EVP_CIPHER_CTX_new(void);
+NETSCAPE_SPKI *Thin_NETSCAPE_SPKI_b64_decode(const char *str, int len);
+int Thin_NETSCAPE_SPKI_verify(NETSCAPE_SPKI *a, EVP_PKEY *r);
+int Thin_X509V3_EXT_print(BIO *out, X509_EXTENSION *ext, unsigned long flag, int indent);
+int Thin_X509_get_ext_by_NID(const X509 *x, int nid, int lastpos);
+int Thin_EVP_PKEY_derive(EVP_PKEY_CTX *ctx, unsigned char *key, size_t *keylen);
+int Thin_EVP_MD_size(const EVP_MD *md);
+X509_STORE *Thin_SSL_CTX_get_cert_store(const SSL_CTX *);
+const unsigned char *Thin_SSL_SESSION_get_id(const SSL_SESSION *s, unsigned int *len);
+int Thin_i2d_SSL_SESSION(SSL_SESSION *in, unsigned char **pp);
+
+/* PKCS5 password based encryption */
+int Thin_PKCS5_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,
+                            ASN1_TYPE *param, const EVP_CIPHER *cipher,
+                            const EVP_MD *md, int en_de);
+int Thin_PKCS5_PBKDF2_HMAC_SHA1(const char *pass, int passlen,
+                                const unsigned char *salt, int saltlen, int iter,
+                                int keylen, unsigned char *out);
+int Thin_PKCS5_PBKDF2_HMAC(const char *pass, int passlen,
+                           const unsigned char *salt, int saltlen, int iter,
+                           const EVP_MD *digest, int keylen, unsigned char *out);
+int Thin_PKCS5_v2_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,
+                               ASN1_TYPE *param, const EVP_CIPHER *cipher,
+                               const EVP_MD *md, int en_de);
+int Thin_EVP_PBE_scrypt(const char *pass, size_t passlen,
+                        const unsigned char *salt, size_t saltlen,
+                        uint64_t N, uint64_t r, uint64_t p, uint64_t maxmem,
+                        unsigned char *key, size_t keylen);
+int Thin_DH_generate_key(DH *dh);
+
+void Thin_DH_get0_key(const DH *dh, const BIGNUM **pub_key, const BIGNUM **priv_key);
+int Thin_DH_set0_key(DH *dh, BIGNUM *pub_key, BIGNUM *priv_key);
+
+int Thin_EVP_PKEY_derive_init(EVP_PKEY_CTX *ctx);
+int Thin_EVP_PKEY_base_id(const EVP_PKEY *pkey);
+
+void Thin_DSA_get0_pqg(const DSA *d, const BIGNUM **p, const BIGNUM **q, const BIGNUM **g);
+int Thin_DSA_set0_pqg(DSA *d, BIGNUM *p, BIGNUM *q, BIGNUM *g);
+void Thin_DSA_get0_key(const DSA *d, const BIGNUM **pub_key, const BIGNUM **priv_key);
+int Thin_DSA_set0_key(DSA *d, BIGNUM *pub_key, BIGNUM *priv_key);
+const BIGNUM *Thin_DSA_get0_p(const DSA *d);
+const BIGNUM *Thin_DSA_get0_q(const DSA *d);
+const BIGNUM *Thin_DSA_get0_g(const DSA *d);
+const BIGNUM *Thin_DSA_get0_pub_key(const DSA *d);
+const BIGNUM *Thin_DSA_get0_priv_key(const DSA *d);
+int Thin_BN_num_bits(const BIGNUM *a);
+int Thin_EVP_PKEY_id(const EVP_PKEY *pkey);
+
+EVP_MD_CTX *Thin_EVP_MD_CTX_new(void);
+SSL_CTX *Thin_SSL_get_SSL_CTX(const SSL *ssl);
+const BIO_METHOD *Thin_BIO_s_mem(void);
+X509_EXTENSION *Thin_X509_get_ext(const X509 *x, int loc);
+
+int Thin_EVP_PKEY_paramgen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey);
+
+int Thin_HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len, const EVP_MD *md, ENGINE *impl);
+int Thin_HMAC_Update(HMAC_CTX *ctx, const unsigned char *data, size_t len);
+int Thin_HMAC_Final(HMAC_CTX *ctx, unsigned char *md, unsigned int *len);
+unsigned char *Thin_HMAC(const EVP_MD *evp_md, const void *key, int key_len,
+                         const unsigned char *d, size_t n, unsigned char *md,
+                         unsigned int *md_len);
+
+
+int Thin_BN_cmp(const BIGNUM *a, const BIGNUM *b);
+BN_CTX *Thin_BN_CTX_new(void);
+int Thin_BN_is_prime_ex(const BIGNUM *p, int nchecks, BN_CTX *ctx, BN_GENCB *cb);
+int Thin_SSL_CTX_use_certificate(SSL_CTX *ctx, X509 *x);
+int Thin_X509_check_issued(X509 *issuer, X509 *subject);
+X509 *Thin_X509_dup(X509 *x509);
+BIO *Thin_BIO_new(const BIO_METHOD *type);
+EVP_PKEY *Thin_d2i_PUBKEY(EVP_PKEY **a, const unsigned char **pp, long length);
+int Thin_PEM_bytes_read_bio(unsigned char **pdata, long *plen, char **pnm,
+                            const char *name, BIO *bp, pem_password_cb *cb,
+                            void *u);
+
+int Thin_BN_generate_prime_ex(BIGNUM *ret, int bits, int safe, const BIGNUM *add, const BIGNUM *rem, BN_GENCB *cb);
+
+int Thin_EVP_PKEY_paramgen_init(EVP_PKEY_CTX *ctx);
+EVP_PKEY *Thin_NETSCAPE_SPKI_get_pubkey(NETSCAPE_SPKI *x);
+int Thin_BIO_write(BIO *b, const void *data, int dlen);
+void Thin_DH_get0_pqg(const DH *dh, const BIGNUM **p, const BIGNUM **q, const BIGNUM **g);
+int Thin_EVP_PKEY_derive_set_peer(EVP_PKEY_CTX *ctx, EVP_PKEY *peer);
+int Thin_BN_bn2binpad(const BIGNUM *a, unsigned char *to, int tolen);
+
+int Thin_EVP_DigestInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl);
+int Thin_EVP_DigestUpdate(EVP_MD_CTX *ctx, const void *d, size_t cnt);
+int Thin_EVP_DigestFinal_ex(EVP_MD_CTX *ctx, unsigned char *md, unsigned int *s);
+int Thin_EVP_Digest(const void *data, size_t count,
+                    unsigned char *md, unsigned int *size,
+                    const EVP_MD *type, ENGINE *impl);
+int Thin_EVP_DigestFinalXOF(EVP_MD_CTX *ctx, unsigned char *md, size_t len);
+
+int Thin_EVP_PKEY_size(const EVP_PKEY *pkey);
+const EVP_MD *Thin_EVP_MD_CTX_md(const EVP_MD_CTX *ctx);
+
+unsigned long Thin_EVP_MD_flags(const EVP_MD *md);
+
+int Thin_EVP_PKEY_sign_init(EVP_PKEY_CTX *ctx);
+void Thin_EVP_MD_do_all_sorted(void (*fn)(const EVP_MD *ciph, const char *from, const char *to, void *x), void *arg);
+
+
+int Thin_SSL_set_alpn_protos(SSL *ssl, const unsigned char *protos, unsigned int protos_len);
+X509 *Thin_SSL_get_peer_certificate(const SSL *s);
+
+void *Thin_X509_get_ext_d2i(const X509 *x, int nid, int *crit, int *idx);
+EVP_PKEY *Thin_X509_get_pubkey(X509 *x);
+
+BIGNUM *Thin_BN_secure_new(void);
+
+EVP_PKEY *Thin_EVP_PKEY_new(void);
+EVP_PKEY *Thin_EVP_PKEY_new_mac_key(int type, ENGINE *e, const unsigned char *key, int keylen);
+EVP_PKEY *Thin_EVP_PKEY_new_raw_private_key(int type, ENGINE *e,
+                                            const unsigned char *priv,
+                                            size_t len);
+EVP_PKEY *Thin_EVP_PKEY_new_raw_public_key(int type, ENGINE *e,
+                                           const unsigned char *pub,
+                                           size_t len);
+int Thin_EVP_PKEY_get_raw_private_key(const EVP_PKEY *pkey, unsigned char *priv, size_t *len);
+int Thin_EVP_PKEY_get_raw_public_key(const EVP_PKEY *pkey, unsigned char *pub, size_t *len);
+
+size_t Thin_CRYPTO_secure_used(void);
+
+int Thin_RAND_status(void);
+int Thin_RAND_poll(void);
+int Thin_X509_up_ref(X509 *x);
+
+BIO *Thin_BIO_new_fp(FILE *stream, int close_flag);
+BIO *Thin_BIO_new_file(const char *filename, const char *mode);
+
+OPENSSL_INIT_SETTINGS *Thin_OPENSSL_INIT_new(void);
+void Thin_OPENSSL_init(void);
+int Thin_OPENSSL_INIT_set_config_filename(OPENSSL_INIT_SETTINGS *settings, const char *config_filename);
+int Thin_OPENSSL_init_crypto(uint64_t opts, const OPENSSL_INIT_SETTINGS *settings);
+void Thin_OPENSSL_INIT_set_config_file_flags(OPENSSL_INIT_SETTINGS *settings, unsigned long flags);
+int Thin_OPENSSL_INIT_set_config_appname(OPENSSL_INIT_SETTINGS *settings, const char *config_appname);
+void Thin_OPENSSL_INIT_free(OPENSSL_INIT_SETTINGS *settings);
+int Thin_BIO_get_init(BIO *a);
+
+X509_STORE_CTX *Thin_X509_STORE_CTX_new(void);
+X509 *Thin_SSL_get_certificate(const SSL *ssl);
+
+STACK_OF(X509) *Thin_SSL_get_peer_cert_chain(const SSL *s);
+STACK_OF(SSL_COMP) *Thin_SSL_COMP_get_compression_methods(void);
+
+
+int Thin_EVP_CIPHER_nid(const EVP_CIPHER *cipher);
+const EVP_CIPHER *Thin_EVP_CIPHER_CTX_cipher(const EVP_CIPHER_CTX *ctx);
+
+size_t Thin_SSL_get_client_random(const SSL *ssl, unsigned char *out, size_t outlen);
+
+void Thin_ERR_put_error(int lib, int func, int reason, const char *file, int line);
+
+int Thin_ASN1_INTEGER_get_int64(int64_t *pr, const ASN1_INTEGER *a);
+
+size_t Thin_SSL_client_hello_get0_ciphers(SSL *s, const unsigned char **out);
+const SSL_CIPHER *Thin_SSL_CIPHER_find(SSL *ssl, const unsigned char *ptr);
+
+EVP_PKEY *Thin_ENGINE_load_private_key(ENGINE *e, const char *key_id,
+                                  UI_METHOD *ui_method, void *callback_data);
+EVP_PKEY *Thin_ENGINE_load_public_key(ENGINE *e, const char *key_id,
+                                 UI_METHOD *ui_method, void *callback_data);
+int Thin_SSL_CTX_set_session_id_context(SSL_CTX *ctx,
+                                          const unsigned char *sid_ctx,
+                                          unsigned int sid_ctx_len);
+long Thin_SSL_CTX_set_timeout(SSL_CTX *ctx, long t);
+const SSL_METHOD *Thin_TLS_method(void);
+unsigned long Thin_SSL_CTX_set_options(SSL_CTX *ctx, unsigned long op);
+SSL_CTX *Thin_SSL_CTX_new(const SSL_METHOD *meth);
+STACK_OF(SSL_CIPHER) *Thin_SSL_get_ciphers(const SSL *s);
+SSL *Thin_SSL_new(SSL_CTX *ctx);
+int Thin_ENGINE_init(ENGINE *e);
+int Thin_ENGINE_finish(ENGINE *e);
+int Thin_SSL_CTX_set_client_cert_engine(SSL_CTX *ctx, ENGINE *e);
+ENGINE *Thin_ENGINE_by_id(const char *id);
+//
+
+int Thin_ENGINE_ctrl_cmd_string(ENGINE *e, const char *cmd_name, const char *arg, int cmd_optional);
+int Thin_ENGINE_set_default(ENGINE *e, unsigned int flags);
+
+int Thin_SSL_CTX_set_ex_data(SSL_CTX *ssl, int idx, void *data);
+void *Thin_SSL_CTX_get_ex_data(const SSL_CTX *ssl, int idx);
+void Thin_CRYPTO_secure_clear_free(void *ptr, size_t num,
+                              const char *file, int line);
+
+const char *Thin_SSL_get_servername(const SSL *s, const int type);
+int Thin_SSL_CTX_set_ciphersuites(SSL_CTX *ctx, const char *str);
+
+void *Thin_CRYPTO_memdup(const void *str, size_t siz, const char *file, int line);
+int Thin_RSA_pkey_ctx_ctrl(EVP_PKEY_CTX *ctx, int optype, int cmd, int p1, void *p2);
+void Thin_CRYPTO_clear_free(void *ptr, size_t num, const char *file, int line);
+
+void Thin_SSL_CTX_set_keylog_callback(SSL_CTX *ctx, SSL_CTX_keylog_cb_func cb);
+void Thin_SSL_CTX_sess_set_new_cb(SSL_CTX *ctx,
+                             int (*new_session_cb) (struct ssl_st *ssl,
+                                                    SSL_SESSION *sess));
+void Thin_SSL_CTX_sess_set_get_cb(SSL_CTX *ctx,
+                             SSL_SESSION *(*get_session_cb) (struct ssl_st
+                                                             *ssl,
+                                                             const unsigned char
+                                                             *data, int len,
+                                                             int *copy));
+void Thin_SSL_set_bio(SSL *s, BIO *rbio, BIO *wbio);
+
+
+void Thin_SSL_set_verify(SSL *s, int mode, SSL_verify_cb callback);
+
+void Thin_SSL_set_msg_callback(SSL *ssl,
+                          void (*cb) (int write_p, int version,
+                                      int content_type, const void *buf,
+                                      size_t len, SSL *ssl, void *arg));
+
+
+void Thin_SSL_trace(int write_p, int version, int content_type,
+               const void *buf, size_t len, SSL *ssl, void *arg);
+
+
+SSL_CTX *Thin_SSL_set_SSL_CTX(SSL *ssl, SSL_CTX *ctx);
+int Thin_SSL_use_psk_identity_hint(SSL *s, const char *identity_hint);
+void Thin_SSL_set_psk_server_callback(SSL *ssl, SSL_psk_server_cb_func cb);
+void Thin_SSL_set_psk_client_callback(SSL *ssl, SSL_psk_client_cb_func cb);
+
+STACK_OF(X509_NAME) *Thin_SSL_dup_CA_list(const STACK_OF(X509_NAME) *sk);
+void Thin_SSL_set_client_CA_list(SSL *s, STACK_OF(X509_NAME) *name_list);
+
+void Thin_SSL_CTX_set_alpn_select_cb(SSL_CTX *ctx,
+                                SSL_CTX_alpn_select_cb_func cb,
+                                void *arg);
+
+int Thin_EVP_PKEY_CTX_ctrl(EVP_PKEY_CTX *ctx, int keytype, int optype,
+                      int cmd, int p1, void *p2);
+
+const EVP_CIPHER *Thin_EVP_get_cipherbyname(const char *name);
+int Thin_SSL_use_certificate(SSL *ssl, X509 *x);
+int Thin_SSL_use_PrivateKey(SSL *ssl, EVP_PKEY *pkey);
+X509 *Thin_SSL_CTX_get0_certificate(const SSL_CTX *ctx);
+EVP_PKEY *Thin_SSL_CTX_get0_privatekey(const SSL_CTX *ctx);
+
+int Thin_SSL_client_hello_get0_ext(SSL *s, unsigned int type,
+                              const unsigned char **out, size_t *outlen);
+const char *Thin_X509_verify_cert_error_string(long n);
+
+X509 *Thin_PEM_read_bio_X509_AUX(BIO *bp, X509 **x, pem_password_cb *cb, void *u);
+
+int Thin_PKCS12_parse(PKCS12 *p12, const char *pass, EVP_PKEY **pkey, X509 **cert, STACK_OF(X509) **ca);
+struct ec_key_st *Thin_EVP_PKEY_get1_EC_KEY(EVP_PKEY *pkey);
+const EC_GROUP *Thin_EC_KEY_get0_group(const EC_KEY *key);
+const char *Thin_ERR_reason_error_string(unsigned long e);
+int Thin_SSL_CTX_add_client_CA(SSL_CTX *ctx, X509 *x);
+
+void Thin_sk_SSL_COMP_zero(STACK_OF(SSL_COMP) *sk);
+
+int Thin_sk_ASN1_OBJECT_num(const struct stack_st_ASN1_OBJECT *sk);
+int Thin_sk_X509_num(const struct stack_st_X509 *sk);
+const EC_POINT *Thin_EC_KEY_get0_public_key(const EC_KEY *key);
+
+unsigned long Thin_ERR_peek_last_error(void);
+int Thin_sk_X509_push(STACK_OF(X509) *sk, X509 *x);
+int Thin_X509_STORE_add_crl(X509_STORE *ctx, X509_CRL *x);
+int Thin_X509_STORE_set_flags(X509_STORE *ctx, unsigned long flags);
+
+STACK_OF(X509) *Thin_sk_X509_new(sk_X509_compfunc fn);
+STACK_OF(X509) *Thin_sk_X509_new_null();
+X509 *Thin_PEM_read_bio_X509(BIO *bp, X509 **x, pem_password_cb *cb, void *u);
+
+const ASN1_OBJECT *Thin_sk_ASN1_OBJECT_value(const struct stack_st_ASN1_OBJECT *sk, int i);
+void Thin_sk_ASN1_OBJECT_pop_free(STACK_OF(ASN1_OBJECT)* sk, void (*fn)(asn1_object_st *));
+
+int Thin_sk_X509_NAME_num(STACK_OF(X509_NAME)* sk);
+x509_st *Thin_sk_X509_value(const struct stack_st_X509 *sk, int i);
+void Thin_sk_X509_pop_free(STACK_OF(X509) *sk, void (*fn)(x509_st *));
+
+const SSL_CIPHER *Thin_sk_SSL_CIPHER_value(const struct stack_st_SSL_CIPHER *sk, int i);
+
+int Thin_i2t_ASN1_OBJECT(char *buf, int buf_len, const ASN1_OBJECT *a);
+
+int Thin_sk_ACCESS_DESCRIPTION_num(STACK_OF(ACCESS_DESCRIPTION)* sk);
+ACCESS_DESCRIPTION *Thin_sk_ACCESS_DESCRIPTION_value(const struct stack_st_ACCESS_DESCRIPTION *sk, int i);
+void Thin_ACCESS_DESCRIPTION_free(ACCESS_DESCRIPTION *p);
+void Thin_sk_ACCESS_DESCRIPTION_pop_free(STACK_OF(ACCESS_DESCRIPTION) *sk, void (*fn)(ACCESS_DESCRIPTION *));
+
+x509_st *Thin_sk_X509_delete(STACK_OF(X509) *sk, int i);
+
+void Thin_sk_CONF_VALUE_pop_free(STACK_OF(CONF_VALUE) *sk, void (*fn)(CONF_VALUE *));
+
+int Thin_OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name);
+
+int Thin_EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *x, int keylen);
+
+const char *Thin_SSL_CIPHER_standard_name(const SSL_CIPHER *c);
+
+void Thin_EVP_CIPHER_CTX_set_flags(EVP_CIPHER_CTX *ctx, int flags);
+
+int Thin_BN_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
+
+int Thin_sk_GENERAL_NAME_num(STACK_OF(GENERAL_NAME)* sk);
+GENERAL_NAME *Thin_sk_GENERAL_NAME_value(const struct stack_st_GENERAL_NAME *sk, int i);
+void Thin_GENERAL_NAME_free(GENERAL_NAME *p);
+void Thin_sk_GENERAL_NAME_pop_free(STACK_OF(GENERAL_NAME) *sk, void (*fn)(GENERAL_NAME *));
+
+void Thin_X509V3_EXT_val_prn(BIO *out, STACK_OF(CONF_VALUE) *val, int indent, int ml);
+STACK_OF(CONF_VALUE) *Thin_i2v_GENERAL_NAME(X509V3_EXT_METHOD *method, GENERAL_NAME *gen, STACK_OF(CONF_VALUE) *ret);
+
+void Thin_BIO_set_flags(BIO *b, int flags);
+void Thin_BIO_clear_flags(BIO *b, int flags);
+
+int Thin_sk_SSL_CIPHER_num(STACK_OF(SSL_CIPHER)* ciphers);
+
+X509_NAME *Thin_sk_X509_NAME_value(const stack_st_X509_NAME *sk, int i);
+
+unsigned long Thin_EVP_CIPHER_flags(const EVP_CIPHER *cipher);
+
+void *Thin_OPENSSL_sk_value(const OPENSSL_STACK *, int);
+size_t Thin_SSL_get_finished(const SSL *s, void *buf, size_t count);
+size_t Thin_SSL_get_peer_finished(const SSL *s, void *buf, size_t count);
+int Thin_SSL_renegotiate_pending(const SSL *s);
+int Thin_EVP_CIPHER_CTX_reset(EVP_CIPHER_CTX *c);
+void Thin_SSL_set_connect_state(SSL *s);
+void Thin_SSL_set_accept_state(SSL *s);
+
+void Thin_BIO_set_shutdown(BIO *a, int shut);
+void Thin_SSL_get0_alpn_selected(const SSL *ssl, const unsigned char **data,
+                            unsigned int *len);
+int Thin_SSL_export_keying_material(SSL *s, unsigned char *out, size_t olen,
+                                      const char *label, size_t llen,
+                                      const unsigned char *context,
+                                      size_t contextlen, int use_context);
+int Thin_SSL_get_shared_sigalgs(SSL *s, int idx,
+                           int *psign, int *phash, int *psignandhash,
+                           unsigned char *rsig, unsigned char *rhash);
+int Thin_X509_verify(X509 *a, EVP_PKEY *r);
+int Thin_X509_check_private_key(const X509 *x509, const EVP_PKEY *pkey);
+EVP_PKEY *Thin_X509_PUBKEY_get(X509_PUBKEY *key);
+unsigned long Thin_OpenSSL_version_num(void);
+const char *Thin_SSL_CIPHER_get_version(const SSL_CIPHER *c);
+int Thin_SSL_select_next_proto(unsigned char **out, unsigned char *outlen,
+                                 const unsigned char *in, unsigned int inlen,
+                                 const unsigned char *client,
+                                 unsigned int client_len);
+int Thin_X509_digest(const X509 *data, const EVP_MD *type,
+                unsigned char *md, unsigned int *len);
+ASN1_INTEGER *Thin_X509_get_serialNumber(X509 *x);
+X509_CRL *Thin_PEM_read_bio_X509_CRL(BIO *bp, X509_CRL **x,
+                                 pem_password_cb *cb, void *u);
+const ASN1_TIME *Thin_X509_get0_notAfter(const X509 *x);
+const ASN1_TIME * Thin_X509_get0_notBefore(const X509 *x);
+int Thin_SSL_CTX_set_cipher_list(SSL_CTX *, const char *str);
+int Thin_X509_check_ca(X509 *x);
+int Thin_SSL_is_server(const SSL *s);
+int Thin_SSL_renegotiate(SSL *s);
+int Thin_ASN1_TIME_print(BIO *fp, const ASN1_TIME *a);
+int Thin_X509_check_host(X509 *x, const char *chk, size_t chklen,
+                    unsigned int flags, char **peername);
+int Thin_X509_check_email(X509 *x, const char *chk, size_t chklen,
+                     unsigned int flags);
+int Thin_X509_check_ip(X509 *x, const unsigned char *chk, size_t chklen,
+                  unsigned int flags);
+int Thin_X509_check_ip_asc(X509 *x, const char *ipasc, unsigned int flags);
+int Thin_X509_STORE_up_ref(X509_STORE *v);
+const char *Thin_SSL_get_version(const SSL *s);
+long Thin_BIO_ctrl(BIO *bp, int cmd, long larg, void *parg);
+int Thin_X509_NAME_get_index_by_NID(X509_NAME *name, int nid, int lastpos);
+int Thin_OBJ_txt2nid(const char *s);
+X509_NAME_ENTRY *Thin_X509_NAME_get_entry(const X509_NAME *name, int loc);
+ASN1_STRING * Thin_X509_NAME_ENTRY_get_data(const X509_NAME_ENTRY *ne);
+int Thin_PEM_write_bio_PUBKEY(BIO *bp, EVP_PKEY *x);
+const unsigned char *Thin_ASN1_STRING_get0_data(const ASN1_STRING *x);
+
+void *Thin_SSL_get_ex_data(const SSL *ssl, int idx);
+int Thin_SSL_set_ex_data(SSL *ssl, int idx, void *data);
+void Thin_SSL_set_info_callback(SSL *ssl,
+                           void (*cb) (const SSL *ssl, int type, int val));
+
+int Thin_EVP_PKEY_verify_recover_init(EVP_PKEY_CTX *ctx);
+
+int Thin_EVP_PKEY_sign(EVP_PKEY_CTX *ctx,
+                  unsigned char *sig, size_t *siglen,
+                  const unsigned char *tbs, size_t tbslen);
+
+int Thin_EVP_BytesToKey(const EVP_CIPHER *type, const EVP_MD *md,
+                          const unsigned char *salt,
+                          const unsigned char *data, int datal, int count,
+                          unsigned char *key, unsigned char *iv);
+int Thin_EVP_CIPHER_block_size(const EVP_CIPHER *cipher);
+int Thin_EVP_CIPHER_impl_ctx_size(const EVP_CIPHER *cipher);
+int Thin_EVP_CIPHER_key_length(const EVP_CIPHER *cipher);
+int Thin_EVP_CIPHER_iv_length(const EVP_CIPHER *cipher);
+unsigned long Thin_EVP_CIPHER_flags(const EVP_CIPHER *cipher);
+void Thin_EVP_CIPHER_do_all_sorted(void (*fn)
+                               (const EVP_CIPHER *ciph, const char *from,
+                                const char *to, void *x), void *arg);
+int Thin_EVP_PKEY_verify_recover(EVP_PKEY_CTX *ctx,
+                            unsigned char *rout, size_t *routlen,
+                            const unsigned char *sig, size_t siglen);
+void Thin_X509_STORE_CTX_free(X509_STORE_CTX *ctx);
+void Thin_X509_CRL_free(X509_CRL *ctx);
+void Thin_PKCS12_free(PKCS12 *ctx);
+
+int Thin_EVP_DecryptInit_ex(EVP_CIPHER_CTX *ctx,
+                                  const EVP_CIPHER *cipher, ENGINE *impl,
+                                  const unsigned char *key,
+                                  const unsigned char *iv);
+
+const EVP_MD *Thin_EVP_md5(void);
+const BIGNUM *Thin_BN_value_one(void);
+const char *Thin_OBJ_nid2sn(int n);
+BN_ULONG Thin_BN_get_word(const BIGNUM *a);
+int Thin_BN_lshift(BIGNUM *r, const BIGNUM *a, int n);
+
+
+const EVP_MD *Thin_EVP_sha1(void);
+const EVP_MD *Thin_EVP_sha224(void);
+const EVP_MD *Thin_EVP_sha256(void);
+const EVP_MD *Thin_EVP_sha384(void);
+const EVP_MD *Thin_EVP_sha512(void);
+const EVP_MD *Thin_EVP_sha512_224(void);
+const EVP_MD *Thin_EVP_sha512_256(void);
+const EVP_MD *Thin_EVP_sha3_224(void);
+const EVP_MD *Thin_EVP_sha3_256(void);
+const EVP_MD *Thin_EVP_sha3_384(void);
+const EVP_MD *Thin_EVP_sha3_512(void);
+const EVP_MD *Thin_EVP_shake128(void);
+const EVP_MD *Thin_EVP_shake256(void);
+
+int Thin_EC_GROUP_order_bits(const EC_GROUP *group);
+void Thin_X509V3_conf_free(CONF_VALUE *val);
+
+
+const EVP_CIPHER *Thin_EVP_aes_128_cbc(void);
+
+DH *Thin_PEM_read_bio_DHparams(BIO *bp, DH **x, pem_password_cb *cb, void *u);
+char *Thin_ERR_error_string(unsigned long e, char *buf);
+int Thin_DH_generate_parameters_ex(DH *dh, int prime_len, int generator,
+                              BN_GENCB *cb);
+
+int Thin_DH_check(const DH *dh, int *codes);
+int Thin_DH_size(const DH *dh);
+int Thin_DH_compute_key(unsigned char *key, const BIGNUM *pub_key, DH *dh);
+
+
+int Thin_EVP_PKEY_assign(EVP_PKEY *pkey, int type, void *key);
+
+int Thin_DH_set0_key(DH *dh, BIGNUM *pub_key, BIGNUM *priv_key);
+
+char *Thin_BN_bn2hex(const BIGNUM *a);
+char *Thin_BN_bn2dec(const BIGNUM *a);
+
+int Thin_OBJ_sn2nid(const char *s);
+
+
+int Thin_DH_check_pub_key(const DH *dh, const BIGNUM *pub_key, int *codes);
+
+int Thin_EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr);
+
+int Thin_EC_KEY_check_key(const EC_KEY *key);
+
+int Thin_EC_GROUP_get_degree(const EC_GROUP *group);
+
+int Thin_ECDH_compute_key(void *out, size_t outlen, const EC_POINT *pub_key,
+                     const EC_KEY *ecdh,
+                     void *(*KDF) (const void *in, size_t inlen,
+                                   void *out, size_t *outlen));
+
+EC_KEY *Thin_EC_KEY_new_by_curve_name(int nid);
+
+int Thin_EC_KEY_set_public_key(EC_KEY *key, const EC_POINT *pub);
+
+int Thin_EC_KEY_generate_key(EC_KEY *key);
+
+EC_KEY *Thin_EC_KEY_dup(const EC_KEY *src);
+
+int Thin_EC_KEY_set_private_key(EC_KEY *key, const BIGNUM *prv);
+
+const BIGNUM *Thin_EC_KEY_get0_private_key(const EC_KEY *key);
+
+size_t Thin_EC_POINT_point2oct(const EC_GROUP *group, const EC_POINT *p,
+                          point_conversion_form_t form,
+                          unsigned char *buf, size_t len, BN_CTX *ctx);
+
+int Thin_EC_POINT_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *n,
+                 const EC_POINT *q, const BIGNUM *m, BN_CTX *ctx);
+
+EC_POINT *Thin_EC_POINT_new(const EC_GROUP *group);
+
+int Thin_EVP_EncryptInit_ex(EVP_CIPHER_CTX *ctx,
+                                  const EVP_CIPHER *cipher, ENGINE *impl,
+                                  const unsigned char *key,
+                                  const unsigned char *iv);
+
+int Thin_EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *c, int pad);
+
+int Thin_EC_curve_nist2nid(const char *name);
+
+const struct ec_key_st *Thin_EVP_PKEY_get0_EC_KEY(EVP_PKEY *pkey);
+struct ec_key_st *Thin_EVP_PKEY_get1_EC_KEY(EVP_PKEY *pkey);
+
+int Thin_EC_POINT_get_affine_coordinates(const EC_GROUP *group, const EC_POINT *p,
+                                    BIGNUM *x, BIGNUM *y, BN_CTX *ctx);
+int Thin_EVP_PKEY_get_raw_public_key(const EVP_PKEY *pkey, unsigned char *pub,
+                                size_t *len);
+
+size_t Thin_EC_get_builtin_curves(EC_builtin_curve *r, size_t nitems);
+
+int Thin_i2d_RSA_PUBKEY(RSA *a, unsigned char **pp);
+RSA *Thin_d2i_RSA_PUBKEY(RSA **a, const unsigned char **pp, long length);
+
+int Thin_EC_GROUP_get_order(const EC_GROUP *group, BIGNUM *order, BN_CTX *ctx);
+
+int Thin_EVP_PKEY_set1_EC_KEY(EVP_PKEY *pkey, struct ec_key_st *key);
+
+int Thin_EC_KEY_set_public_key_affine_coordinates(EC_KEY *key, BIGNUM *x,
+                                             BIGNUM *y);
+int Thin_i2d_RSAPublicKey_bio(BIO *bp, RSA *rsa);
+
+int Thin_i2d_PUBKEY_bio(BIO *bp, EVP_PKEY *pkey);
+
+int Thin_EVP_PKEY_up_ref(EVP_PKEY *pkey);
+
+int Thin_PEM_write_bio_RSAPublicKey(BIO *bp, RSA *x);
+
+int Thin_PEM_write_bio_RSAPrivateKey(BIO *bp, RSA *x, const EVP_CIPHER *enc,
+                                 unsigned char *kstr, int klen,
+                                 pem_password_cb *cb, void *u);
+
+int Thin_PEM_write_bio_PKCS8PrivateKey(BIO *, EVP_PKEY *, const EVP_CIPHER *,
+                                  char *, int, pem_password_cb *, void *);
+
+EVP_PKEY *Thin_d2i_PrivateKey(int type, EVP_PKEY **a, const unsigned char **pp,
+                         long length);
+PKCS8_PRIV_KEY_INFO *Thin_d2i_PKCS8_PRIV_KEY_INFO_bio(BIO *bp,
+                                                 PKCS8_PRIV_KEY_INFO **p8inf);
+
+int Thin_i2d_ECPrivateKey_bio(BIO *bp, EC_KEY *eckey);
+
+int Thin_EC_POINT_oct2point(const EC_GROUP *group, EC_POINT *p,
+                       const unsigned char *buf, size_t len, BN_CTX *ctx);
+
+ASN1_INTEGER *Thin_BN_to_ASN1_INTEGER(const BIGNUM *bn, ASN1_INTEGER *ai);
+BIGNUM *Thin_ASN1_INTEGER_to_BN(const ASN1_INTEGER *ai, BIGNUM *bn);
+
+EC_GROUP *Thin_EC_GROUP_new_by_curve_name(int nid);
+
+PKCS12 *Thin_d2i_PKCS12_bio(BIO *bp, PKCS12 **p12);
+
+void Thin_RSA_get0_factors(const RSA *r, const BIGNUM **p, const BIGNUM **q);
+
+void *Thin_EVP_PKEY_get0(const EVP_PKEY *pkey);
+
+int Thin_i2d_X509(X509 *x, unsigned char **buf);
+
+X509 *Thin_d2i_X509(X509 **p, const unsigned char **in, long len);
+
+const char *Thin_EC_curve_nid2nist(int nid);
+
+int Thin_EC_GROUP_get_curve_name(const EC_GROUP *group);
+
+int Thin_OBJ_obj2nid(const ASN1_OBJECT *o);
+int Thin_RSA_set0_key(RSA *r, BIGNUM *n, BIGNUM *e, BIGNUM *d);
+int Thin_RSA_set0_factors(RSA *r, BIGNUM *p, BIGNUM *q);
+
+RSA *Thin_RSA_new(void);
+int Thin_EVP_PKEY_verify_init(EVP_PKEY_CTX *ctx);
+int Thin_EVP_PKEY_verify(EVP_PKEY_CTX *ctx,
+                    const unsigned char *sig, size_t siglen,
+                    const unsigned char *tbs, size_t tbslen);
+
+void Thin_RSA_get0_crt_params(const RSA *r,
+                         const BIGNUM **dmp1, const BIGNUM **dmq1,
+                         const BIGNUM **iqmp);
+
+int Thin_EVP_PKEY_set1_RSA(EVP_PKEY *pkey, struct rsa_st *key);
+const RSA_PSS_PARAMS *Thin_RSA_get0_pss_params(const RSA *r);
+
+int Thin_RSA_set0_crt_params(RSA *r,BIGNUM *dmp1, BIGNUM *dmq1, BIGNUM *iqmp);
+
+PKCS8_PRIV_KEY_INFO *Thin_EVP_PKEY2PKCS8(EVP_PKEY *pkey);
+
+const char *Thin_OBJ_nid2ln(int n);
+
+int Thin_i2d_PKCS8_PRIV_KEY_INFO_bio(BIO *bp, PKCS8_PRIV_KEY_INFO *p8inf);
+
+ECDSA_SIG *Thin_ECDSA_SIG_new(void);
+
+int Thin_i2d_ECDSA_SIG(const ECDSA_SIG *sig, unsigned char **pp);
+
+int Thin_EVP_DigestSignInit(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,
+                                  const EVP_MD *type, ENGINE *e,
+                                  EVP_PKEY *pkey);
+
+int Thin_EVP_DigestVerifyInit(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,
+                                const EVP_MD *type, ENGINE *e,
+                                EVP_PKEY *pkey);
+int Thin_i2d_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,
+                            char *kstr, int klen,
+                            pem_password_cb *cb, void *u);
+EVP_PKEY *Thin_d2i_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY **x, pem_password_cb *cb,
+                                  void *u);
+
+EVP_PKEY *Thin_EVP_PKCS82PKEY(const PKCS8_PRIV_KEY_INFO *p8);
+
+int Thin_i2d_RSAPrivateKey_bio(BIO *bp, RSA *rsa);
+
+EVP_PKEY *Thin_d2i_PublicKey(int type, EVP_PKEY **a, const unsigned char **pp,
+                        long length);
+
+int Thin_PEM_write_bio_ECPrivateKey(BIO *bp, ec_key_st *x, const EVP_CIPHER *enc,
+                              unsigned char *kstr, int klen,
+                              pem_password_cb *cb, void *u);
+ 
+int Thin_EVP_DigestSign(EVP_MD_CTX *ctx, unsigned char *sigret,
+                          size_t *siglen, const unsigned char *tbs,
+                          size_t tbslen);
+int Thin_EVP_DigestVerify(EVP_MD_CTX *ctx, const unsigned char *sigret,
+                            size_t siglen, const unsigned char *tbs,
+                            size_t tbslen);
+point_conversion_form_t Thin_EC_KEY_get_conv_form(const EC_KEY *key);
+
+int Thin_PEM_write_bio_X509(BIO *bp, X509 *x);
+int Thin_PEM_write_X509(FILE *fp, X509 *x);
+
+ECDSA_SIG *Thin_d2i_ECDSA_SIG(ECDSA_SIG **sig, const unsigned char **pp, long len);
+void Thin_ECDSA_SIG_get0(const ECDSA_SIG *sig, const BIGNUM **pr, const BIGNUM **ps);
+const BIGNUM *Thin_ECDSA_SIG_get0_r(const ECDSA_SIG *sig);
+const BIGNUM *Thin_ECDSA_SIG_get0_s(const ECDSA_SIG *sig);
+int Thin_ECDSA_SIG_set0(ECDSA_SIG *sig, BIGNUM *r, BIGNUM *s);
+
+STACK_OF(X509_NAME) *Thin_SSL_CTX_get_client_CA_list(const SSL_CTX *s);
+int Thin_ASN1_STRING_to_UTF8(unsigned char **out, const ASN1_STRING *in);
+
+int Thin_EVP_DigestSignFinal(EVP_MD_CTX *ctx, unsigned char *sigret, size_t *siglen);
+void Thin_SSL_CTX_set_client_cert_cb(SSL_CTX *ctx,
+                                int (*client_cert_cb) (SSL *ssl, X509 **x509,
+                                                       EVP_PKEY **pkey));
+
+STACK_OF(X509_NAME) *Thin_SSL_get_client_CA_list(const SSL *s);
+char *Thin_X509_NAME_oneline(const X509_NAME *a, char *buf, int size);
+
+unsigned char *Thin_SHA1(const unsigned char *d, size_t n, unsigned char *md);
+
+int Thin_BN_print(BIO *bio, const BIGNUM *a);
+int Thin_BIO_printf(BIO *bio, const char *format, ...);
+void Thin_ERR_print_errors_cb(int (*cb) (const char *str, size_t len, void *u), void *u);
+
+OSSL_PROVIDER *Thin_OSSL_PROVIDER_load(OSSL_LIB_CTX *, const char *name);
+int Thin_OSSL_PROVIDER_unload(OSSL_PROVIDER *prov);
+
+int Thin_EVP_default_properties_is_fips_enabled(OSSL_LIB_CTX *libctx);
+BIGNUM *Thin_BN_get_rfc2409_prime_768(BIGNUM *bn);
+BIGNUM *Thin_BN_get_rfc2409_prime_1024(BIGNUM *bn);
+
+void Thin_EVP_MD_free(EVP_MD *md);
+int Thin_EVP_PKEY_eq(const EVP_PKEY *a, const EVP_PKEY *b);
+EVP_CIPHER *Thin_EVP_CIPHER_fetch(OSSL_LIB_CTX *ctx, const char *algorithm, const char *properties);
+const char *Thin_EVP_CIPHER_get0_name(const EVP_CIPHER *cipher);
+void Thin_EVP_CIPHER_free(EVP_CIPHER *cipher);
+EVP_MD *Thin_EVP_MD_fetch(OSSL_LIB_CTX *ctx, const char *algorithm, const char *properties);
+const char *Thin_EVP_MD_get0_name(const EVP_MD *md);
+int Thin_EVP_default_properties_enable_fips(OSSL_LIB_CTX *libctx, int enable);
+int Thin_EVP_CIPHER_CTX_get_nid(const EVP_CIPHER_CTX *ctx);
+
+#endif // SRC_CRYPTO_CRYPTO_INL_H_
\ No newline at end of file
diff --git a/src/crypto/crypto_x509.cc b/src/crypto/crypto_x509.cc
index 1c208f5d1a..cc3d3e38ed 100644
--- a/src/crypto/crypto_x509.cc
+++ b/src/crypto/crypto_x509.cc
@@ -40,14 +40,14 @@ ManagedX509& ManagedX509::operator=(const ManagedX509& that) {
   cert_.reset(that.get());
 
   if (cert_)
-    X509_up_ref(cert_.get());
+    Thin_X509_up_ref(cert_.get());
 
   return *this;
 }
 
 void ManagedX509::MemoryInfo(MemoryTracker* tracker) const {
   // This is an approximation based on the der encoding size.
-  int size = i2d_X509(cert_.get(), nullptr);
+  int size = Thin_i2d_X509(cert_.get(), nullptr);
   tracker->TrackFieldWithSize("cert", size);
 }
 
@@ -123,11 +123,11 @@ MaybeLocal<Object> X509Certificate::GetCert(
     Environment* env,
     const SSLPointer& ssl) {
   ClearErrorOnReturn clear_error_on_return;
-  X509* cert = SSL_get_certificate(ssl.get());
+  X509* cert = Thin_SSL_get_certificate(ssl.get());
   if (cert == nullptr)
     return MaybeLocal<Object>();
 
-  X509Pointer ptr(X509_dup(cert));
+  X509Pointer ptr(Thin_X509_dup(cert));
   return New(env, std::move(ptr));
 }
 
@@ -142,19 +142,19 @@ MaybeLocal<Object> X509Certificate::GetPeerCert(
   bool is_server =
       static_cast<int>(flag) & static_cast<int>(GetPeerCertificateFlag::SERVER);
 
-  X509Pointer cert(is_server ? SSL_get_peer_certificate(ssl.get()) : nullptr);
-  STACK_OF(X509)* ssl_certs = SSL_get_peer_cert_chain(ssl.get());
-  if (!cert && (ssl_certs == nullptr || sk_X509_num(ssl_certs) == 0))
+  X509Pointer cert(is_server ? Thin_SSL_get_peer_certificate(ssl.get()) : nullptr);
+  STACK_OF(X509)* ssl_certs = Thin_SSL_get_peer_cert_chain(ssl.get());
+  if (!cert && (ssl_certs == nullptr || Thin_sk_X509_num(ssl_certs) == 0))
     return MaybeLocal<Object>();
 
   std::vector<Local<Value>> certs;
 
   if (!cert) {
-    cert.reset(sk_X509_value(ssl_certs, 0));
-    sk_X509_delete(ssl_certs, 0);
+    cert.reset(Thin_sk_X509_value(ssl_certs, 0));
+    Thin_sk_X509_delete(ssl_certs, 0);
   }
 
-  return sk_X509_num(ssl_certs)
+  return Thin_sk_X509_num(ssl_certs)
       ? New(env, std::move(cert), ssl_certs)
       : New(env, std::move(cert));
 }
@@ -170,19 +170,19 @@ void X509Certificate::Parse(const FunctionCallbackInfo<Value>& args) {
   ClearErrorOnReturn clear_error_on_return;
   BIOPointer bio(LoadBIO(env, args[0]));
   if (!bio)
-    return ThrowCryptoError(env, ERR_get_error());
+    return ThrowCryptoError(env, Thin_ERR_get_error());
 
   Local<Object> cert;
 
-  X509Pointer pem(PEM_read_bio_X509_AUX(
+  X509Pointer pem(Thin_PEM_read_bio_X509_AUX(
       bio.get(), nullptr, NoPasswordCallback, nullptr));
   if (!pem) {
     // Try as DER, but return the original PEM failure if it isn't DER.
     MarkPopErrorOnReturn mark_here;
 
-    X509Pointer der(d2i_X509(nullptr, &data, data_len));
+    X509Pointer der(Thin_d2i_X509(nullptr, &data, data_len));
     if (!der)
-      return ThrowCryptoError(env, ERR_get_error());
+      return ThrowCryptoError(env, Thin_ERR_get_error());
 
     if (!X509Certificate::New(env, std::move(der)).ToLocal(&cert))
       return;
@@ -197,7 +197,7 @@ void X509Certificate::Subject(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   X509Certificate* cert;
   ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
-  BIOPointer bio(BIO_new(BIO_s_mem()));
+  BIOPointer bio(Thin_BIO_new(Thin_BIO_s_mem()));
   CHECK(bio);
   Local<Value> ret;
   if (GetSubject(env, bio, cert->get()).ToLocal(&ret))
@@ -208,7 +208,7 @@ void X509Certificate::Issuer(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   X509Certificate* cert;
   ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
-  BIOPointer bio(BIO_new(BIO_s_mem()));
+  BIOPointer bio(Thin_BIO_new(Thin_BIO_s_mem()));
   CHECK(bio);
   Local<Value> ret;
   if (GetIssuerString(env, bio, cert->get()).ToLocal(&ret))
@@ -219,7 +219,7 @@ void X509Certificate::SubjectAltName(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   X509Certificate* cert;
   ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
-  BIOPointer bio(BIO_new(BIO_s_mem()));
+  BIOPointer bio(Thin_BIO_new(Thin_BIO_s_mem()));
   CHECK(bio);
   Local<Value> ret;
   if (GetSubjectAltNameString(env, bio, cert->get()).ToLocal(&ret))
@@ -230,7 +230,7 @@ void X509Certificate::InfoAccess(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   X509Certificate* cert;
   ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
-  BIOPointer bio(BIO_new(BIO_s_mem()));
+  BIOPointer bio(Thin_BIO_new(Thin_BIO_s_mem()));
   CHECK(bio);
   Local<Value> ret;
   if (GetInfoAccessString(env, bio, cert->get()).ToLocal(&ret))
@@ -241,7 +241,7 @@ void X509Certificate::ValidFrom(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   X509Certificate* cert;
   ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
-  BIOPointer bio(BIO_new(BIO_s_mem()));
+  BIOPointer bio(Thin_BIO_new(Thin_BIO_s_mem()));
   CHECK(bio);
   Local<Value> ret;
   if (GetValidFrom(env, cert->get(), bio).ToLocal(&ret))
@@ -252,7 +252,7 @@ void X509Certificate::ValidTo(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   X509Certificate* cert;
   ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
-  BIOPointer bio(BIO_new(BIO_s_mem()));
+  BIOPointer bio(Thin_BIO_new(Thin_BIO_s_mem()));
   CHECK(bio);
   Local<Value> ret;
   if (GetValidTo(env, cert->get(), bio).ToLocal(&ret))
@@ -264,7 +264,7 @@ void X509Certificate::Fingerprint(const FunctionCallbackInfo<Value>& args) {
   X509Certificate* cert;
   ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
   Local<Value> ret;
-  if (GetFingerprintDigest(env, EVP_sha1(), cert->get()).ToLocal(&ret))
+  if (GetFingerprintDigest(env, Thin_EVP_sha1(), cert->get()).ToLocal(&ret))
     args.GetReturnValue().Set(ret);
 }
 
@@ -273,7 +273,7 @@ void X509Certificate::Fingerprint256(const FunctionCallbackInfo<Value>& args) {
   X509Certificate* cert;
   ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
   Local<Value> ret;
-  if (GetFingerprintDigest(env, EVP_sha256(), cert->get()).ToLocal(&ret))
+  if (GetFingerprintDigest(env, Thin_EVP_sha256(), cert->get()).ToLocal(&ret))
     args.GetReturnValue().Set(ret);
 }
 
@@ -282,7 +282,7 @@ void X509Certificate::Fingerprint512(const FunctionCallbackInfo<Value>& args) {
   X509Certificate* cert;
   ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
   Local<Value> ret;
-  if (GetFingerprintDigest(env, EVP_sha512(), cert->get()).ToLocal(&ret))
+  if (GetFingerprintDigest(env, Thin_EVP_sha512(), cert->get()).ToLocal(&ret))
     args.GetReturnValue().Set(ret);
 }
 
@@ -318,11 +318,11 @@ void X509Certificate::PublicKey(const FunctionCallbackInfo<Value>& args) {
   X509Certificate* cert;
   ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
 
-  // TODO(tniessen): consider checking X509_get_pubkey() when the
+  // TODO(tniessen): consider checking Thin_X509_get_pubkey() when the
   // X509Certificate object is being created.
   ClearErrorOnReturn clear_error_on_return;
-  EVPKeyPointer pkey(X509_get_pubkey(cert->get()));
-  if (!pkey) return ThrowCryptoError(env, ERR_get_error());
+  EVPKeyPointer pkey(Thin_X509_get_pubkey(cert->get()));
+  if (!pkey) return ThrowCryptoError(env, Thin_ERR_get_error());
   ManagedEVPPKey epkey(std::move(pkey));
   std::shared_ptr<KeyObjectData> key_data =
       KeyObjectData::CreateAsymmetric(kKeyTypePublic, epkey);
@@ -336,9 +336,9 @@ void X509Certificate::Pem(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   X509Certificate* cert;
   ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
-  BIOPointer bio(BIO_new(BIO_s_mem()));
+  BIOPointer bio(Thin_BIO_new(Thin_BIO_s_mem()));
   CHECK(bio);
-  if (PEM_write_bio_X509(bio.get(), cert->get()))
+  if (Thin_PEM_write_bio_X509(bio.get(), cert->get()))
     args.GetReturnValue().Set(ToV8Value(env, bio));
 }
 
@@ -346,7 +346,7 @@ void X509Certificate::CheckCA(const FunctionCallbackInfo<Value>& args) {
   X509Certificate* cert;
   ClearErrorOnReturn clear_error_on_return;
   ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
-  args.GetReturnValue().Set(X509_check_ca(cert->get()) == 1);
+  args.GetReturnValue().Set(Thin_X509_check_ca(cert->get()) == 1);
 }
 
 void X509Certificate::CheckHost(const FunctionCallbackInfo<Value>& args) {
@@ -361,7 +361,7 @@ void X509Certificate::CheckHost(const FunctionCallbackInfo<Value>& args) {
   uint32_t flags = args[1].As<Uint32>()->Value();
   char* peername;
 
-  switch (X509_check_host(
+  switch (Thin_X509_check_host(
               cert->get(),
               *name,
               name.length(),
@@ -371,7 +371,7 @@ void X509Certificate::CheckHost(const FunctionCallbackInfo<Value>& args) {
       Local<Value> ret = args[0];
       if (peername != nullptr) {
         ret = OneByteString(env->isolate(), peername);
-        OPENSSL_free(peername);
+        Thin_OPENSSL_free(peername);
       }
       return args.GetReturnValue().Set(ret);
     }
@@ -395,7 +395,7 @@ void X509Certificate::CheckEmail(const FunctionCallbackInfo<Value>& args) {
   Utf8Value name(env->isolate(), args[0]);
   uint32_t flags = args[1].As<Uint32>()->Value();
 
-  switch (X509_check_email(
+  switch (Thin_X509_check_email(
               cert->get(),
               *name,
               name.length(),
@@ -422,7 +422,7 @@ void X509Certificate::CheckIP(const FunctionCallbackInfo<Value>& args) {
   Utf8Value name(env->isolate(), args[0]);
   uint32_t flags = args[1].As<Uint32>()->Value();
 
-  switch (X509_check_ip_asc(cert->get(), *name, flags)) {
+  switch (Thin_X509_check_ip_asc(cert->get(), *name, flags)) {
     case 1:  // Match!
       return args.GetReturnValue().Set(args[0]);
     case 0:  // No Match!
@@ -448,7 +448,7 @@ void X509Certificate::CheckIssued(const FunctionCallbackInfo<Value>& args) {
   ClearErrorOnReturn clear_error_on_return;
 
   args.GetReturnValue().Set(
-    X509_check_issued(issuer->get(), cert->get()) == X509_V_OK);
+    Thin_X509_check_issued(issuer->get(), cert->get()) == X509_V_OK);
 }
 
 void X509Certificate::CheckPrivateKey(const FunctionCallbackInfo<Value>& args) {
@@ -463,7 +463,7 @@ void X509Certificate::CheckPrivateKey(const FunctionCallbackInfo<Value>& args) {
   ClearErrorOnReturn clear_error_on_return;
 
   args.GetReturnValue().Set(
-      X509_check_private_key(
+      Thin_X509_check_private_key(
           cert->get(),
           key->Data()->GetAsymmetricKey().get()) == 1);
 }
@@ -480,7 +480,7 @@ void X509Certificate::Verify(const FunctionCallbackInfo<Value>& args) {
   ClearErrorOnReturn clear_error_on_return;
 
   args.GetReturnValue().Set(
-      X509_verify(
+      Thin_X509_verify(
           cert->get(),
           key->Data()->GetAsymmetricKey().get()) > 0);
 }
@@ -511,10 +511,10 @@ X509Certificate::X509Certificate(
       cert_(std::move(cert)) {
   MakeWeak();
 
-  if (issuer_chain != nullptr && sk_X509_num(issuer_chain)) {
-    X509Pointer cert(X509_dup(sk_X509_value(issuer_chain, 0)));
-    sk_X509_delete(issuer_chain, 0);
-    Local<Object> obj = sk_X509_num(issuer_chain)
+  if (issuer_chain != nullptr && Thin_sk_X509_num(issuer_chain)) {
+    X509Pointer cert(Thin_X509_dup(Thin_sk_X509_value(issuer_chain, 0)));
+    Thin_sk_X509_delete(issuer_chain, 0);
+    Local<Object> obj = Thin_sk_X509_num(issuer_chain)
         ? X509Certificate::New(env, std::move(cert), issuer_chain)
             .ToLocalChecked()
         : X509Certificate::New(env, std::move(cert))
diff --git a/src/node.cc b/src/node.cc
index 909de94b5d..24fe5957f4 100644
--- a/src/node.cc
+++ b/src/node.cc
@@ -947,7 +947,7 @@ std::unique_ptr<InitializationResult> InitializeOncePerProcess(
 #if HAVE_OPENSSL && !defined(OPENSSL_IS_BORINGSSL)
     auto GetOpenSSLErrorString = []() -> std::string {
       std::string ret;
-      ERR_print_errors_cb(
+      Thin_ERR_print_errors_cb(
           [](const char* str, size_t len, void* opaque) {
             std::string* ret = static_cast<std::string*>(opaque);
             ret->append(str, len);
@@ -966,7 +966,7 @@ std::unique_ptr<InitializationResult> InitializeOncePerProcess(
     // In the case of FIPS builds we should make sure
     // the random source is properly initialized first.
 #if OPENSSL_VERSION_MAJOR >= 3
-    // Call OPENSSL_init_crypto to initialize OPENSSL_INIT_LOAD_CONFIG to
+    // Call Thin_OPENSSL_init_crypto to initialize OPENSSL_INIT_LOAD_CONFIG to
     // avoid the default behavior where errors raised during the parsing of the
     // OpenSSL configuration file are not propagated and cannot be detected.
     //
@@ -977,7 +977,7 @@ std::unique_ptr<InitializationResult> InitializeOncePerProcess(
     //
     // For Node.js this will mean that CSPRNG() will be called by V8 as
     // part of its initialization process, and CSPRNG() will in turn call
-    // call RAND_status which will now always return 0, leading to an endless
+    // call Thin_RAND_status which will now always return 0, leading to an endless
     // loop and the node process will appear to hang/freeze.
 
     // Passing NULL as the config file will allow the default openssl.cnf file
@@ -1002,33 +1002,33 @@ std::unique_ptr<InitializationResult> InitializeOncePerProcess(
       conf_file = per_process::cli_options->openssl_config.c_str();
     }
 
-    OPENSSL_INIT_SETTINGS* settings = OPENSSL_INIT_new();
-    OPENSSL_INIT_set_config_filename(settings, conf_file);
-    OPENSSL_INIT_set_config_appname(settings, conf_section_name);
-    OPENSSL_INIT_set_config_file_flags(settings,
+    OPENSSL_INIT_SETTINGS* settings = Thin_OPENSSL_INIT_new();
+    Thin_OPENSSL_INIT_set_config_filename(settings, conf_file);
+    Thin_OPENSSL_INIT_set_config_appname(settings, conf_section_name);
+    Thin_OPENSSL_INIT_set_config_file_flags(settings,
                                        CONF_MFLAGS_IGNORE_MISSING_FILE);
 
-    OPENSSL_init_crypto(OPENSSL_INIT_LOAD_CONFIG, settings);
-    OPENSSL_INIT_free(settings);
+    Thin_OPENSSL_init_crypto(OPENSSL_INIT_LOAD_CONFIG, settings);
+    Thin_OPENSSL_INIT_free(settings);
 
-    if (ERR_peek_error() != 0) {
+    if (Thin_ERR_peek_error() != 0) {
       // XXX: ERR_GET_REASON does not return something that is
       // useful as an exit code at all.
-      result->exit_code_ = ERR_GET_REASON(ERR_peek_error());
+      result->exit_code_ = ERR_GET_REASON(Thin_ERR_peek_error());
       result->early_return_ = true;
       result->errors_.emplace_back("OpenSSL configuration error:\n" +
                                    GetOpenSSLErrorString());
       return result;
     }
 #else  // OPENSSL_VERSION_MAJOR < 3
-    if (FIPS_mode()) {
-      OPENSSL_init();
+    if (Thin_FIPS_mode()) {
+      Thin_OPENSSL_init();
     }
 #endif
     if (!crypto::ProcessFipsOptions()) {
       // XXX: ERR_GET_REASON does not return something that is
       // useful as an exit code at all.
-      result->exit_code_ = ERR_GET_REASON(ERR_peek_error());
+      result->exit_code_ = ERR_GET_REASON(Thin_ERR_peek_error());
       result->early_return_ = true;
       result->errors_.emplace_back(
           "OpenSSL error when trying to enable FIPS:\n" +
-- 
2.25.1

