From 22a1b7bc2d1cfd8a48ed1987a139ba377e65de3f Mon Sep 17 00:00:00 2001
From: Lin Cheng <lin_cheng@dell.com>
Date: Wed, 1 Jun 2022 22:46:37 +0800
Subject: [PATCH] src: support SSL select client cert callback on tls socket

Node TLS connection support SSLSelectClientCertCallback function
tls.options add onselectclientcert
---
 lib/_tls_wrap.js             |  2 ++
 src/crypto/crypto_context.cc |  8 ++++++
 src/crypto/crypto_context.h  |  3 +++
 src/crypto/crypto_tls.cc     | 47 ++++++++++++++++++++++++++++++++++++
 src/crypto/crypto_tls.h      |  1 +
 src/env.h                    |  1 +
 6 files changed, 62 insertions(+)

diff --git a/lib/_tls_wrap.js b/lib/_tls_wrap.js
index 57399c602a..8a686b7c13 100644
--- a/lib/_tls_wrap.js
+++ b/lib/_tls_wrap.js
@@ -725,6 +725,7 @@ TLSSocket.prototype._init = function(socket, wrap) {
       this._finishInit();
     };
     ssl.onocspresponse = onocspresponse;
+    ssl.onselectclientcert = options.onselectclientcert;
 
     if (options.session)
       ssl.setSession(options.session);
@@ -1635,6 +1636,7 @@ exports.connect = function connect(...args) {
     highWaterMark: options.highWaterMark,
     onread: options.onread,
     signal: options.signal,
+    onselectclientcert: options.onselectclientcert,
   });
 
   // rejectUnauthorized property can be explicitly defined as `undefined`
diff --git a/src/crypto/crypto_context.cc b/src/crypto/crypto_context.cc
index 739b559c3b..2ed08bd96a 100644
--- a/src/crypto/crypto_context.cc
+++ b/src/crypto/crypto_context.cc
@@ -227,6 +227,7 @@ X509_STORE* NewRootCertStore() {
       X509_STORE_add_cert(store, cert);
     }
   }
+  X509_STORE_set_flags(store, X509_V_FLAG_PARTIAL_CHAIN);
 
   return store;
 }
@@ -404,6 +405,7 @@ inline void SecureContext::Reset() {
   ctx_.reset();
   cert_.reset();
   issuer_.reset();
+  client_key_provided_ = false;
 }
 
 SecureContext::~SecureContext() {
@@ -563,6 +565,10 @@ void SecureContext::SetSelectSNIContextCallback(SelectSNIContextCb cb) {
   SSL_CTX_set_tlsext_servername_callback(ctx_.get(), cb);
 }
 
+void SecureContext::SetSelectClientCertCallback(SelectClientCertCb cb) {
+  SSL_CTX_set_client_cert_cb(ctx_.get(), cb);
+}
+
 void SecureContext::SetKeylogCallback(KeylogCb cb) {
   SSL_CTX_set_keylog_callback(ctx_.get(), cb);
 }
@@ -598,6 +604,8 @@ void SecureContext::SetKey(const FunctionCallbackInfo<Value>& args) {
 
   if (!SSL_CTX_use_PrivateKey(sc->ctx_.get(), key.get()))
     return ThrowCryptoError(env, ERR_get_error(), "SSL_CTX_use_PrivateKey");
+
+  sc->client_key_provided_ = true;
 }
 
 void SecureContext::SetSigalgs(const FunctionCallbackInfo<Value>& args) {
diff --git a/src/crypto/crypto_context.h b/src/crypto/crypto_context.h
index d9b33a4736..2fd953aa42 100644
--- a/src/crypto/crypto_context.h
+++ b/src/crypto/crypto_context.h
@@ -31,6 +31,7 @@ class SecureContext final : public BaseObject {
   using KeylogCb = void (*)(const SSL*, const char*);
   using NewSessionCb = int (*)(SSL*, SSL_SESSION*);
   using SelectSNIContextCb = int (*)(SSL*, int*, void*);
+  using SelectClientCertCb = int (*)(SSL*, X509 **, EVP_PKEY **);
 
   ~SecureContext() override;
 
@@ -51,6 +52,7 @@ class SecureContext final : public BaseObject {
   void SetKeylogCallback(KeylogCb cb);
   void SetNewSessionCallback(NewSessionCb cb);
   void SetSelectSNIContextCallback(SelectSNIContextCb cb);
+  void SetSelectClientCertCallback(SelectClientCertCb cb);
 
   // TODO(joyeecheung): track the memory used by OpenSSL types
   SET_NO_MEMORY_INFO()
@@ -65,6 +67,7 @@ class SecureContext final : public BaseObject {
   EnginePointer private_key_engine_;
 #endif  // !OPENSSL_NO_ENGINE
 
+  bool client_key_provided_ = false;
   static const int kMaxSessionSize = 10 * 1024;
 
   // See TicketKeyCallback
diff --git a/src/crypto/crypto_tls.cc b/src/crypto/crypto_tls.cc
index cfe760adb3..8054ca5104 100644
--- a/src/crypto/crypto_tls.cc
+++ b/src/crypto/crypto_tls.cc
@@ -61,6 +61,7 @@ using v8::String;
 using v8::True;
 using v8::Uint32;
 using v8::Value;
+using errors::TryCatchScope;
 
 namespace crypto {
 
@@ -427,6 +428,10 @@ void TLSWrap::InitSSL() {
   if (is_server())
     sc_->SetSelectSNIContextCallback(SelectSNIContextCallback);
 
+  if (is_client() && !sc_->client_key_provided_) {
+    sc_->SetSelectClientCertCallback(SelectClientCertCallback);
+  }
+
   ConfigureSecureContext(sc_.get());
 
   SSL_set_cert_cb(ssl_.get(), SSLCertCallback, this);
@@ -751,6 +756,7 @@ void TLSWrap::ClearOut() {
     int err = GetSSLError(read);
     switch (err) {
       case SSL_ERROR_ZERO_RETURN:
+      case SSL_ERROR_WANT_X509_LOOKUP:
         // Ignore ZERO_RETURN after EOF, it is basically not an error.
         if (eof_) return;
         error = env()->zero_return_string();
@@ -795,6 +801,9 @@ void TLSWrap::ClearOut() {
         return;
     }
 
+    if (err == SSL_ERROR_WANT_X509_LOOKUP) {
+      eof_ = true;
+    }
     Debug(this, "Got SSL error (%d), calling onerror", err);
     // When TLS Alert are stored in wbio,
     // it should be flushed to socket before destroyed.
@@ -1311,6 +1320,44 @@ int TLSWrap::SelectSNIContextCallback(SSL* s, int* ad, void* arg) {
   return SSL_TLSEXT_ERR_OK;
 }
 
+int TLSWrap::SelectClientCertCallback(SSL* s, X509 **cert, EVP_PKEY ** key) {
+  TLSWrap* p = static_cast<TLSWrap*>(SSL_get_app_data(s));
+  if (!p->is_client())
+    return 0;
+
+  Environment* env = p->env();
+  Local<Object> object = p->object();
+  Local<Value> onselectclientcert = object->Get(env->context(),
+                                                env->onselectclientcert_string()).ToLocalChecked();
+
+  // Not an function, probably undefined or null
+  if (onselectclientcert->IsUndefined() || !onselectclientcert->IsFunction()) {
+    return 0;
+  }
+
+  Local<Array> distinguishedNames = Array::New(env->isolate());
+  char buf[BUFSIZ];
+  STACK_OF(X509_NAME) * sk = SSL_get_client_CA_list(s);
+  X509_NAME *name;
+  if (sk != NULL && (sk_X509_NAME_num(sk) > 0)) {
+    for (int i = 0; i < sk_X509_NAME_num(sk); i++) {
+      name = sk_X509_NAME_value(sk, i);
+      X509_NAME_oneline(name, buf, sizeof(buf));
+      distinguishedNames->Set(env->context(), i, OneByteString(env->isolate(), buf)).Check();
+    }
+  }
+  int value_int = 0;
+  Local<Value> value;
+  Local<Value> argv[] = { distinguishedNames };
+  TryCatchScope try_catch(env);
+  if (!p->MakeCallback(env->onselectclientcert_string(), arraysize(argv), argv).ToLocal(&value) ||
+      !value->Int32Value(env->context()).To(&value_int)) {
+        if (try_catch.HasCaught() && !try_catch.HasTerminated())
+          errors::TriggerUncaughtException(env->isolate(), try_catch);
+  }
+  return value_int;
+}
+
 int TLSWrap::SetCACerts(SecureContext* sc) {
   int err = SSL_set1_verify_cert_store(
       ssl_.get(), SSL_CTX_get_cert_store(sc->ctx_.get()));
diff --git a/src/crypto/crypto_tls.h b/src/crypto/crypto_tls.h
index 765c6c476b..226c988d0a 100644
--- a/src/crypto/crypto_tls.h
+++ b/src/crypto/crypto_tls.h
@@ -169,6 +169,7 @@ class TLSWrap : public AsyncWrap,
   int GetSSLError(int status) const;
 
   static int SelectSNIContextCallback(SSL* s, int* ad, void* arg);
+  static int SelectClientCertCallback(SSL* s, X509 **cert, EVP_PKEY ** key);
 
   static void CertCbDone(const v8::FunctionCallbackInfo<v8::Value>& args);
   static void DestroySSL(const v8::FunctionCallbackInfo<v8::Value>& args);
diff --git a/src/env.h b/src/env.h
index 1fbf965788..6270ff1c4b 100644
--- a/src/env.h
+++ b/src/env.h
@@ -350,6 +350,7 @@ constexpr size_t kFsStatsBufferLength =
   V(onmessage_string, "onmessage")                                             \
   V(onnewsession_string, "onnewsession")                                       \
   V(onocspresponse_string, "onocspresponse")                                   \
+  V(onselectclientcert_string, "onselectclientcert")                           \
   V(onreadstart_string, "onreadstart")                                         \
   V(onreadstop_string, "onreadstop")                                           \
   V(onshutdown_string, "onshutdown")                                           \
-- 
2.25.1

