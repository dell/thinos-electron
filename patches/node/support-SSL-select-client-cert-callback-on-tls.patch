From 388f6c38ff88f7d383086f7d9ecbdd2ee53f8287 Mon Sep 17 00:00:00 2001
From: Lin Cheng <lin_cheng@dell.com>
Date: Mon, 4 Sep 2023 09:39:41 +0000
Subject: [PATCH] src: support SSL select client cert callback on tls socket

NodeJS TLS connection support SSLSelectClientCertCallback function
tls.options add onselectclientcert
---
 lib/_tls_wrap.js             |  2 ++
 src/crypto/crypto_context.cc |  6 +++++
 src/crypto/crypto_context.h  |  4 ++-
 src/crypto/crypto_tls.cc     | 48 +++++++++++++++++++++++++++++++++++-
 src/crypto/crypto_tls.h      |  2 +-
 src/env_properties.h         |  1 +
 6 files changed, 60 insertions(+), 3 deletions(-)

diff --git a/lib/_tls_wrap.js b/lib/_tls_wrap.js
index 819dac9c43..c8b444a884 100644
--- a/lib/_tls_wrap.js
+++ b/lib/_tls_wrap.js
@@ -743,6 +743,7 @@ TLSSocket.prototype._init = function(socket, wrap) {
       this._finishInit();
     };
     ssl.onocspresponse = onocspresponse;
+    ssl.onselectclientcert = options.onselectclientcert;
 
     if (options.session)
       ssl.setSession(options.session);
@@ -1645,6 +1646,7 @@ exports.connect = function connect(...args) {
     highWaterMark: options.highWaterMark,
     onread: options.onread,
     signal: options.signal,
+    onselectclientcert: options.onselectclientcert,
   });
 
   // rejectUnauthorized property can be explicitly defined as `undefined`
diff --git a/src/crypto/crypto_context.cc b/src/crypto/crypto_context.cc
index 0262dee543..34ff222dbd 100644
--- a/src/crypto/crypto_context.cc
+++ b/src/crypto/crypto_context.cc
@@ -411,6 +411,7 @@ inline void SecureContext::Reset() {
   ctx_.reset();
   cert_.reset();
   issuer_.reset();
+  client_key_provided_ = false;
 }
 
 SecureContext::~SecureContext() {
@@ -573,6 +574,10 @@ void SecureContext::SetSelectSNIContextCallback(SelectSNIContextCb cb) {
   SSL_CTX_set_tlsext_servername_callback(ctx_.get(), cb);
 }
 
+void SecureContext::SetSelectClientCertCallback(SelectClientCertCb cb) {
+  SSL_CTX_set_client_cert_cb(ctx_.get(), cb);
+}
+
 void SecureContext::SetKeylogCallback(KeylogCb cb) {
   SSL_CTX_set_keylog_callback(ctx_.get(), cb);
 }
@@ -624,6 +629,7 @@ void SecureContext::SetKey(const FunctionCallbackInfo<Value>& args) {
 
   if (!SSL_CTX_use_PrivateKey(sc->ctx_.get(), key.get()))
     return ThrowCryptoError(env, ERR_get_error(), "SSL_CTX_use_PrivateKey");
+  sc->client_key_provided_ = true;
 }
 
 void SecureContext::SetSigalgs(const FunctionCallbackInfo<Value>& args) {
diff --git a/src/crypto/crypto_context.h b/src/crypto/crypto_context.h
index 607b0984ba..e0a5602160 100644
--- a/src/crypto/crypto_context.h
+++ b/src/crypto/crypto_context.h
@@ -32,7 +32,7 @@ class SecureContext final : public BaseObject {
   using KeylogCb = void (*)(const SSL*, const char*);
   using NewSessionCb = int (*)(SSL*, SSL_SESSION*);
   using SelectSNIContextCb = int (*)(SSL*, int*, void*);
-
+  using SelectClientCertCb = int (*)(SSL*, X509 **, EVP_PKEY **);
   ~SecureContext() override;
 
   static bool HasInstance(Environment* env, const v8::Local<v8::Value>& value);
@@ -54,6 +54,7 @@ class SecureContext final : public BaseObject {
   void SetKeylogCallback(KeylogCb cb);
   void SetNewSessionCallback(NewSessionCb cb);
   void SetSelectSNIContextCallback(SelectSNIContextCb cb);
+  void SetSelectClientCertCallback(SelectClientCertCb cb);
 
   inline const X509Pointer& issuer() const { return issuer_; }
   inline const X509Pointer& cert() const { return cert_; }
@@ -70,6 +71,7 @@ class SecureContext final : public BaseObject {
   SET_MEMORY_INFO_NAME(SecureContext)
   SET_SELF_SIZE(SecureContext)
 
+  bool client_key_provided_ = false;
   static const int kMaxSessionSize = 10 * 1024;
 
   // See TicketKeyCallback
diff --git a/src/crypto/crypto_tls.cc b/src/crypto/crypto_tls.cc
index 3656f3e206..dd313371d4 100644
--- a/src/crypto/crypto_tls.cc
+++ b/src/crypto/crypto_tls.cc
@@ -60,7 +60,7 @@ using v8::String;
 using v8::True;
 using v8::Uint32;
 using v8::Value;
-
+using errors::TryCatchScope;
 namespace crypto {
 
 namespace {
@@ -417,6 +417,10 @@ void TLSWrap::InitSSL() {
   if (is_server())
     sc_->SetSelectSNIContextCallback(SelectSNIContextCallback);
 
+  if (is_client() && !sc_->client_key_provided_) {
+    sc_->SetSelectClientCertCallback(SelectClientCertCallback);
+  }
+
   ConfigureSecureContext(sc_.get());
 
   SSL_set_cert_cb(ssl_.get(), SSLCertCallback, this);
@@ -733,6 +737,7 @@ void TLSWrap::ClearOut() {
     int err = SSL_get_error(ssl_.get(), read);
     switch (err) {
       case SSL_ERROR_ZERO_RETURN:
+      case SSL_ERROR_WANT_X509_LOOKUP:
         if (!eof_) {
           eof_ = true;
           EmitRead(UV_EOF);
@@ -778,6 +783,9 @@ void TLSWrap::ClearOut() {
         return;
     }
 
+    if (err == SSL_ERROR_WANT_X509_LOOKUP) {
+       eof_ = true;
+    }
     Debug(this, "Got SSL error (%d), calling onerror", err);
     // When TLS Alert are stored in wbio,
     // it should be flushed to socket before destroyed.
@@ -1293,6 +1301,44 @@ int TLSWrap::SelectSNIContextCallback(SSL* s, int* ad, void* arg) {
   return SSL_TLSEXT_ERR_OK;
 }
 
+int TLSWrap::SelectClientCertCallback(SSL* s, X509 **cert, EVP_PKEY ** key) {
+  TLSWrap* p = static_cast<TLSWrap*>(SSL_get_app_data(s));
+  if (!p->is_client())
+    return 0;
+
+  Environment* env = p->env();
+  Local<Object> object = p->object();
+  Local<Value> onselectclientcert = object->Get(env->context(),
+                                                env->onselectclientcert_string()).ToLocalChecked();
+
+  // Not an function, probably undefined or null
+  if (onselectclientcert->IsUndefined() || !onselectclientcert->IsFunction()) {
+    return 0;
+  }
+
+  Local<Array> distinguishedNames = Array::New(env->isolate());
+  char buf[BUFSIZ];
+  STACK_OF(X509_NAME) * sk = SSL_get_client_CA_list(s);
+  X509_NAME *name;
+  if (sk != NULL && (sk_X509_NAME_num(sk) > 0)) {
+    for (int i = 0; i < sk_X509_NAME_num(sk); i++) {
+      name = sk_X509_NAME_value(sk, i);
+      X509_NAME_oneline(name, buf, sizeof(buf));
+      distinguishedNames->Set(env->context(), i, OneByteString(env->isolate(), buf)).Check();
+    }
+  }
+  int value_int = 0;
+  Local<Value> value;
+  Local<Value> argv[] = { distinguishedNames };
+  TryCatchScope try_catch(env);
+  if (!p->MakeCallback(env->onselectclientcert_string(), arraysize(argv), argv).ToLocal(&value) ||
+      !value->Int32Value(env->context()).To(&value_int)) {
+        if (try_catch.HasCaught() && !try_catch.HasTerminated())
+          errors::TriggerUncaughtException(env->isolate(), try_catch);
+  }
+  return value_int;
+}
+
 int TLSWrap::SetCACerts(SecureContext* sc) {
   int err = SSL_set1_verify_cert_store(ssl_.get(),
                                        SSL_CTX_get_cert_store(sc->ctx().get()));
diff --git a/src/crypto/crypto_tls.h b/src/crypto/crypto_tls.h
index 5d1b24ff77..b2c9a70e40 100644
--- a/src/crypto/crypto_tls.h
+++ b/src/crypto/crypto_tls.h
@@ -168,7 +168,7 @@ class TLSWrap : public AsyncWrap,
   int SetCACerts(SecureContext* sc);
 
   static int SelectSNIContextCallback(SSL* s, int* ad, void* arg);
-
+  static int SelectClientCertCallback(SSL* s, X509 **cert, EVP_PKEY ** key);
   static void CertCbDone(const v8::FunctionCallbackInfo<v8::Value>& args);
   static void DestroySSL(const v8::FunctionCallbackInfo<v8::Value>& args);
   static void EnableCertCb(const v8::FunctionCallbackInfo<v8::Value>& args);
diff --git a/src/env_properties.h b/src/env_properties.h
index 26e4e6a754..a021e39dbb 100644
--- a/src/env_properties.h
+++ b/src/env_properties.h
@@ -218,6 +218,7 @@
   V(onmessage_string, "onmessage")                                             \
   V(onnewsession_string, "onnewsession")                                       \
   V(onocspresponse_string, "onocspresponse")                                   \
+  V(onselectclientcert_string, "onselectclientcert")                           \
   V(onreadstart_string, "onreadstart")                                         \
   V(onreadstop_string, "onreadstop")                                           \
   V(onshutdown_string, "onshutdown")                                           \
-- 
2.25.1

